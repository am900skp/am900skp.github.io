<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>QT(常用数据类型) | kpsun</title>
  <meta name="keywords" content=" QT ">
  <meta name="description" content="QT(常用数据类型) | kpsun">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人简介孙楷朋准大二计算机相关专业在读热爱编程,乐于合作,善于总结分享,有良好的的编程习惯目标BAT大厂联系方式 QQ: 1287923885 WeChat: code_cpp Email: &amp;#107;&amp;#112;&amp;#x73;&amp;#117;&amp;#x6e;&amp;#64;&amp;#x66;&amp;#111;&amp;#120;&amp;#109;&amp;#97;&amp;#x69;&amp;#108;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#109;">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="http://goskp.github.io/about/index.html">
<meta property="og:site_name" content="kpsun">
<meta property="og:description" content="个人简介孙楷朋准大二计算机相关专业在读热爱编程,乐于合作,善于总结分享,有良好的的编程习惯目标BAT大厂联系方式 QQ: 1287923885 WeChat: code_cpp Email: &amp;#107;&amp;#112;&amp;#x73;&amp;#117;&amp;#x6e;&amp;#64;&amp;#x66;&amp;#111;&amp;#120;&amp;#109;&amp;#97;&amp;#x69;&amp;#108;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#109;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-14T04:24:56.000Z">
<meta property="article:modified_time" content="2022-09-14T12:29:33.592Z">
<meta property="article:author" content="kpsun">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/o.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="false" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="false" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/o.jpg"/>
</a>
<div class="author">
    <span>kpsun</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(56)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="后端">
                        
                        后端
                        <small>(22)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Qt5开发">
                        
                        Qt5开发
                        <small>(7)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构">
                        
                        数据结构
                        <small>(24)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="计算机硬件">
                        
                        计算机硬件
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="设计模式">
                        
                        设计模式
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="56">
<input type="hidden" id="yelog_site_word_count" value="102.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://fomalhaut1998.github.io/">Fomalhaut1998a</a></li>
            
            <li><a target="_blank" href="https://cnhuazhu.gitee.io/">cnhuazhu</a></li>
            
            <li><a target="_blank" href="https://wangeasycloud.cn/">cheerio</a></li>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://lee-jhong001-github-io.vercel.app/">lee-jhong</a></li>
            
            <li><a target="_blank" href="https://hi-wilson.github.io/">Wilson</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DesignPattern</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>QT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Rust</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据结构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计算机硬件</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/10/07/QT(Designer%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E4%BD%BF%E7%94%A8)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(Designer设计师的使用)">QT(Designer设计师的使用)</span>
            <span class="post-date" title="2022-10-07 15:58:45">2022/10/07</span>
        </a>
        
        
        <a  class="全部文章 设计模式 "
           href="/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"
           data-tag="DesignPattern"
           data-author="" >
            <span class="post-title" title="设计模式-观察者模式">设计模式-观察者模式</span>
            <span class="post-date" title="2022-10-01 10:34:34">2022/10/01</span>
        </a>
        
        
        <a  class="全部文章 算法 "
           href="/2022/09/30/C++%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/"
           data-tag="Algorithm"
           data-author="" >
            <span class="post-title" title="C/C++常用刷题技巧">C/C++常用刷题技巧</span>
            <span class="post-date" title="2022-09-30 15:36:35">2022/09/30</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/29/QT(%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(布局管理器)">QT(布局管理器)</span>
            <span class="post-date" title="2022-09-29 18:53:52">2022/09/29</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/26/QT(%E5%AF%B9%E8%AF%9D%E6%A1%86)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(对话框)">QT(对话框)</span>
            <span class="post-date" title="2022-09-26 07:06:17">2022/09/26</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/23/QT(%E6%8E%A7%E4%BB%B6)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(控件)">QT(控件)</span>
            <span class="post-date" title="2022-09-23 16:07:57">2022/09/23</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/22/QT(QWidget)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(QWidget)">QT(QWidget)</span>
            <span class="post-date" title="2022-09-22 19:09:02">2022/09/22</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/06/QT(%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(信号和槽)">QT(信号和槽)</span>
            <span class="post-date" title="2022-09-06 12:08:32">2022/09/06</span>
        </a>
        
        
        <a  class="全部文章 Qt5开发 "
           href="/2022/09/01/QT(%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)/"
           data-tag="QT"
           data-author="" >
            <span class="post-title" title="QT(常用数据类型)">QT(常用数据类型)</span>
            <span class="post-date" title="2022-09-01 15:32:46">2022/09/01</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/08/31/Rust(1)/"
           data-tag="Rust"
           data-author="" >
            <span class="post-title" title="Rust(1)">Rust(1)</span>
            <span class="post-date" title="2022-08-31 18:39:55">2022/08/31</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9E%E6%BA%AF%E6%B3%95(DP,Queen)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-回溯法(DP,Queen)">数据结构-回溯法(DP,Queen)</span>
            <span class="post-date" title="2022-07-22 16:19:29">2022/07/22</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(DP)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-动态规划(DP)">数据结构-动态规划(DP)</span>
            <span class="post-date" title="2022-07-20 16:18:50">2022/07/20</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(sort)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-排序算法(sort)">数据结构-排序算法(sort)</span>
            <span class="post-date" title="2022-07-18 10:35:06">2022/07/18</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-分而治之">数据结构-分而治之</span>
            <span class="post-date" title="2022-07-17 16:18:25">2022/07/17</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95(graph)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-贪心算法(graph)">数据结构-贪心算法(graph)</span>
            <span class="post-date" title="2022-07-16 16:17:58">2022/07/16</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88(DFS,BFS)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-深度/广度优先(DFS,BFS)">数据结构-深度/广度优先(DFS,BFS)</span>
            <span class="post-date" title="2022-07-15 16:17:01">2022/07/15</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE(graph)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-图(graph)">数据结构-图(graph)</span>
            <span class="post-date" title="2022-07-13 16:16:30">2022/07/13</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91(RB)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-红黑树(RB)">数据结构-红黑树(RB)</span>
            <span class="post-date" title="2022-07-12 16:15:41">2022/07/12</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-平衡二叉树(AVL)">数据结构-平衡二叉树(AVL)</span>
            <span class="post-date" title="2022-07-11 16:15:25">2022/07/11</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C(C++%E6%8F%8F%E8%BF%B0)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-分支定界(C++描述)">数据结构-分支定界(C++描述)</span>
            <span class="post-date" title="2022-07-10 16:14:33">2022/07/10</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91(tree)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-哈夫曼树(tree)">数据结构-哈夫曼树(tree)</span>
            <span class="post-date" title="2022-07-09 16:06:00">2022/07/09</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(tree)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-二叉搜索树(tree)">数据结构-二叉搜索树(tree)</span>
            <span class="post-date" title="2022-07-08 19:34:11">2022/07/08</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91(tree)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-二叉树(tree)">数据结构-二叉树(tree)</span>
            <span class="post-date" title="2022-07-07 08:26:46">2022/07/07</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86(heap)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-堆(heap)">数据结构-堆(heap)</span>
            <span class="post-date" title="2022-07-06 12:50:51">2022/07/06</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8(hash)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-哈希表(hash)">数据结构-哈希表(hash)</span>
            <span class="post-date" title="2022-07-05 18:06:58">2022/07/05</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8(hash)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-哈希存储(hash)">数据结构-哈希存储(hash)</span>
            <span class="post-date" title="2022-07-05 17:12:58">2022/07/05</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B0%81%E8%A3%85string%E7%B1%BB(C++%E6%8F%8F%E8%BF%B0)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-简单封装string类(C++描述)">数据结构-简单封装string类(C++描述)</span>
            <span class="post-date" title="2022-07-04 16:17:52">2022/07/04</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2(string,BF,KMP)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-串(string,BF,KMP)">数据结构-串(string,BF,KMP)</span>
            <span class="post-date" title="2022-07-03 14:36:09">2022/07/03</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97(queue)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-队列(queue)">数据结构-队列(queue)</span>
            <span class="post-date" title="2022-07-02 15:38:29">2022/07/02</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88(stack)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-栈(stack)">数据结构-栈(stack)</span>
            <span class="post-date" title="2022-07-01 20:29:22">2022/07/01</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8(list)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-顺序表(list)">数据结构-顺序表(list)</span>
            <span class="post-date" title="2022-06-30 12:46:33">2022/06/30</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%90%88%E5%B9%B6,%E5%8F%8D%E8%BD%AC,%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8(list)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-合并,反转,有序链表(list)">数据结构-合并,反转,有序链表(list)</span>
            <span class="post-date" title="2022-06-29 10:40:49">2022/06/29</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(list)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-双向链表(list)">数据结构-双向链表(list)</span>
            <span class="post-date" title="2022-06-28 10:34:06">2022/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据结构 "
           href="/2022/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E5%8D%95%E9%93%BE%E8%A1%A8(list)/"
           data-tag="数据结构"
           data-author="" >
            <span class="post-title" title="数据结构-基础单链表(list)">数据结构-基础单链表(list)</span>
            <span class="post-date" title="2022-06-27 20:54:15">2022/06/27</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/26/C++%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++可变参数模板">C++可变参数模板</span>
            <span class="post-date" title="2022-06-26 18:15:05">2022/06/26</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/24/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++正则表达式">C++正则表达式</span>
            <span class="post-date" title="2022-06-24 17:10:54">2022/06/24</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/21/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++智能指针">C++智能指针</span>
            <span class="post-date" title="2022-06-21 19:06:51">2022/06/21</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/17/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%8B%B7%E8%B4%9D,%E7%AE%97%E6%95%B0,%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88,%E5%A0%86)/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库算法篇(拷贝,算数,排列组合,堆)">C++标准模板库算法篇(拷贝,算数,排列组合,堆)</span>
            <span class="post-date" title="2022-06-17 14:01:01">2022/06/17</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/13/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%9F%A5%E6%89%BE,%E6%8E%92%E5%BA%8F,%E9%9B%86%E5%90%88)/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库算法篇(查找,排序,集合)">C++标准模板库算法篇(查找,排序,集合)</span>
            <span class="post-date" title="2022-06-13 15:56:33">2022/06/13</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库之迭代器">C++标准模板库之迭代器</span>
            <span class="post-date" title="2022-06-09 16:47:20">2022/06/09</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/06/04/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Binitalizer_list%E4%B8%8Eset%E4%B8%8Emap/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库之initalizer_list与set与map">C++标准模板库之initalizer_list与set与map</span>
            <span class="post-date" title="2022-06-04 16:41:40">2022/06/04</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/30/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Blist%E4%B8%8Estack%E4%B8%8Equeue/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库之list与stack与queue">C++标准模板库之list与stack与queue</span>
            <span class="post-date" title="2022-05-30 12:35:09">2022/05/30</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/27/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Barray%E4%B8%8Evector/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++标准模板库之array与vector">C++标准模板库之array与vector</span>
            <span class="post-date" title="2022-05-27 14:16:07">2022/05/27</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/26/C++%E6%A8%A1%E6%9D%BF/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++模板">C++模板</span>
            <span class="post-date" title="2022-05-26 08:32:18">2022/05/26</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/25/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++异常处理">C++异常处理</span>
            <span class="post-date" title="2022-05-25 16:26:04">2022/05/25</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/24/C++IO%E6%B5%81/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++IO流">C++IO流</span>
            <span class="post-date" title="2022-05-24 16:11:36">2022/05/24</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/23/C++%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++虚函数与多态">C++虚函数与多态</span>
            <span class="post-date" title="2022-05-23 16:04:05">2022/05/23</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/22/C++%E7%BB%A7%E6%89%BF/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++继承">C++继承</span>
            <span class="post-date" title="2022-05-22 11:47:42">2022/05/22</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/21/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++运算符重载">C++运算符重载</span>
            <span class="post-date" title="2022-05-21 08:32:18">2022/05/21</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/20/C++%E5%8F%8B%E5%85%83/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++友元">C++友元</span>
            <span class="post-date" title="2022-05-20 18:37:54">2022/05/20</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/19/C++%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++特殊成员">C++特殊成员</span>
            <span class="post-date" title="2022-05-19 21:07:35">2022/05/19</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/18/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88%E6%A1%88%E4%BE%8B/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++类的组合案例">C++类的组合案例</span>
            <span class="post-date" title="2022-05-18 19:07:35">2022/05/18</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/17/C++%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++构造与析构">C++构造与析构</span>
            <span class="post-date" title="2022-05-17 13:17:08">2022/05/17</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/16/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++类和对象">C++类和对象</span>
            <span class="post-date" title="2022-05-16 11:58:16">2022/05/16</span>
        </a>
        
        
        <a  class="全部文章 后端 "
           href="/2022/05/15/C++%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag="C++"
           data-author="" >
            <span class="post-title" title="C++和C的区别">C++和C的区别</span>
            <span class="post-date" title="2022-05-15 15:24:31">2022/05/15</span>
        </a>
        
        
        <a  class="全部文章 计算机硬件 "
           href="/2022/05/10/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"
           data-tag="计算机硬件"
           data-author="" >
            <span class="post-title" title="计组-计算机硬件基础">计组-计算机硬件基础</span>
            <span class="post-date" title="2022-05-10 10:30:46">2022/05/10</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-QT(常用数据类型)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">QT(常用数据类型)</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Qt5开发">Qt5开发</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">QT</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-10-07 16:10:04'>2022-09-01 15:32</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11.3k</span>
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6"><span class="toc-text">项目文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main-cpp"><span class="toc-text">main.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#widget-cpp"><span class="toc-text">widget.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloQt-pro"><span class="toc-text">HelloQt.pro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8qmake%E5%8F%98%E9%87%8F"><span class="toc-text">常用qmake变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">常用快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">基础类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#log%E8%BE%93%E5%87%BA"><span class="toc-text">log输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QByteArray"><span class="toc-text">QByteArray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QString"><span class="toc-text">QString</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">数据操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-text">子字符串查找和判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-text">查看字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">字符串格式化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.2 不同字符串类型相互转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-QVariant"><span class="toc-text">4. QVariant</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.1 标准类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2 自定义类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8"><span class="toc-text">位置和尺寸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QPoint"><span class="toc-text">QPoint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QLine"><span class="toc-text">QLine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QSize"><span class="toc-text">QSize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QRect"><span class="toc-text">QRect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-text">日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QDate"><span class="toc-text">QDate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTime"><span class="toc-text">QTime</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E6%97%B6%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">经时计时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QDateTime"><span class="toc-text">QDateTime</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#container"><span class="toc-text">container</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8"><span class="toc-text">遍历容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QList"><span class="toc-text">QList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0"><span class="toc-text">公有函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QStringList"><span class="toc-text">QStringList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QLinkedList"><span class="toc-text">QLinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QVector"><span class="toc-text">QVector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QStack"><span class="toc-text">QStack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QQueue"><span class="toc-text">QQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QMap"><span class="toc-text">QMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E5%87%BD%E6%95%B0-1"><span class="toc-text">公有函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QMultiMap"><span class="toc-text">QMultiMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QHash"><span class="toc-text">QHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QMultiHash"><span class="toc-text">QMultiHash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QSet"><span class="toc-text">QSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QtGlobal"><span class="toc-text">QtGlobal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QtMath"><span class="toc-text">QtMath</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><blockquote>
<p>主函数所在的文件</p>
</blockquote>
<pre><code class="cpp">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;			//Qt标准窗口类头文件

class Widget : public QWidget	//自己的类继承自Qwidget类
&#123;
    Q_OBJECT					//使用信号与槽机制，必须包含该宏

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();
&#125;;
#endif // WIDGET_H
</code></pre>
<h3 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a>widget.cpp</h3><blockquote>
<p>窗口类源文件</p>
</blockquote>
<pre><code class="cpp">#include &quot;widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
&#125;

Widget::~Widget()
&#123;
&#125;
</code></pre>
<h3 id="HelloQt-pro"><a href="#HelloQt-pro" class="headerlink" title="HelloQt.pro"></a>HelloQt.pro</h3><blockquote>
<p>Qt项目文件，注释需要用#号</p>
</blockquote>
<pre><code class="cpp">#项目编译时需要加载哪些模块
QT       += core gui

# 如果当前Qt版本大于4, 要添加一个额外的模块: widgets
# Qt 5中对gui模块进行了拆分, 将 widgets 独立出来了
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

# 让Qt支持c++11标准
CONFIG += c++11

#如果您使用任何已标记为不推荐使用的Qt功能，则以下定义使您的编译器发出警告（确切的警告取决于您的编译器）。 
#请参考不推荐使用的API的文档，以了解如何将您的代码移植远离它。
DEFINES += QT_DEPRECATED_WARNINGS

#如果使用过时的API，您还可以使代码无法编译。
#为此，请取消注释以下行。
#您也可以选择仅在特定版本的Qt之前禁用已弃用的API。
#DEFINES + = QT_DISABLE_DEPRECATED_BEFORE = 0x060000    ＃禁用所有在Qt 6.0.0之前弃用的API

# 项目中的源文件	删除后，项目里不会显示所有的源文件
SOURCES += \
    main.cpp \
    widget.cpp

# 项目中的头文件
HEADERS += \
    widget.h

#部署的默认规则
qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin					#嵌入式
else: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin	#unix
!isEmpty(target.path): INSTALLS += target
</code></pre>
<p>pro是Qt的工程文件，这个文件是给qmake用来生成Makefile用的。</p>
<p>如果了解makefile的人应该知道，Makefile的三个关键点就是<code>目标</code>，<code>依赖</code>，<code>命令</code>。这里也很类似。pro文件中可以指明这个Qt项目的<code>头文件</code>，<code>源文件</code>，<code>链接的外部库</code>，<code>目标文件名</code>，<code>模板(生成什么样的Makefile)</code>，<code>版本配置(debug/release)</code>等。</p>
<h3 id="常用qmake变量"><a href="#常用qmake变量" class="headerlink" title="常用qmake变量"></a>常用qmake变量</h3><table>
<thead>
<tr>
<th align="left">.pro中变量</th>
<th align="left">含义</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TEMPLATE</td>
<td align="left">模板变量指定生成makefile(app:应用程序&#x2F;lib:库)</td>
<td align="left">TEMPLATE &#x3D; app</td>
</tr>
<tr>
<td align="left">QT</td>
<td align="left">指定加载的Qt模块(core&#x2F;gui&#x2F;widgets…)</td>
<td align="left">QT +&#x3D; widgtes</td>
</tr>
<tr>
<td align="left">DESTDIR</td>
<td align="left">指定生成的应用程序放置的目录</td>
<td align="left">DESTDIR +&#x3D; ..&#x2F;bin</td>
</tr>
<tr>
<td align="left">TARGET</td>
<td align="left">指定生成的应用程序名</td>
<td align="left">TARGET &#x3D; hello</td>
</tr>
<tr>
<td align="left">HEADERS</td>
<td align="left">工程中包含的头文件</td>
<td align="left">HEADERS +&#x3D; hello.h</td>
</tr>
<tr>
<td align="left">FORMS</td>
<td align="left">工程中包含的.ui设计文件</td>
<td align="left">FORMS +&#x3D; hello.ui</td>
</tr>
<tr>
<td align="left">SOURCES</td>
<td align="left">工程中包含的源文件</td>
<td align="left">SOURCES +&#x3D; main.cpp hello.cpp</td>
</tr>
<tr>
<td align="left">RESOURCES</td>
<td align="left">工程中包含的资源文件</td>
<td align="left">RESOURCES +&#x3D; qrc&#x2F;hello.qrc</td>
</tr>
<tr>
<td align="left">LIBS</td>
<td align="left">引入的lib文件的路径 -L：引入路径</td>
<td align="left">LIBS +&#x3D; -L.</td>
</tr>
<tr>
<td align="left">CONFIG</td>
<td align="left">用来告诉qmake关于应用程序的配置信息</td>
<td align="left">CONFIG+&#x3D; qt warn_on release</td>
</tr>
<tr>
<td align="left">UI_DIR</td>
<td align="left">指定.ui文件转化成<code>ui_*.h</code>文件的存放目录</td>
<td align="left">UI_DIR +&#x3D; forms</td>
</tr>
<tr>
<td align="left">RCC_DIR</td>
<td align="left">指定将.qrc文件转换成<code>qrc_*.h</code>文件的存放目录</td>
<td align="left">RCC_DIR +&#x3D; ..&#x2F;tmp</td>
</tr>
<tr>
<td align="left">MOC_DIR</td>
<td align="left">指定将含Q_OBJECT的头文件转换成标准.h文件的存放目录</td>
<td align="left">MOC_DIR +&#x3D; ..&#x2F;tmp</td>
</tr>
<tr>
<td align="left">OBJECTS_DIR</td>
<td align="left">指定目标文件(obj)的存放目录</td>
<td align="left">OBJECTS_DIR +&#x3D; ..&#x2F;tmp</td>
</tr>
<tr>
<td align="left">DEPENDPATH</td>
<td align="left">程序编译时依赖的相关路径</td>
<td align="left">DEPENDPATH +&#x3D; . forms include qrc sources</td>
</tr>
<tr>
<td align="left">INCLUDEPATH</td>
<td align="left">头文件包含路径</td>
<td align="left">INCLUDEPATH +&#x3D; .</td>
</tr>
<tr>
<td align="left">DEFINES</td>
<td align="left">增加预处理器宏（gcc的-D选项）。</td>
<td align="left">DEFINES +&#x3D; USE_MY_STUFF</td>
</tr>
<tr>
<td align="left">QMAKE_CFLAGS</td>
<td align="left">设置c编译器flag参数</td>
<td align="left">QMAKE_CFLAGS +&#x3D; -g</td>
</tr>
<tr>
<td align="left">QMAKE_CXXFLAGS</td>
<td align="left">设置c++编译器flag参数</td>
<td align="left">QMAKE_CXXFLAGS +&#x3D; -g</td>
</tr>
<tr>
<td align="left">QMAKE_LFLAGS</td>
<td align="left">设置链接器flag参数</td>
<td align="left">QMAKE_LFLAGS +&#x3D; -rdynamic</td>
</tr>
</tbody></table>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li><p>运行     Ctrl + r</p>
</li>
<li><p>编译     Ctrl + b</p>
</li>
<li><p>注释     Ctrl + &#x2F;</p>
</li>
<li><p>字体缩放 Ctrl + 鼠标滚轮</p>
</li>
<li><p>查找&#x2F;替换 Ctrl + f</p>
</li>
<li><p>整行移动   Ctrl + Shift + ↑ 或 ↓</p>
</li>
<li><p>自动对齐   Ctrl + i</p>
</li>
<li><p>帮助文档</p>
<ul>
<li>第一种：Qt Creator 直接查看   F1</li>
<li>第二种：打开独立的帮助文档程序  assistant</li>
</ul>
</li>
<li><p>同名.h 和 .cpp 之间的切换  F4</p>
</li>
<li><p>快速添加函数的定义  Alt + Enter      <span style="font-size:15px"><code>鼠标移动到函数申明上</code></span></p>
</li>
<li><p>修改变量名，并应用到所有用到该变量的地方  Ctrl + Shift +r</p>
</li>
<li><p>快速打开输出窗口 Alt + 数字键(1-8)</p>
</li>
<li><p>书签功能,即在某行代码处进行标记,方便以后找到。书签也可以添加文字标注。</p>
<ul>
<li><p>按Ctrl + M   添加&#x2F;删除书签</p>
</li>
<li><p>按Ctrl + .     查找并移动到下一个标签</p>
</li>
</ul>
</li>
</ul>
<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>因为Qt是一个C++框架, 因此C++中所有的语法和数据类型在Qt中都是被支持的, 但是Qt中也定义了一些属于自己的数据类型</p>
<p>QT基本数据类型定义在<code>#include &lt;QtGlobal&gt;</code> 中，QT基本数据类型有：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>注释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>qint8</td>
<td>signed char</td>
<td>有符号8位数据</td>
</tr>
<tr>
<td>qint16</td>
<td>signed short</td>
<td>16位数据类型</td>
</tr>
<tr>
<td>qint32</td>
<td>signed short</td>
<td>32位有符号数据类型</td>
</tr>
<tr>
<td>qint64</td>
<td>long long int 或(__int64)</td>
<td>64位有符号数据类型，Windows中定义为__int64</td>
</tr>
<tr>
<td>qintptr</td>
<td>qint32 或 qint64</td>
<td>指针类型 根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td>
</tr>
<tr>
<td>qlonglong</td>
<td>long long int 或(__int64)</td>
<td>Windows中定义为__int64</td>
</tr>
<tr>
<td>qptrdiff</td>
<td>qint32 或 qint64</td>
<td>根据系统类型不同而不同，32位系统为qint32、64位系统为qint64</td>
</tr>
<tr>
<td>qreal</td>
<td>double 或 float</td>
<td>除非配置了-qreal float选项，否则默认为double</td>
</tr>
<tr>
<td>quint8</td>
<td>unsigned char</td>
<td>无符号8位数据类型</td>
</tr>
<tr>
<td>quint16</td>
<td>unsigned short</td>
<td>无符号16位数据类型</td>
</tr>
<tr>
<td>quint32</td>
<td>unsigned int</td>
<td>无符号32位数据类型</td>
</tr>
<tr>
<td>quint64</td>
<td>unsigned long long int 或 (unsigned __int64)</td>
<td>无符号64比特数据类型，Windows中定义为unsigned __int64</td>
</tr>
<tr>
<td>quintptr</td>
<td>quint32 或 quint64</td>
<td>根据系统类型不同而不同，32位系统为quint32、64位系统为quint64</td>
</tr>
<tr>
<td>qulonglong</td>
<td>unsigned long long int 或 (unsigned __int64)</td>
<td>Windows中定义为__int64</td>
</tr>
<tr>
<td>uchar</td>
<td>unsigned char</td>
<td>无符号字符类型</td>
</tr>
<tr>
<td>uint</td>
<td>unsigned int</td>
<td>无符号整型</td>
</tr>
<tr>
<td>ulong</td>
<td>unsigned long</td>
<td>无符号长整型</td>
</tr>
<tr>
<td>ushort</td>
<td>unsigned short</td>
<td>无符号短整型</td>
</tr>
<tr>
<td>qsizetype</td>
<td>size_t</td>
<td></td>
</tr>
</tbody></table>
<h1 id="log输出"><a href="#log输出" class="headerlink" title="log输出"></a>log输出</h1><blockquote>
<p>在Qt中进行log输出, 一般不使用c中的<code>printf</code>, 也不是使用C++中的<code>cout</code>, Qt框架提供了专门用于日志输出的类, 头文件名为 <code>QDebug</code>。</p>
</blockquote>
<p><strong>基本分类</strong></p>
<ul>
<li>qDebug：调试信息提示</li>
<li>qInfo     ：输出信息</li>
<li>qWarning ：一般的警告提示</li>
<li>qCritical ：严重的错误提示</li>
<li>qFatal ：致命错误提示，会直接中断程序</li>
</ul>
<p><strong>C风格输出</strong></p>
<pre><code class="cpp">qDebug(&quot;我是%s，今年%d岁了~&quot;,&quot;kpsun&quot;,17);
qInfo(&quot;kpsun%d&quot;,666);
qWarning(&quot;hello %s&quot;,&quot;warning&quot;);
qCritical(&quot;helo %s&quot;,&quot;critical&quot;);
qFatal(&quot;hello %s&quot;,&quot;qFatal&quot;);		//致命错误会直接中断程序
</code></pre>
<p><strong>C++风格</strong></p>
<pre><code class="cpp">qDebug()&lt;&lt;&quot;好帅&quot;&lt;&lt;endl;
qInfo()&lt;&lt;&quot;qInfo&quot;&lt;&lt;endl;
qWarning()&lt;&lt;&quot;qWarnning&quot;&lt;&lt;endl;
qCritical()&lt;&lt;&quot;qCritical&quot;&lt;&lt;endl;
#qFatal()&lt;&lt;&quot;qFatal&quot;&lt;&lt;endl;			//致命错误不能用&lt;&lt;输出
</code></pre>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><blockquote>
<p>C     &#x3D;&gt; <code>char*</code></p>
<p>C++ &#x3D;&gt; <code>std::string</code></p>
<p>Qt	&#x3D;&gt; <code>QByteArray</code>, <code>QString</code></p>
</blockquote>
<h2 id="QByteArray"><a href="#QByteArray" class="headerlink" title="QByteArray"></a>QByteArray</h2><blockquote>
<p>在Qt中<code>QByteArray</code>可以看做是C语言中 <code>char*</code>的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。</p>
</blockquote>
<ul>
<li><p>构造函数</p>
<pre><code class="cpp">// 构造空对象, 里边没有数据
QByteArray::QByteArray();
// 将data中的size个字符进行构造, 得到一个字节数组对象
// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)
QByteArray::QByteArray(const char *data, int size = -1);
// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组
QByteArray::QByteArray(int size, char ch);
</code></pre>
</li>
<li><p>数据操作</p>
<pre><code class="c++">// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &amp;QByteArray::append(const QByteArray &amp;ba);
void QByteArray::push_back(const QByteArray &amp;other);

// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &amp;QByteArray::prepend(const QByteArray &amp;ba);
void QByteArray::push_front(const QByteArray &amp;other);

// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &amp;QByteArray::insert(int i, const QByteArray &amp;ba);

// 删除数据
// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除
QByteArray &amp;QByteArray::remove(int pos, int len);
// 从字符数组的尾部删除 n 个字节
void QByteArray::chop(int n);
// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)
void QByteArray::truncate(int pos);
// 将对象中的数据清空, 使其为null
void QByteArray::clear();

// 字符串替换
// 将字节数组中的 子字符串 before 替换为 after
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &amp;QByteArray::replace(const QByteArray &amp;before, const QByteArray &amp;after);
</code></pre>
</li>
<li><p>子字符串查找和判断</p>
<pre><code class="c++">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false
bool QByteArray::contains(const QByteArray &amp;ba) const;
bool QByteArray::contains(const char *ba) const;
// 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false
bool QByteArray::contains(char ch) const;

// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false
bool QByteArray::startsWith(const QByteArray &amp;ba) const;
bool QByteArray::startsWith(const char *ba) const;
// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false
bool QByteArray::startsWith(char ch) const;

// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false
bool QByteArray::endsWith(const QByteArray &amp;ba) const;
bool QByteArray::endsWith(const char *ba) const;
// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false
bool QByteArray::endsWith(char ch) const;
</code></pre>
</li>
<li><p>遍历</p>
<pre><code class="c++">// 使用迭代器
iterator QByteArray::begin();
iterator QByteArray::end();

// 使用数组的方式进行遍历
// i的取值范围 0 &lt;= i &lt; size()
char QByteArray::at(int i) const;
char QByteArray::operator[](int i) const;
</code></pre>
</li>
<li><p>查看字节数</p>
<pre><code class="c++">// 返回字节数组对象中字符的个数
int QByteArray::length() const;
int QByteArray::size() const;
int QByteArray::count() const;

// 返回字节数组对象中 子字符串ba 出现的次数
int QByteArray::count(const QByteArray &amp;ba) const;
int QByteArray::count(const char *ba) const;
// 返回字节数组对象中 字符串ch 出现的次数
int QByteArray::count(char ch) const;
</code></pre>
</li>
<li><p>类型转换</p>
<pre><code class="c++">// 将QByteArray类型的字符串 转换为 char* 类型
char *QByteArray::data();
const char *QByteArray::data() const;

// int, short, long, float, double -&gt; QByteArray
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &amp;QByteArray::setNum(int n, int base = 10);
QByteArray &amp;QByteArray::setNum(short n, int base = 10);
QByteArray &amp;QByteArray::setNum(qlonglong n, int base = 10);
QByteArray &amp;QByteArray::setNum(float n, char f = &#39;g&#39;, int prec = 6);
QByteArray &amp;QByteArray::setNum(double n, char f = &#39;g&#39;, int prec = 6);
[static] QByteArray QByteArray::number(int n, int base = 10);
[static] QByteArray QByteArray::number(qlonglong n, int base = 10);
[static] QByteArray QByteArray::number(double n, char f = &#39;g&#39;, int prec = 6);

// QByteArray -&gt; int, short, long, float, double
int QByteArray::toInt(bool *ok = Q_NULLPTR, int base = 10) const;
short QByteArray::toShort(bool *ok = Q_NULLPTR, int base = 10) const;
long QByteArray::toLong(bool *ok = Q_NULLPTR, int base = 10) const;
float QByteArray::toFloat(bool *ok = Q_NULLPTR) const;
double QByteArray::toDouble(bool *ok = Q_NULLPTR) const;

// std::string -&gt; QByteArray
[static] QByteArray QByteArray::fromStdString(const std::string &amp;str);
// QByteArray -&gt; std::string
std::string QByteArray::toStdString() const;

// 所有字符转换为大写
QByteArray QByteArray::toUpper() const;
// 所有字符转换为小写
QByteArray QByteArray::toLower() const;
</code></pre>
</li>
</ul>
<h2 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h2><blockquote>
<p>QString也是封装了字符串, 但是内部的编码为<code>utf8</code>, UTF-8属于Unicode字符集, 它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符，这样可以将世界上几乎所有语言的常用字符收录其中。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="c++">// 构造一个空字符串对象
QString();
// 将 char* 字符串 转换为 QString 类型
QString(const char *str);
// 将 QByteArray 转换为 QString 类型
QString(const QByteArray &amp;ba);
// 其他重载的同名构造函数可参考Qt帮助文档, 此处略
</code></pre>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><pre><code class="c++">// 尾部追加数据
QString&amp; append(const QString &amp;str);
QString&amp; append(const char *str);
QString&amp; append(const QByteArray &amp;ba);
void push_back(const QString &amp;other);

// 头部添加数据
QString&amp; prepend(const QString &amp;str);
QString&amp; prepend(const char *str);
QString&amp; prepend(const QByteArray &amp;ba);
void QString::push_front(const QString &amp;other);

// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)
QString&amp; insert(int position, const QString &amp;str);
QString&amp; insert(int position, const char *str);
QString&amp; insert(int position, const QByteArray &amp;str);

// 删除数据
// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除
QString&amp; remove(int position, int n);

// 从字符串的尾部删除 n 个字符
void  chop(int n);
// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)
void  truncate(int position);
// 将对象中的数据清空, 使其为null
void  clear();

// 字符串替换
// 将字节数组中的 子字符串 before 替换为 after
// 参数 cs 为是否区分大小写, 默认区分大小写
QString&amp; replace(const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
</code></pre>
<h3 id="子字符串查找和判断"><a href="#子字符串查找和判断" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3><pre><code class="c++">// 参数 cs 为是否区分大小写, 默认区分大小写
// 其他重载的同名函数可参考Qt帮助文档, 此处略

// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false
bool  contains(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false
bool startsWith(const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false
bool endsWith(const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
</code></pre>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><pre><code class="c++">// 使用迭代器
iterator  begin();
iterator  end();

// 使用数组的方式进行遍历
const QChar  at(int position) const
const QChar  operator[](int position) const;
</code></pre>
<h3 id="查看字节数"><a href="#查看字节数" class="headerlink" title="查看字节数"></a>查看字节数</h3><pre><code class="c++">// 返回字节数组对象中字符的个数
int  length() const;
int  size() const;
int  count() const;

// 返回字节串对象中 子字符串 str 出现的次数
// 参数 cs 为是否区分大小写, 默认区分大小写
int  count(const QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
</code></pre>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><pre><code class="c++">// int, short, long, float, double -&gt; QString
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString&amp; setNum(int n, int base = 10);
QString&amp; setNum(short n, int base = 10);
QString&amp; setNum(long n, int base = 10);
QString&amp; setNum(float n, char format = &#39;g&#39;, int precision = 6);
QString&amp;QString::setNum(double n, char format = &#39;g&#39;, int precision = 6);
[static] QString QString::number(long n, int base = 10);
[static] QString QString::number(int n, int base = 10);
[static] QString QString::number(double n, char format = &#39;g&#39;, int precision = 6);

// QString -&gt; int, short, long, float, double
int QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const;
short QString::toShort(bool *ok = Q_NULLPTR, int base = 10) const;
long QString::toLong(bool *ok = Q_NULLPTR, int base = 10) const
float QString::toFloat(bool *ok = Q_NULLPTR) const;
double QString::toDouble(bool *ok = Q_NULLPTR) const;


// 所有字符转换为大写
QString QString::toUpper() const;
// 所有字符转换为小写
QString QString::toLower() const;
</code></pre>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>C语言中有sprintf()函数，QString也提供了一个asprintf()函数。</p>
<pre><code class="cpp"> QString res =  QString::asprintf(&quot;fileName:%s size:%d&quot;,&quot;./av.jpg&quot;,20);
 qDebug()&lt;&lt;res&lt;&lt;endl;
</code></pre>
<p>不过QString还提供的另一种格式化字符串输出的函数arg()，更为方便。</p>
<pre><code class="c++">QString arg(const QString &amp;a, int fieldWidth = 0, QChar fillChar = QLatin1Char( &#39; &#39; )) const;
QString arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( &#39; &#39; )) const;
//用于填充字符串中的%1,%2…为给定格式的整形数字，其中第一个参数是要填充的数字，第二个参数为最小宽度，第三个参数为进制，第四个参数为当原始数字长度不足最小宽度时用于填充的字符

// 示例程序
QString str =  QString(&quot;%1 %2 %3&quot;).arg(1).arg(2);
str = str.arg(&quot;hello&quot;);
qDebug()&lt;&lt;str&lt;&lt;endl;     //&quot;hello 2 1&quot;

QString text = QString(&quot;%1:%2:%3&quot;).arg(1,2,10,QChar(&#39;0&#39;)).arg(35).arg(59);
qDebug()&lt;&lt;text&lt;&lt;endl;    //&quot;01:35:59&quot;
</code></pre>
<h2 id="3-2-不同字符串类型相互转换"><a href="#3-2-不同字符串类型相互转换" class="headerlink" title="3.2 不同字符串类型相互转换"></a>3.2 不同字符串类型相互转换</h2><pre><code class="cpp">// std::string -&gt; QString
[static] QString QString::fromStdString(const std::string &amp;str);
// QString -&gt; std::string
std::string QString::toStdString() const;

#QString -&gt; QByteArray
// 转换为本地编码, 跟随操作系统
QByteArray QString::toLocal8Bit() const;
// 转换为 Latin-1 编码的字符串 不支持中文
QByteArray QString::toLatin1() const;
// 转换为 utf8 编码格式的字符串 (常用)
QByteArray QString::toUtf8() const;

#QByteArray -&gt; QString
//使用QString的构造函数即可
</code></pre>
<h1 id="4-QVariant"><a href="#4-QVariant" class="headerlink" title="4. QVariant"></a>4. QVariant</h1><blockquote>
<p>QVariant(变体数据类型)这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。</p>
<p>QVariant 这个类型充当着最常见的数据类型的联合。QVariant 可以保存很多Qt的数据类型，包括<code>QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、 QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString</code>，并且还有C++基本类型，如<code> int、float</code>等。</p>
</blockquote>
<h2 id="4-1-标准类型"><a href="#4-1-标准类型" class="headerlink" title="4.1 标准类型"></a>4.1 标准类型</h2><ul>
<li>将标准类型转换为QVariant类型</li>
</ul>
<pre><code class="c++">// 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个
QVariant(int val);
QVariant(bool val);
QVariant(double val);
QVariant(const char *val);
QVariant(const QByteArray &amp;val);
QVariant(const QString &amp;val);
......
    
// 使用设置函数也可以将支持的类型的数据设置到QVariant对象中
// 这里的 T 类型, 就是QVariant支持的类型
void setValue(const T &amp;value);
// 该函数行为和 setValue() 函数完全相同
[static] QVariant fromValue(const T &amp;value);
</code></pre>
<p><strong>Exmple</strong></p>
<pre><code class="cpp">QVariant v(5);

QVariant v;
v.setValue(5);

QVariant v = QVariant::fromValue(5);

int i = v.toInt();          // i is now 5
QString s = v.toString();   // s is now &quot;5&quot;
</code></pre>
<ul>
<li>判断 QVariant中封装的实际数据类型</li>
</ul>
<blockquote>
<p>Type 是枚举类型</p>
</blockquote>
<pre><code class="c++">//获取类型，返回的是一个枚举类型;如QVariant::Int ...
Type type() const;
//获取类型名
const char *typeName() const;
//根据类型id(枚举)获取类型名(字符串)
[static] const char *typeToName(int typeId);
//根据类型名(字符串)获取类型id(枚举)
[static] Type nameToType(const char *name);
</code></pre>
<ul>
<li>将QVariant对象转换为实际的数据类型</li>
</ul>
<pre><code class="c++">//在转换之前可以先判断能够转换成对应的类型
bool canConvert(int targetTypeId) const
bool canConvert() const

bool 		toBool() const;
QByteArray 	toByteArray() const;
double 		toDouble(bool *ok = Q_NULLPTR) const;
float 		toFloat(bool *ok = Q_NULLPTR) const;
int 		toInt(bool *ok = Q_NULLPTR) const;
QString 	toString() const;
......

T value() const
//v.value&lt;int&gt;();       
</code></pre>
<h2 id="4-2-自定义类型"><a href="#4-2-自定义类型" class="headerlink" title="4.2 自定义类型"></a>4.2 自定义类型</h2><blockquote>
<p>除了标准类型, 我们自定义的类型也可以使用<code>QVariant</code>类进行封装, <code>被QVariant存储的数据类型需要有一个默认的构造函数和一个拷贝构造函数</code>。为了实现这个功能，首先必须使用<code>Q_DECLARE_METATYPE()</code>宏。通常会将这个宏放在类的声明所在头文件的下面， 原型为： </p>
<p><code>Q_DECLARE_METATYPE(Type)</code></p>
<p>使用的具体步骤如下: </p>
</blockquote>
<ul>
<li><p>第一步: 定义类型，并注册</p>
<pre><code class="c++">//自定义类型
class Animal
&#123;
public:
    Animal()&#123;&#125;  //必须要有默认构造函数
                //拷贝构造函数也必须有，不过没有深、浅拷贝时，用默认的即可
    Animal(QString name):_name(name)&#123;&#125;
    void show()
    &#123;
        qDebug()&lt;&lt;&quot;Animal show name is :&quot;&lt;&lt; _name &lt;&lt;endl;
    &#125;
private:
    QString _name;
&#125;;
//自定义类型注册
Q_DECLARE_METATYPE(Animal);
</code></pre>
</li>
<li><p>第二步: 使用forvalue()存储对象</p>
<pre><code class="c++">int main()
&#123;
    //QVariant vt(Animal(&quot;snake&quot;));	//不可以通过构造函数存自定义类型
    QVariant vt;
    //有以下两种方法可以，存自定义类型
    vt = QVariant::fromValue(Animal(&quot;dog&quot;));	//①
    vt.setValue(Animal(&quot;cat&quot;));					//②
    //如果能转换到Animal类型，就转换
    if(vt.canConvert&lt;Animal&gt;())
    &#123;
        Animal animal = vt.value&lt;Animal&gt;();
        animal.show();
    &#125;
    return 0;
&#125;
</code></pre>
</li>
</ul>
<p>操作涉及的API如下:</p>
<pre><code class="c++">// 如果当前QVariant对象可用转换为对应的模板类型 T, 返回true, 否则返回false
bool canConvert() const;
// 将当前QVariant对象转换为实际的 T 类型
T value() const;
</code></pre>
<h1 id="位置和尺寸"><a href="#位置和尺寸" class="headerlink" title="位置和尺寸"></a>位置和尺寸</h1><blockquote>
<p>在QT中我们常见的 点, 线, 尺寸, 矩形 都被进行了封装。</p>
</blockquote>
<h2 id="QPoint"><a href="#QPoint" class="headerlink" title="QPoint"></a>QPoint</h2><blockquote>
<p><code>QPoint</code>类封装了我们常用用到的坐标点 (x, y), 常用的 API如下:</p>
</blockquote>
<pre><code class="c++">void QPoint::setX(int x);
void QPoint::setY(int y);

int QPoint::x() const;
int &amp;QPoint::rx();

int QPoint::y() const;
int &amp;QPoint::ry();

//如果x和y坐标都为0则返回true，否则返回false
bool isNull() const

//返回x()和y()的绝对值之和，传统上称为从原点到该点的向量的“曼哈顿长度”。
//(p1-p2).manhattanLength();   
int manhattanLength() const    

//返回一个交换了x和y坐标的点:   QPoint&#123;1, 2&#125;.transposed() // &#123;2, 1&#125;  
QPoint transposed() const    
    
// 直接通过坐标对象进行算术运算: 加减乘除
QPoint &amp;QPoint::operator*=(float factor);
QPoint &amp;QPoint::operator*=(double factor);
QPoint &amp;QPoint::operator*=(int factor);
QPoint &amp;QPoint::operator+=(const QPoint &amp;point);
QPoint &amp;QPoint::operator-=(const QPoint &amp;point);
QPoint &amp;QPoint::operator/=(qreal divisor);
...
</code></pre>
<h2 id="QLine"><a href="#QLine" class="headerlink" title="QLine"></a>QLine</h2><blockquote>
<p><code>QLine</code>是一个直线类, 封装了两个坐标点 (<code>两点确定一条直线</code>)</p>
<p>常用API如下:</p>
</blockquote>
<pre><code class="c++">// 设置直线的起点坐标
void setP1(const QPoint &amp;p1);
// 设置直线的终点坐标
void setP2(const QPoint &amp;p2);

void setPoints(const QPoint &amp;p1, const QPoint &amp;p2);
void setLine(int x1, int y1, int x2, int y2);


QPoint p1() const;		// 返回直线的起始点坐标
QPoint p2() const;		// 返回直线的终点坐标
QPoint center() const;	// 返回值直线的中心点坐标, (p1() + p2()) / 2	


int x1() const;		// 返回值直线起点的 x 坐标
int y1() const;		// 返回值直线起点的 y 坐标
int x2() const;		// 返回值直线终点的 x 坐标
int y2() const;		// 返回值直线终点的 y 坐标

int dx() const			//返回直线向量的水平分量  
int dy() const			//返回直线向量的垂直分量  

// 用给定的坐标点平移这条直线
void translate(const QPoint &amp;offset);
void translate(int dx, int dy);
// 用给定的坐标点平移这条直线, 返回平移之后的坐标点(不会改变这条线的坐标)
QLine translated(const QPoint &amp;offset) const;
QLine translated(int dx, int dy) const;

// 直线对象进行比较
bool operator!=(const QLine &amp;line) const;
bool operator==(const QLine &amp;line) const;
</code></pre>
<h2 id="QSize"><a href="#QSize" class="headerlink" title="QSize"></a>QSize</h2><blockquote>
<p>在QT中<code>QSize</code>类用来形容长度和宽度, 常用的API如下:</p>
</blockquote>
<pre><code class="c++">void setWidth(int width)
void setHeight(int height);

int width() const;		// 得到宽度
int &amp;rwidth();			// 得到宽度的引用
int height() const;		// 得到高度
int &amp;rheight();			// 得到高度的引用

void transpose();			// 交换高度和宽度的值
QSize transposed() const;	// 交换高度和宽度的值, 返回交换之后的尺寸信息

//返回一个大小，宽为当前大小与other的最小值，高为当前大小与other的最小值
QSize boundedTo(const QSize&amp; oterSize)
//返回一个大小，宽为当前大小与other的最大值，高为当前大小与other的最大值    
QSize expandedTo(const QSize &amp;otherSize) const    
    
/*
根据指定的模式，按给定的宽度和高度缩放矩形:  
    如果mode为Qt::IgnoreAspectRatio，则大小设置为(width, height)。  
    如果mode为Qt::KeepAspectRatio，当前大小将在内部缩放到一个尽可能大的矩形(宽度，高度)，保持高宽比。  
    如果mode是Qt::KeepAspectRatioByExpanding，当前大小被缩放到一个矩形，尽可能小的外部(宽度，高度)，保持长宽比。  
*/
void scale(int width, int height, Qt::AspectRatioMode mode)
void scale(const QSize &amp;size, Qt::AspectRatioMode mode)
QSize scaled(int width, int height, Qt::AspectRatioMode mode) const
QSize scaled(const QSize &amp;s, Qt::AspectRatioMode mode) const
    

// 进行算法运算: 加减乘除
QSize &amp;operator*=(qreal factor);
QSize &amp;operator+=(const QSize &amp;size);
QSize &amp;operator-=(const QSize &amp;size);
QSize &amp;operator/=(qreal divisor);
</code></pre>
<h2 id="QRect"><a href="#QRect" class="headerlink" title="QRect"></a>QRect</h2><blockquote>
<p>在Qt中使用 <code>QRect</code>类来描述一个矩形, 常用的API如下:</p>
</blockquote>
<pre><code class="c++">// 构造一个空对象
QRect::QRect();
// 基于左上角坐标, 和右下角坐标构造一个矩形对象
QRect::QRect(const QPoint &amp;topLeft, const QPoint &amp;bottomRight);
// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象
QRect::QRect(const QPoint &amp;topLeft, const QSize &amp;size);
// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象
QRect::QRect(int x, int y, int width, int height);

// 设置矩形的尺寸信息, 左上角坐标不变
void QRect::setSize(const QSize &amp;size);
// 设置矩形左上角坐标为(x,y), 大小为(width, height)
void QRect::setRect(int x, int y, int width, int height);
// 设置矩形宽度
void QRect::setWidth(int width);
// 设置矩形高度
void QRect::setHeight(int height);

// 返回值矩形左上角坐标
QPoint QRect::topLeft() const;
// 返回矩形右上角坐标
// 该坐标点值为: QPoint(left() + width() -1, top())
QPoint QRect::topRight() const;
// 返回矩形左下角坐标
// 该坐标点值为: QPoint(left(), top() + height() - 1)
QPoint QRect::bottomLeft() const;
// 返回矩形右下角坐标
// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)
QPoint QRect::bottomRight() const;
// 返回矩形中心点坐标
QPoint QRect::center() const;

// 返回矩形上边缘y轴坐标
int QRect::top() const;
int QRect::y() const;
// 返回值矩形下边缘y轴坐标
int QRect::bottom() const;
// 返回矩形左边缘 x轴坐标
int QRect::x() const;
int QRect::left() const;
// 返回矩形右边缘x轴坐标
int QRect::right() const;

// 返回矩形的高度
int QRect::width() const;
// 返回矩形的宽度
int QRect::height() const;
// 返回矩形的尺寸信息
QSize QRect::size() const;

//调整矩形的尺寸 （左上角和右下角坐标偏移量）
void QRect::adjust(int dx1, int dy1, int dx2, int dy2)
QRect QRect::adjusted(int dx1, int dy1, int dx2, int dy2) const    
</code></pre>
<p>QPoint，QLine，QSize，QRect各自都还有浮点型版本的，分别是QPointF，QLineF，QSizeF，QRectF，函数基本一样</p>
<h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><h2 id="QDate"><a href="#QDate" class="headerlink" title="QDate"></a>QDate</h2><pre><code class="c++">// 构造函数
QDate::QDate();
QDate::QDate(int y, int m, int d);

// 公共成员函数
// 重新设置日期对象中的日期
bool QDate::setDate(int year, int month, int day);
// 给日期对象添加 ndays 天
QDate QDate::addDays(qint64 ndays) const;
// 给日期对象添加 nmonths 月
QDate QDate::addMonths(int nmonths) const;
// 给日期对象添加 nyears 月
QDate QDate::addYears(int nyears) const;

// 得到日期对象中的年/月/日
int QDate::year() const;
int QDate::month() const;
int QDate::day() const;
void QDate::getDate(int *year, int *month, int *day) const;
 
/*日期对象格式化
    d 		- 	没有前导零的日子 (1 to 31)  
    dd		-	前导为0的日子   (01 to 31)  
    ddd		-	显示(缩写) 周一、周二、周三、周四、周五、周六、周日		
    dddd	- 	显示(完整) 星期一、星期二、星期三、星期四、星期五、星期六、星期日
    
    M		-	没有前导零的月份(1到12)  
    MM		-	前导零的月份(01到12)  
    MMM		-	缩写 1月、2月、3月...         
    MMMM	-	完整 一月、二月、三月...
    
    yy		-	两个数字的年 (00 to 99)
    yyyy	-	以四位数表示的年份
*/
QString QDate::toString(const QString &amp;format) const;

// 操作符重载 ==&gt; 日期比较
bool QDate::operator!=(const QDate &amp;d) const;
bool QDate::operator&lt;(const QDate &amp;d) const;
bool QDate::operator&lt;=(const QDate &amp;d) const;
bool QDate::operator==(const QDate &amp;d) const;
bool QDate::operator&gt;(const QDate &amp;d) const;
bool QDate::operator&gt;=(const QDate &amp;d) const;

// 静态函数 -&gt; 得到本地的当前日期
[static] QDate QDate::currentDate();
</code></pre>
<h2 id="QTime"><a href="#QTime" class="headerlink" title="QTime"></a>QTime</h2><pre><code class="c++">// 构造函数
QTime::QTime();
/*
    h 			==&gt; must be in the range 0 to 23
    m and s 	==&gt; must be in the range 0 to 59
    ms 			==&gt; must be in the range 0 to 999
*/ 
QTime::QTime(int h, int m, int s = 0, int ms = 0);

// 公共成员函数
// Returns true if the set time is valid; otherwise returns false.
bool QTime::setHMS(int h, int m, int s, int ms = 0);
QTime QTime::addSecs(int s) const;
QTime QTime::addMSecs(int ms) const;

// 示例代码
  QTime n(14, 0, 0);                // n == 14:00:00
  QTime t;
  t = n.addSecs(70);                // t == 14:01:10
  t = n.addSecs(-70);               // t == 13:58:50
  t = n.addSecs(10 * 60 * 60 + 5);  // t == 00:00:05
  t = n.addSecs(-15 * 60 * 60);     // t == 23:00:00

// 从时间对象中取出 时/分/秒/毫秒
// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.
int QTime::hour() const;
// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.
int QTime::minute() const;
// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.
int QTime::second() const;
// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.
int QTime::msec() const;


// 时间格式化
/*
    -- 时
    h	==&gt;	The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
    hh	==&gt;	The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
    H	==&gt;	The hour without a leading zero (0 to 23, even with AM/PM display)
    HH	==&gt;	The hour with a leading zero (00 to 23, even with AM/PM display)
    -- 分
    m	==&gt;	The minute without a leading zero (0 to 59)
    mm	==&gt;	The minute with a leading zero (00 to 59)
    -- 秒
    s	==&gt;	The whole second, without any leading zero (0 to 59)
    ss	==&gt;	The whole second, with a leading zero where applicable (00 to 59)
    -- 毫秒
    zzz	==&gt;	The fractional part of the second, to millisecond precision, 
            including trailing zeroes where applicable (000 to 999).
    -- 上午或者下午
    AP or A		==&gt;		使用AM/PM(大写) 描述上下午, 中文系统显示汉字
    ap or a		==&gt;		使用am/pm(小写) 描述上下午, 中文系统显示汉字
*/
QString QTime::toString(const QString &amp;format) const;


// 操作符重载 ==&gt; 时间比较
bool QTime::operator!=(const QTime &amp;t) const;
bool QTime::operator&lt;(const QTime &amp;t) const;
bool QTime::operator&lt;=(const QTime &amp;t) const;
bool QTime::operator==(const QTime &amp;t) const;
bool QTime::operator&gt;(const QTime &amp;t) const;
bool QTime::operator&gt;=(const QTime &amp;t) const;

// 静态函数 -&gt; 得到当前时间
[static] QTime QTime::currentTime();
</code></pre>
<h3 id="经时计时器"><a href="#经时计时器" class="headerlink" title="经时计时器"></a>经时计时器</h3><p>QTime的经时计时器已经过时了，推荐使用QElapsedTimer。</p>
<pre><code class="cpp">//QTime已废弃的函数
// 开始计时
void QTime::start();
// 计时结束
int QTime::elapsed() const;
// 重新计时
int QTime::restart();

// 推荐使用的API函数
// QElapsedTimer 类
void QElapsedTimer::start();
qint64 QElapsedTimer::restart();
qint64 QElapsedTimer::elapsed() const;
</code></pre>
<ul>
<li><p>主要的使用方法就是测量一个操作耗时多久，例子如下：</p>
<pre><code class="cpp">QElapsedTimer elapse;
elapse.start();

for(int i = 0;i&lt;10000000;i++);

qDebug()&lt;&lt;elapse.elapsed()&lt;&lt;endl;
</code></pre>
</li>
</ul>
<h2 id="QDateTime"><a href="#QDateTime" class="headerlink" title="QDateTime"></a>QDateTime</h2><pre><code class="c++">// 构造函数
QDateTime::QDateTime();
QDateTime::QDateTime(const QDate &amp;date, const QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);

// 公共成员函数
// 设置日期
void QDateTime::setDate(const QDate &amp;date);
// 设置时间
void QDateTime::setTime(const QTime &amp;time);
// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数
QDateTime QDateTime::addYears(int nyears) const;
QDateTime QDateTime::addMonths(int nmonths) const;
QDateTime QDateTime::addDays(qint64 ndays) const;
QDateTime QDateTime::addSecs(qint64 s) const;
QDateTime QDateTime::addMSecs(qint64 msecs) const;

// 得到对象中的日期
QDate QDateTime::date() const;
// 得到对象中的时间
QTime QDateTime::time() const;

// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数
QString QDateTime::toString(const QString &amp;format) const;


// 操作符重载 ==&gt; 日期时间对象的比较
bool QDateTime::operator!=(const QDateTime &amp;other) const;
bool QDateTime::operator&lt;(const QDateTime &amp;other) const;
bool QDateTime::operator&lt;=(const QDateTime &amp;other) const;
bool QDateTime::operator==(const QDateTime &amp;other) const;
bool QDateTime::operator&gt;(const QDateTime &amp;other) const;
bool QDateTime::operator&gt;=(const QDateTime &amp;other) const;

// 静态函数
// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)
[static] QDateTime QDateTime::currentDateTime();
</code></pre>
<h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p>Qt中提供了一组通用的基于模板的容器类（container class）。可以用来存储指定的项（items）,与STL(C++标准模板库)相比，Qt中的容器更轻量，更安全，功能更强大。</p>
<ul>
<li><p>序列式容器</p>
<ul>
<li>QList</li>
<li>QLinkedList</li>
<li>QVector</li>
<li>QStack</li>
<li>QQueue</li>
</ul>
<p><code>对于大多数应用程序，QList是最好的类型。虽然它是作为数组列表实现的，但是它提供了非常快的前置和附加。如果你真的需要一个链表，使用QLinkedList;如果您希望您的项目占用连续的内存位置，请使用QVector。QStack和QQueue是提供LIFO和FIFO语义的便利类。</code></p>
</li>
<li><p>关联式容器</p>
<ul>
<li>QMap</li>
<li>QMultiMap</li>
<li>QHash</li>
<li>QMultiHash</li>
<li>QSet</li>
</ul>
<p><code>“multi”容器方便地支持与单个键相关联的多个值。“hash”容器通过使用哈希函数而不是对排序集进行二进制搜索，从而提供更快的查找。</code></p>
</li>
<li><p>作为特殊情况，QCache和QContiguousCache类在有限的缓存存储中提供了对象的高效散列查找。</p>
</li>
</ul>
<h2 id="遍历容器"><a href="#遍历容器" class="headerlink" title="遍历容器"></a>遍历容器</h2><p>Qt提供了两种遍历容器的风格：</p>
<p><strong>java风格</strong>的迭代器和<strong>stl风格</strong>的迭代器。java风格的迭代器更容易使用并提供高级功能，而STL风格的迭代器稍微更高效，可以与Qt和STL的通用算法一起使用。</p>
<ul>
<li><strong>java风格</strong></li>
</ul>
<table>
<thead>
<tr>
<th>容器</th>
<th>只读迭代器</th>
<th>读写迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>QList<T>,QQueue<T></T></T></td>
<td>QListIterator<T></T></td>
<td>QMutableListIterator<T></T></td>
</tr>
<tr>
<td>QLinkedList<T></T></td>
<td>QLinkedListIterator<T></T></td>
<td>QMutableLinkedListIterator<T></T></td>
</tr>
<tr>
<td>QVector<T>,QStack<T></T></T></td>
<td>QVectorIterator<T></T></td>
<td>QMutableVectorIterator<T></T></td>
</tr>
<tr>
<td>QSet<T></T></td>
<td>QSetIterator<T></T></td>
<td>QMutableSetIterator<T></T></td>
</tr>
<tr>
<td>QMap&lt;Key,T&gt;,QMultiMap&lt;Key,T&gt;</td>
<td>QMapIterator<T></T></td>
<td>QMutableMapIterator<T></T></td>
</tr>
<tr>
<td>QHash&lt;Key,T&gt;,QMultiHash&lt;Key,T&gt;</td>
<td>QHashIterator<T></T></td>
<td>QMutableHashIterator<T></T></td>
</tr>
</tbody></table>
<ul>
<li><strong>STL风格</strong></li>
</ul>
<table>
<thead>
<tr>
<th>容器</th>
<th>只读迭代器</th>
<th>读写迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>QList<T>,QQueue<T></T></T></td>
<td>QList<T>::const_iterator</T></td>
<td>QList<T>::iterator</T></td>
</tr>
<tr>
<td>QLinkedList<T></T></td>
<td>QLinkedList<T>::const_iterator</T></td>
<td>QLinkedList<T>::iterator</T></td>
</tr>
<tr>
<td>QVector<T>,QStack<T></T></T></td>
<td>QVector<T>::const_iterator</T></td>
<td>QVector<T>::iterator</T></td>
</tr>
<tr>
<td>QSet<T></T></td>
<td>QSet<T>::const_iterator</T></td>
<td>QSet<T>::iterator</T></td>
</tr>
<tr>
<td>QMap&lt;Key,T&gt;,QMultiMap&lt;Key,T&gt;</td>
<td>QMap<T>::const_iterator</T></td>
<td>QMap<T>::iterator</T></td>
</tr>
<tr>
<td>QHash&lt;Key,T&gt;,QMultiHash&lt;Key,T&gt;</td>
<td>QHash<T>::const_iterator</T></td>
<td>QHash<T>::iterator</T></td>
</tr>
</tbody></table>
<pre><code class="cpp">QList&lt;int&gt; list;
list&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5;

QListIterator&lt;int&gt; it(list);
while (it.hasNext())
&#123;
    qDebug()&lt;&lt;it.next();
&#125;
</code></pre>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h3><p>QList模板提供了一个列表，实际上是一个指针数组，当项目数小于1000时，可以实现快速的插入删除操作</p>
<p>QList<T> 是 Qt 的通用容器类之一。它将项目存储在一个列表中，该列表提供基于索引的快速访问和基于索引的插入和删除。<br>QList<T>、QLinkedList<T> 和 QVector<T> 提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。</T></T></T></T></p>
<p><strong>使用概述：</strong></p>
<ul>
<li>QVector 应该是您的默认首选。 QVector<T> 通常会比 QList<T> 提供更好的性能，因为 QVector<T> 总是将其项按顺序存储在内存中，其中 QList<T> 将在堆上分配它的项，除非 sizeof(T) &lt;&#x3D; sizeof(void *) 并且 T 已使用 Q_DECLARE_TYPEINFO 声明为 Q_MOVABLE_TYPE 或 Q_PRIMITIVE_TYPE。</T></T></T></T></li>
<li>然而，QList 在整个 Qt API 被大量使用，用于传递参数和返回值。 使用 QList可以很方便的与这些 API 进行交互。</li>
<li>如果您需要一个真正的链表，它保证常量时间内插入列表，并且使用迭代器指向项而不是索引，那么请使用QLinkedList。</li>
</ul>
<h4 id="公有函数"><a href="#公有函数" class="headerlink" title="公有函数"></a>公有函数</h4><ul>
<li>添加数据</li>
</ul>
<pre><code class="cpp">//支持流插入
QList&lt;int&gt;()&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5;

void append(const T &amp;value)
void append(const QList&lt;T&gt; &amp;value)
 
void insert(int i, const T &amp;value)
QList::iterator insert(QList::iterator before, const T &amp;value)

void prepend(const T &amp;value)
void push_back(const T &amp;value)
void push_front(const T &amp;value)
</code></pre>
<ul>
<li>获取数据</li>
</ul>
<pre><code class="cpp">T &amp;back()
const T &amp;back() const  

T &amp;first()
const T &amp;first() const
T &amp;front()
const T &amp;front() const 

T &amp;last()
const T &amp;last() const 

const T &amp;constFirst() const
const T &amp;constLast() const

//返回下标为i的元素，如果下标i不合法，则返回defaultValue
T value(int i) const
T value(int i, const T &amp;defaultValue) const  
    
const T &amp;at(int i) const
T &amp;operator[](int i)
const T &amp;operator[](int i) const
//返回从位置pos开始的子列表。如果length为-1(默认)，则包含pos中的所有元素; 
QList&lt;T&gt; mid(int pos, int length = -1) const
</code></pre>
<ul>
<li>删除数据</li>
</ul>
<pre><code class="cpp">void clear()
    
QList::iterator erase(QList::iterator pos)
QList::iterator erase(QList::iterator begin, QList::iterator end)   

void pop_back()
void pop_front()
//删除元素   
int removeAll(const T &amp;value)
bool removeOne(const T &amp;value)
void removeAt(int i)
void removeFirst()
void removeLast()
//删除元素并返回它，如果不使用返回值，removeAt()会更高效 
T takeAt(int i)
T takeFirst()
T takeLast()
</code></pre>
<ul>
<li>查找&#x2F;替换</li>
</ul>
<pre><code class="cpp">//返回value在列表中第一次出现的索引位置，从索引位置from向前搜索。 如果没有匹配的项，则返回-1。  
int indexOf(const T &amp;value, int from = 0) const
//返回value在列表中最后一次出现的索引位置，从索引位置from反向搜索。如果from是-1(默认值)，则搜索从最后一项开始。如果没有匹配的项，则返回-1。     
int lastIndexOf(const T &amp;value, int from = -1) const
//将索引位置为i的项替换为value
void replace(int i, const T &amp;value)
//如果列表中包含值的出现，则返回true; 否则返回false。 该函数要求值类型具有operator==()的实现。     
bool contains(const T &amp;value) const
</code></pre>
<ul>
<li>交换&#x2F;移动</li>
</ul>
<pre><code class="cpp">//将索引位置from到索引位置to  
//[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;] move(1,4)-&gt; [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;B&quot;, &quot;F&quot;]
void move(int from, int to)

void swap(QList&lt;T&gt; &amp;other)
//交换下标i j的元素    
void swapItemsAt(int i, int j)
</code></pre>
<ul>
<li>判断函数</li>
</ul>
<pre><code class="cpp">int count(const T &amp;value) const
int count() const
int size() const
int length() const

bool empty() const
bool isEmpty() const
//如果列表第一项/后一项等于value,则返回true; 否则返回false。  
bool startsWith(const T &amp;value) const    
bool endsWith(const T &amp;value) const
//预分配空间大小    
void reserve(int alloc)
</code></pre>
<ul>
<li>和其他容器互转</li>
</ul>
<pre><code class="cpp">QSet&lt;T&gt; toSet() const
std::list&lt;T&gt; toStdList() const
QVector&lt;T&gt; toVector() const

[static] QList&lt;T&gt; fromSet(const QSet&lt;T&gt; &amp;set)
[static] QList&lt;T&gt; fromStdList(const std::list&lt;T&gt; &amp;list)
[static] QList&lt;T&gt; fromVector(const QVector&lt;T&gt; &amp;vector)
</code></pre>
<h3 id="QStringList"><a href="#QStringList" class="headerlink" title="QStringList"></a>QStringList</h3><p>QStringList继承自QList<QString>。 它提供基于索引的快速访问以及快速插入和删除。 将字符串列表作为值参数传递既快速又安全。<br>        QList的所有功能也适用于QStringList。 例如，可以使用isEmpty()来测试列表是否为空，还可以调用append()、prepend()、insert()、replace()、removeAll()、removeAt()、removeFirst()、removeLast()和removeOne()等函数来修改QStringList。 此外，QStringList提供了一些方便的函数，使处理字符串列表更容易:  </QString></p>
<ul>
<li>判断是否包含某个字符串</li>
</ul>
<pre><code class="cpp">bool contains(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
</code></pre>
<ul>
<li>过滤：返回包含子字符串str的所有字符串的列表</li>
</ul>
<pre><code class="cpp">QStringList filter(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QStringList filter(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QStringList filter(const QRegExp &amp;rx) const
QStringList filter(const QRegularExpression &amp;re) const
</code></pre>
<ul>
<li>查找</li>
</ul>
<pre><code class="cpp">//从左往右查找
int indexOf(const QRegExp &amp;rx, int from = 0) const
int indexOf(QStringView str, int from = 0) const
int indexOf(QLatin1String str, int from = 0) const
int indexOf(QRegExp &amp;rx, int from = 0) const
int indexOf(const QRegularExpression &amp;re, int from = 0) const
    
//从右往左查找    
int lastIndexOf(const QRegExp &amp;rx, int from = -1) const
int lastIndexOf(QStringView str, int from = -1) const
int lastIndexOf(QLatin1String str, int from = -1) const
int lastIndexOf(QRegExp &amp;rx, int from = -1) const
int lastIndexOf(const QRegularExpression &amp;re, int from = -1) const   
</code></pre>
<ul>
<li>连接：将QStringList中的所有字符串连接为一个字符串，每个元素由给定的分隔符(可以是空串)分隔。</li>
</ul>
<pre><code class="cpp">//支持流插入 &lt;&lt;
QString join(const QString &amp;separator) const
QString join(QStringView separator) const
QString join(QLatin1String separator) const
QString join(QChar separator) const
</code></pre>
<ul>
<li>删除：从QStringList中删除重复的元素。 返回已删除元素的数量。</li>
</ul>
<pre><code class="cpp">int removeDuplicates()
</code></pre>
<ul>
<li>替换：返回一个字符串列表，其中每个字符串在找到before文本时都将before文本替换为after文本</li>
</ul>
<pre><code class="cpp">QStringList &amp;replaceInStrings(const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QStringList &amp;replaceInStrings(QStringView before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QStringList &amp;replaceInStrings(const QString &amp;before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QStringList &amp;replaceInStrings(QStringView before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QStringList &amp;replaceInStrings(const QRegExp &amp;rx, const QString &amp;after)
QStringList &amp;replaceInStrings(const QRegularExpression &amp;re, const QString &amp;after)
</code></pre>
<ul>
<li>排序：升序</li>
</ul>
<pre><code class="cpp">void sort(Qt::CaseSensitivity cs = Qt::CaseSensitive)
</code></pre>
<h3 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a>QLinkedList</h3><p>单链表</p>
<h3 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a>QVector</h3><pre><code class="cpp">//返回vector底层数组指针。只要不重新分配vector对象，指针就保持有效。 这个函数在将vector传递给接受普通c++数组的函数时非常有用。    
T *data()
const T *data() const
//将value赋给向量中的所有项。 如果size不同于-1(默认值)，则vector的大小将被调整为size之前的大小。
QVector&lt;T&gt; &amp;fill(const T &amp;value, int size = -1)
</code></pre>
<h3 id="QStack"><a href="#QStack" class="headerlink" title="QStack"></a>QStack</h3><pre><code class="cpp">T pop()
void push(const T &amp;t)
void swap(QStack&lt;T&gt; &amp;other)
T &amp;top()
const T &amp;top() const
</code></pre>
<h3 id="QQueue"><a href="#QQueue" class="headerlink" title="QQueue"></a>QQueue</h3><pre><code class="cpp">//删除队头并返回它  
T dequeue()
//将值t加到队尾    
void enqueue(const T &amp;t)
//返回队头的引用
T &amp;head()
const T &amp;head() const
    
void swap(QQueue&lt;T&gt; &amp;other)
</code></pre>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h3><p>QMap&lt;Key, T&gt; 是 Qt 的通用容器类之一。 它存储(键，值)对，并提供与键关联的值的快速查找。<br>        QMap 和 QHash 提供非常相似的功能。 区别在于：</p>
<ul>
<li>QHash 提供比 QMap 更快的平均查找速度。</li>
<li>在迭代 QHash 时，项目是任意排序的。 使用 QMap，项目总是按键排序。</li>
<li>QHash 的键类型必须提供 operator&#x3D;&#x3D;() 和全局 qHash(Key) 函数。 QMap 的键类型必须提供 operator&lt;() 指定总顺序。 从 Qt 5.8.1 开始，使用指针类型作为键也是安全的，即使底层 operator&lt;() 不提供全序。</li>
</ul>
<h4 id="公有函数-1"><a href="#公有函数-1" class="headerlink" title="公有函数"></a>公有函数</h4><ul>
<li>添加数据</li>
</ul>
<pre><code class="cpp">//插入新的键值对，如果已经有一个键为key的项，则该项的值将被value替换；如果有多个键为key的项，则最近插入的项的值将被value替换。  
QMap::iterator insert(const Key &amp;key, const T &amp;value)
QMap::iterator insert(QMap::const_iterator pos, const Key &amp;key, const T &amp;value)
//插入新的键值对，如果在map中已经有一个具有相同键的项，这个函数将创建一个新的项    
QMap::iterator insertMulti(const Key &amp;key, const T &amp;value)
QMap::iterator insertMulti(QMap::const_iterator pos, const Key &amp;key, const T &amp;value)
</code></pre>
<ul>
<li>获取数据</li>
</ul>
<pre><code class="cpp">T &amp;first()
const T &amp;first() const
const Key &amp;firstKey() const
    
const Key key(const T &amp;value, const Key &amp;defaultKey = Key()) const 

QList&lt;Key&gt; keys() const
QList&lt;Key&gt; keys(const T &amp;value) const
T &amp;last()
const T &amp;last() const
const Key &amp;lastKey() const

//返回一个列表，该列表包含映射中的所有键。 在映射中出现多次的键在返回的列表中只出现一次。      
QList&lt;Key&gt; uniqueKeys() const
//将其他map中的所有项目插入到该map中。      
QMap&lt;Key, T&gt; &amp;unite(const QMap&lt;Key, T&gt; &amp;other)

const T value(const Key &amp;key, const T &amp;defaultValue = T()) const
QList&lt;T&gt; values() const
QList&lt;T&gt; values(const Key &amp;key) const

T &amp;operator[](const Key &amp;key)
const T operator[](const Key &amp;key) const
</code></pre>
<ul>
<li>删除数据</li>
</ul>
<pre><code class="cpp">void clear()

QMap::iterator erase(QMap::iterator pos)

int remove(const Key &amp;key)
    
T take(const Key &amp;key)
</code></pre>
<ul>
<li>查找</li>
</ul>
<pre><code class="cpp">bool contains(const Key &amp;key) const
/* 返回两个迭代器
迭代器1：是指向当前 map 容器中第一个大于或等于 key 的键值对的迭代器（lowerBound()）。
迭代器2：是指向当前 map 容器中第一个大于 key 的键值对的迭代器。（upperBound()）
*/
QPair&lt;QMap::iterator, QMap::iterator&gt; equal_range(const Key &amp;key)
QPair&lt;QMap::const_iterator, QMap::const_iterator&gt; equal_range(const Key &amp;key) const
    
QMap::iterator find(const Key &amp;key)
QMap::const_iterator find(const Key &amp;key) const
    
QMap::iterator lowerBound(const Key &amp;key)
QMap::const_iterator lowerBound(const Key &amp;key) const

QMap::iterator upperBound(const Key &amp;key)
QMap::const_iterator upperBound(const Key &amp;key) const
</code></pre>
<ul>
<li>判断</li>
</ul>
<pre><code class="cpp">int count(const Key &amp;key) const
int count() const
int size() const
    
bool empty() const
bool isEmpty() const
</code></pre>
<h3 id="QMultiMap"><a href="#QMultiMap" class="headerlink" title="QMultiMap"></a>QMultiMap</h3><ul>
<li>插入和替换：插入新的键值对。  <ul>
<li>如果已经有一个键为key的项，则该项的值将被value替换。 </li>
<li>如果有多个键为key的项，则最近插入的项的值将被value替换。</li>
</ul>
</li>
</ul>
<pre><code class="cpp">typename QMap&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value)
</code></pre>
<h3 id="QHash"><a href="#QHash" class="headerlink" title="QHash"></a>QHash</h3><ul>
<li>添加数据</li>
</ul>
<pre><code class="cpp">QHash::iterator insert(const Key &amp;key, const T &amp;value)
QHash::iterator insertMulti(const Key &amp;key, const T &amp;value)
</code></pre>
<ul>
<li>获取数据</li>
</ul>
<pre><code class="cpp">const Key key(const T &amp;value) const
const Key key(const T &amp;value, const Key &amp;defaultKey) const

QList&lt;Key&gt; keys() const
QList&lt;Key&gt; keys(const T &amp;value) const
   
QList&lt;Key&gt; uniqueKeys() const
QHash&lt;K, V&gt; &amp;unite(const QHash&lt;K, V&gt; &amp;other)
const T value(const Key &amp;key) const
const T value(const Key &amp;key, const T &amp;defaultValue) const
QList&lt;T&gt; values() const
QList&lt;T&gt; values(const Key &amp;key) const
</code></pre>
<ul>
<li>删除数据</li>
</ul>
<pre><code class="cpp">void clear()

QHash::iterator erase(QHash::const_iterator pos)
QHash::iterator erase(QHash::iterator pos)
    
QPair&lt;QHash::iterator, QHash::iterator&gt; equal_range(const Key &amp;key)
QPair&lt;QHash::const_iterator, QHash::const_iterator&gt; equal_range(const Key &amp;key) const
   
int remove(const Key &amp;key)

T take(const Key &amp;key)
</code></pre>
<ul>
<li>查找</li>
</ul>
<pre><code class="cpp">bool contains(const Key &amp;key) const
    
QHash::iterator find(const Key &amp;key)
QHash::const_iterator find(const Key &amp;key) const
</code></pre>
<ul>
<li>判断</li>
</ul>
<pre><code class="cpp">int count(const Key &amp;key) const
int count() const
int size() const
    
bool empty() const    
</code></pre>
<h3 id="QMultiHash"><a href="#QMultiHash" class="headerlink" title="QMultiHash"></a>QMultiHash</h3><p><code>继承自QHash</code></p>
<pre><code class="cpp">typename QHash&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value)
</code></pre>
<ul>
<li>案例</li>
</ul>
<pre><code class="cpp">class Grade //班级
&#123;
public:
    Grade(int number, const QString&amp; GradeName)
        :number(number),name(GradeName)
    &#123;&#125;
    friend QDebug operator&lt;&lt;(QDebug out, const Grade&amp; stu);
    friend bool operator==(const Grade&amp; left, const Grade&amp; right);
    friend uint qHash(const Grade&amp; stu, uint seed = 0);
private:
    int number;     //班级号
    QString name;   
&#125;;
QDebug operator&lt;&lt;(QDebug out, const Grade&amp; stu)
&#123;
    out &lt;&lt; &quot;[&quot; &lt;&lt; stu.number &lt;&lt;&quot;,&quot; &lt;&lt; stu.name &lt;&lt; &quot;]&quot;;
    return out;
&#125;
bool operator==(const Grade&amp; left, const Grade&amp; right)
&#123;
    return (left.number == right.number);
&#125;
uint qHash(const Grade&amp; stu, uint seed)
&#123;
    return stu.number;
&#125;

int main(int argc, char *argv[])
&#123;
    QCoreApplication a(argc, argv);

    QHash&lt;Grade, QString&gt; hash;
    hash.insert(Grade(1403, &quot;安卓&quot;), &quot;张三&quot;);
    hash.insert(Grade(1406, &quot;苹果&quot;), &quot;李四&quot;);

    qDebug() &lt;&lt; hash;

    return a.exec();
&#125;
</code></pre>
<h3 id="QSet"><a href="#QSet" class="headerlink" title="QSet"></a>QSet</h3><ul>
<li>添加数据</li>
</ul>
<pre><code class="cpp">QSet::iterator insert(const T &amp;value)
</code></pre>
<ul>
<li>获取数据</li>
</ul>
<pre><code class="cpp">QList&lt;T&gt; values() const
QList&lt;T&gt; toList() const
</code></pre>
<ul>
<li>删除数据</li>
</ul>
<pre><code class="cpp">void clear()

QSet::iterator erase(QSet::const_iterator pos)
QSet::iterator erase(QSet::iterator pos)
    
bool remove(const T &amp;value) 
</code></pre>
<ul>
<li>查找</li>
</ul>
<pre><code class="cpp">bool contains(const T &amp;value) const
bool contains(const QSet&lt;T&gt; &amp;other) const
    
QSet::const_iterator find(const T &amp;value) const
QSet::iterator find(const T &amp;value)
</code></pre>
<ul>
<li>其他</li>
</ul>
<pre><code class="cpp">int count() const
bool empty() const
bool isEmpty() const
int size() const
</code></pre>
<ul>
<li>交集，差集，并集</li>
</ul>
<pre><code class="cpp">//并集：ohter集合中不在这个集合中的每一项都被插入到这个集合中。 返回对该集合的引用。      
QSet&lt;T&gt; &amp;unite(const QSet&lt;T&gt; &amp;other)
//差集：从该集合中删除包含在ohter集合中的所有项。 返回对该集合的引用。  
QSet&lt;T&gt; &amp;QSet::subtract(const QSet&lt;T&gt; &amp;other)
//交集：从该集合中删除ohter集合中不包含的所有项。 返回对该集合的引用。      
QSet&lt;T&gt; &amp;intersect(const QSet&lt;T&gt; &amp;other)
//如果该集合与ohter集合至少有一个共同项，则返回true。      
bool intersects(const QSet&lt;T&gt; &amp;other) const 
</code></pre>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>直接使用STL中的算法</p>
<h2 id="QtGlobal"><a href="#QtGlobal" class="headerlink" title="QtGlobal"></a>QtGlobal</h2><p>Qt类的头文件都会包含该头文件，所以不用再显式定义了</p>
<pre><code class="cpp">T qAbs(const T &amp;t)	//求绝对值
//返回value限定在min至max范围之内的值
const T &amp;qBound(const T &amp;min, const T &amp;val, const T &amp;max)
//如果p1和p2近似相等，返回true
bool qFuzzyCompare(double p1, double p2)
bool qFuzzyCompare(float p1, float p2)
//如果浮点数约等于0，返回true    
bool qFuzzyIsNull(double d)
bool qFuzzyIsNull(float f)
//返回无穷大的数    
double qInf()
//求最大值和最小值
const T &amp;qMax(const T &amp;a, const T &amp;b)
const T &amp;qMin(const T &amp;a, const T &amp;b)
//四舍五入到最近的整数
qint64 qRound64(double d)
qint64 qRound64(float d)
int qRound(double d)
int qRound(float d)
//获得Qt版本    
const char *qVersion()
</code></pre>
<h2 id="QtMath"><a href="#QtMath" class="headerlink" title="QtMath"></a>QtMath</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><pre><code class="cpp">qreal qAcos(qreal v)
qreal qAsin(qreal v)
qreal qAtan2(qreal y, qreal x)
qreal qAtan(qreal v)
int qCeil(qreal v)
qreal qCos(qreal v)
//角度转弧度    
float qDegreesToRadians(float degrees)
double qDegreesToRadians(double degrees)
qreal qExp(qreal v)
qreal qFabs(qreal v)
int qFloor(qreal v)
qreal qLn(qreal v)
quint32 qNextPowerOfTwo(quint32 value)
quint64 qNextPowerOfTwo(quint64 value)
quint32 qNextPowerOfTwo(qint32 value)
quint64 qNextPowerOfTwo(qint64 value)
qreal qPow(qreal x, qreal y)
float qRadiansToDegrees(float radians)
double qRadiansToDegrees(double radians)
qreal qSin(qreal v)
qreal qSqrt(qreal v)
qreal qTan(qreal v)
</code></pre>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M_E</td>
<td>自然对数的底 （欧拉数）</td>
</tr>
<tr>
<td>M_LOG2E</td>
<td>以2为底e的对数</td>
</tr>
<tr>
<td>M_LOG10E</td>
<td>以10为底的e的对数</td>
</tr>
<tr>
<td>M_LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>M_LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>M_PI</td>
<td>π</td>
</tr>
<tr>
<td>M_PI_2</td>
<td>π&#x2F;2</td>
</tr>
<tr>
<td>M_PI_4</td>
<td>π&#x2F;4</td>
</tr>
<tr>
<td>M_1_PI</td>
<td>1&#x2F;π</td>
</tr>
<tr>
<td>M_2_PI</td>
<td>2&#x2F;π</td>
</tr>
<tr>
<td>M_2_SQRTPI</td>
<td>2除以π的平方根，2 &#x2F;√π</td>
</tr>
<tr>
<td>M_SQRT2</td>
<td>根号2</td>
</tr>
<tr>
<td>M_SQRT1_2</td>
<td>1&#x2F;√π</td>
</tr>
</tbody></table>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。邮件至kpsun@foxmail.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>QT(常用数据类型)</p>
    <p><span class="copy-title">字数:</span><span class="post-count">11.3k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="kpsun">kpsun</a></p>
    <p><span class="copy-title">发布时间:</span>2022-09-01, 15:32:46</p>
    <p><span class="copy-title">最后更新:</span>2022-10-07, 16:10:04</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2022/09/01/QT(%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)/" title="QT(常用数据类型)">http://goskp.github.io/2022/09/01/QT(%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>








    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>


        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script></body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
