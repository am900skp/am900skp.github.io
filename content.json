{"meta":{"title":"kpsun","subtitle":"","description":"","author":"kpsun","url":"http://goskp.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-07-14T04:24:56.000Z","updated":"2022-09-14T12:29:33.592Z","comments":true,"path":"about/index.html","permalink":"http://goskp.github.io/about/index.html","excerpt":"","text":"个人简介孙楷朋准大二计算机相关专业在读热爱编程,乐于合作,善于总结分享,有良好的的编程习惯目标BAT大厂联系方式 QQ: 1287923885 WeChat: code_cpp Email: &#x6b;&#112;&#x73;&#x75;&#x6e;&#64;&#x66;&#111;&#x78;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;"},{"title":"category","date":"2022-08-14T04:20:49.000Z","updated":"2022-08-14T04:20:49.238Z","comments":true,"path":"category/index.html","permalink":"http://goskp.github.io/category/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2022-10-01T02:34:34.000Z","updated":"2022-10-01T02:49:39.113Z","comments":true,"path":"2022/10/01/设计模式-观察者模式/","link":"","permalink":"http://goskp.github.io/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"基于QT信号与槽机制,简单实现一下观察者模式#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; class Boss; //观察者类 class Staff &#123; public: Staff(std::string name, Boss* pBoss) : name(name), pBoss(pBoss) &#123;&#125; void Update(std::string action) &#123; std::cout &lt;&lt; name &lt;&lt; &quot;收到信息:&quot; &lt;&lt; action; if (action == &quot;老板大门走进来&quot;) &#123; std::cout &lt;&lt; &quot;--&gt;开启认真工作模式&quot; &lt;&lt; std::endl; &#125; else if (action == &quot;老板走出大门&quot;) &#123; std::cout &lt;&lt; &quot;--&gt;开启摸鱼状态&quot; &lt;&lt; std::endl; &#125; &#125; private: std::string name; Boss* pBoss; &#125;; //被观察者 class Boss &#123; public: void AddObserver(Staff* pstaff) &#123; staff.push_back(pstaff); &#125; void NotiFy(std::string action) &#123; for (auto&amp; v : staff) &#123; v-&gt;Update(action); &#125; &#125; void SetAction(std::string action) &#123; this-&gt;action = action; NotiFy(action); &#125; private: std::string action; std::vector&lt;Staff*&gt; staff; &#125;; int main(void) &#123; //创建被观察者 Boss* pBoss = new Boss; //创建观察者 Staff* p1 = new Staff(&quot;kpsun&quot;, pBoss); Staff* p2 = new Staff(&quot;skp&quot;, pBoss); //添加到观察者中,建立关联 pBoss-&gt;AddObserver(p1); pBoss-&gt;AddObserver(p2); //设置观察者状态 pBoss-&gt;SetAction(&quot;老板大门走进来&quot;); pBoss-&gt;SetAction(&quot;老板走出大门&quot;); return 0; &#125; kpsun收到信息:老板大门走进来–&gt;开启认真工作模式skp收到信息:老板大门走进来–&gt;开启认真工作模式kpsun收到信息:老板走出大门–&gt;开启摸鱼状态skp收到信息:老板走出大门–&gt;开启摸鱼状态","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://goskp.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://goskp.github.io/tags/DesignPattern/"}]},{"title":"C/C++常用刷题技巧","slug":"C++常用刷题技巧","date":"2022-09-30T07:36:35.000Z","updated":"2022-09-30T07:42:32.433Z","comments":true,"path":"2022/09/30/C++常用刷题技巧/","link":"","permalink":"http://goskp.github.io/2022/09/30/C++%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E6%8A%80%E5%B7%A7/","excerpt":"","text":"C&#x2F;C++常用刷题技巧万能头文件 万能头文件 基本包括了大部分的STL库函数，使用方便快捷 #include &lt;bits/stdc++.h&gt; vectorvector&lt;int&gt; first; // 空的vector，只是一个列表的头，里面没有元素 vector&lt;int&gt; second (4, 100); // 初始化一个具有4个元素的vector，每个元素的值都是100 vector&lt;int&gt; third (second.begin(), second.end()); // 通过其他vector的迭代器的方式，进行拷贝复制初始化 vector&lt;int&gt; fourth (third); // 直接对其他vector的拷贝复制 int myints[] = &#123;16, 2, 77&#125;; vector&lt;int&gt; fifth (myints, myints+sizeof(myints) / sizeof(int)); // 将数组转化成vector，需要提供的是数组的首地址和地址偏移。 vector&lt;int&gt; sixth = &#123;1,5,4,6&#125;; // 指定内容进行构造，内容为1,5,4,6的vector vector&lt; vector&lt;int&gt; &gt; vars; // 二维vector的初始化 int size = 10; vector&lt;vector&lt;int&gt;&gt; vars(size, vector&lt;int&gt;(size, 0)); // （size,size）的矩阵，元素全部是0 #include&lt;vector&gt; vector&lt;int&gt; test;//建立一个vector test.push_back(1); test.push_back(2);//把1和2压入vector，这样test[0]就是1,test[1]就是2 cout&lt;&lt;vec[0]&lt;&lt;endl;//使用下标访问元素 //使用迭代器访问元素. vector&lt;int&gt;::iterator it; for(it=vec.begin();it!=vec.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; vec.insert(vec.begin()+i,a);//在第i+1个元素前面插入a; vec.erase(vec.begin()+2);//删除第3个元素 vec.erase(vec.begin()+i,vec.end()+j);//删除区间[i,j-1];区间从0开始 cout&lt;&lt;vec.size()&lt;&lt;endl;//向量大小 vec.clear();//清空 sort(v.begin(),v.end()); //用sort()函数从小到大进行排序 reverse(v.begin(),v.end()); // 用reverse()函数翻转数组 v.size() // 返回容器的大小 v.empty() //判断容器是否为空，为空返回0，不为空则为1 cout&lt;&lt;v[0]; // 打印第一个元素 cout&lt;&lt;v[v.size()] //打印最后一个元素 lower_bound(v.begin(),v.end(),a) //在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址 upper_bound(v.begin(),v.end(),a)-v.begin() //在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置 vector&lt;int&gt;::iterator it; //定义迭代器方便得到元素值，相当于指针 it=upper_bound(v.begin,v.end(),a) cout&lt;&lt;(*it) //这里返回的是第一个大于a的元素的值 二维数组初始化vector&lt;vector &lt;int&gt; &gt; a(3);//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的 //如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制； for(int i=0;i&lt;a.size();i++)//利用resize函数将每一行的元素个数设置为5个，即5列 a[i].resize(5);//此时我们得到的就是一个3行5列的二维数组 如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用a[0].size() vector&lt;vector &lt;int&gt; &gt; a(3);//初始化的是3*3的矩阵 for(int i=0;i&lt;a.size();i++)//利用resize函数将每一行的元素个数设置为5个，即5列 a[i].resize(5); cout&lt;&lt;a.size()&lt;&lt;endl;//打印的是vector的行数 除上述初始化行列数不同的二维数组之外，我们也可以直接定义，结果也是3行5列的二维数组 vector&lt;vector&lt;int&gt; &gt; Array(3, vector&lt;int&gt;(5)); cout&lt;&lt;Array[0].size()&lt;&lt;endl; //以下也可以 vector&lt;vector&lt;int&gt; &gt;num = &#123; &#123; 1, 1, 1, 0, 1, 1 &#125;, &#123; 1, 0, 1, 1, 1, 1 &#125;, &#123; 1, 1, 1, 0, 0, 1 &#125;, &#123; 1, 0, 1, 0, 0, 1 &#125;, &#123; 1, 1, 1, 1, 1, 1 &#125; &#125;; 字符串部分string s; string t=&quot;m&quot;; cin&gt;&gt;s;//不包括空格 getline(cin,s);//读取一行，可以包含空格 s.append(t);//将字符t添加到s cout&lt;&lt;s+t; //同上述效果一样 //find(“字符串”) / find(&quot;字符串&quot;,postion) ---找不到就返回很大很大的数,可以与-1比较 if(s1.find(s2)==-1)&#123; cout&lt;&lt;&quot;在s1中未找到s2&quot;&lt;&lt;endl; &#125; cout&lt;&lt;s.find(t)&lt;&lt;endl; //找子序列t在s中出现的首次位置 cout&lt;&lt;s.find(t,2)&lt;&lt;endl; //从第二个位置开始找，找子序列t在s中出现的首次位置 int len = s.size();//字符串s的⻓度 int len = s.length();//字符串s的⻓度 cout&lt;&lt;*s1.begin()&lt;&lt;endl;//指向字符串的第一个元素 cout&lt;&lt;*(s1.end()-1)&lt;&lt;endl;//指向字符串的最后一个元素 reverse(s.begin(), s.end());//字符串反转 string s1 = &quot;hello&quot;; string sTemp=s1.substr(1);//下标1开始到结束 //截取substr（pos,num） ----在哪个位置截取，截取多少字符 string sTemp2 = s1.substr(1,3);//下标1开始，截取3个字符 cout&lt;&lt;sTemp&lt;&lt;&quot;----&quot;&lt;&lt;sTemp2&lt;&lt;endl; cout&lt;&lt;s1[0]&lt;&lt;endl; //访问字符串的0处的位置 string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; //两个字符串之间的大小关系 cout&lt;&lt;(s1==s2)&lt;&lt;endl; cout&lt;&lt;(s1&gt;s2)&lt;&lt;endl; cout&lt;&lt;(s1&lt;s2)&lt;&lt;endl; //插入insert(position,&quot;字符串&quot;) s1.insert(1,&quot;b&quot;); cout&lt;&lt;s1; //删除 erase(pos,num)----在哪个位置删除多少字符 s1.earse(1,2); //将123456转为字符串 s1 = to_string(123456); cout&lt;&lt;s1; //将字符型1234转为int类型 ---string to int int x=stoi(&quot;1234&quot;); cout&lt;&lt;x&lt;&lt;endl; 栈 #include&lt;stack&gt; //要引入库函数 stack&lt;int&gt; s ; for(int i=0;i&lt;6;i++)&#123; s.push(i);//入栈操作 &#125; cout&lt;&lt;s.top()&lt;&lt;endl; //访问s的栈顶元素 cout&lt;&lt;s.size()&lt;&lt;endl; 输出s的元素个数 s.pop(); // 删除栈顶元素但不返回其值 cout&lt;&lt;s.empty()&lt;&lt;endl; //非空返回0，是空返回1 队列#include&lt;queue&gt;//要引入库函数 queue&lt;int&gt; s ; for(int i=0;i&lt;6;i++)&#123; s.push(i);//将i元素接到队列的末端； &#125; cout&lt;&lt;&quot;首元素为：&quot;&lt;&lt;s.front()&lt;&lt;endl; //访问队首元素 cout&lt;&lt;&quot;队尾元素：&quot;&lt;&lt;s.back()&lt;&lt;endl; 访问队尾元素 s.pop(); // 弹出队列的第一个元素，并不会返回元素的值； cout&lt;&lt;s.empty()&lt;&lt;endl; //非空返回0，是空返回1 set ⼀个set⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且set会按照元素进⾏从⼩到⼤排序 #include&lt;set&gt; set&lt;int&gt; s; s.insert(2);//插入元素 s.insert(100);//插入元素 for(int i=0;i&lt;6;i++)&#123; s.insert(i);//插入元素 &#125; //迭代变量set&lt;int&gt;::iterator it for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//集合的遍历，it是一个迭代的指针 &#125; //方法二： for(auto v: s) cout&lt;&lt;v&lt;&lt;&quot; &quot;; //输入结果：0 1 2 3 4 5 100 //按照从小到大排序，且删除相同元素 s.erase(3);//删除元素为3的 s.clear();//清空 s.size();//长度 s.empty();//判空 cout&lt;&lt;*s.find(2)&lt;&lt;endl; //查找某一个num值，返回的是迭代器，因此需要*来输出 map map&lt;int,int&gt; mp; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; mp[x] =i; &#125; for(auto v: mp) cout&lt;&lt;v.first&lt;&lt;&quot; ： &quot;&lt;&lt;v.second&lt;&lt;endl; unordered_map//1. 头文件 #include &lt;unordered_map&gt; //2. 初始化 unordered_map&lt;char, int&gt; map; //3. 插入元素 //3.1 数组形式 map[&#39;a&#39;] = 1; //3.2 直接插入 map.insert( &#123; &#123;&#39;b&#39;,2&#125; , &#123;&#39;c&#39;,3&#125; &#125; ); //4. 修改元素 map[&#39;a&#39;] = 0; //5. 删除元素 //5.1 删除key为&#39;a&#39;的元素 map.erase(&#39;a&#39;); //5.2删除第一个元素 map.erase(map.begin()); //6. 判断元素是否存在 //6.1 如果元素存在 if(map.find(&#39;a&#39;)!=map.end()) if(map.count(&#39;a&#39;)!=0) //7. 清空所有元素 map.clear(); //8. 遍历取值并取出键和值 //方法一 for( auto&amp; a : map) &#123; char key= a.first; int value= a.second; &#125; //方法二 for (auto it = map.begin(); it != map.end(); it++) &#123; char key = it-&gt;first; int value = it-&gt;second; &#125; //9. 判断是否为空 if( map.empty() ) //10. 求元素个数 map.size(); ACM模式输入输出参考书程序#include&lt;iostream&gt; #include&lt;sstream&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;limits.h&gt; //INT_MIN 和 INT_MAX的头文件 using namespace std; struct stu &#123; string name; int num; &#125;; // 1. 直接输入一个数 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; cout &lt;&lt; n &lt;&lt; endl; &#125; return -1; &#125; // 2. 直接输入一个字符串 int main() &#123; string str; while (cin &gt;&gt; str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; return -1; &#125; // 3. 只读取一个字符 int main() &#123; char ch; //方式1 while (cin &gt;&gt; ch) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; //方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get() while (cin.get(ch)) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; //方式3 ：ch = getchar() while (getchar()) &#123; cout &lt;&lt; ch &lt;&lt; endl; &#125; return -1; &#125; // 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; //每次读取1 + n 个数，即一个样例有n+1个数 vector&lt;int&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; //处理这组数/字符串 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; endl; &#125; &#125; return -1; &#125; //3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符 int main() &#123; int n = 0; while (cin &gt;&gt; n) &#123; //输入数量 vector&lt;string&gt; strs; for (int i = 0; i &lt; n; i++) &#123; string temp; cin &gt;&gt; temp; strs.push_back(temp); &#125; //处理这组字符串 sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &#39; &#39;; &#125; &#125; return 0; &#125; //4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开 //4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理 int main() &#123; int ele; while (cin &gt;&gt; ele) &#123; int sum = ele; // getchar() //读取单个字符 /*while (cin.get() != &#39;\\n&#39;) &#123;*/ //判断换行符号 while (getchar() != &#39;\\n&#39;) &#123; //如果不是换行符号的话，读到的是数字后面的空格或者table int num; cin &gt;&gt; num; sum += num; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; //4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行 int main() &#123; string str; vector&lt;string&gt; strs; while (cin &gt;&gt; str) &#123; strs.push_back(str); if (getchar() == &#39;\\n&#39;) &#123; //控制测试样例 sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; strs.clear(); &#125; &#125; return 0; &#125; //4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。 int main() &#123; string input; while (getline(cin, input)) &#123; //读取一行 stringstream data(input); //使用字符串流 int num = 0, sum = 0; while (data &gt;&gt; num) &#123; sum += num; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; //4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。 int main() &#123; string words; while (getline(cin, words)) &#123; stringstream data(words); vector&lt;string&gt; strs; string str; while (data &gt;&gt; str) &#123; strs.push_back(str); &#125; sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; &#125; &#125; //4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#39;,&#39;间隔 int main() &#123; string line; //while (cin &gt;&gt; line) &#123; //因为加了“，”所以可以看出一个字符串读取 while(getline(cin, line))&#123; vector&lt;string&gt; strs; stringstream ss(line); string str; while (getline(ss, str, &#39;,&#39;)) &#123; strs.push_back(str); &#125; // sort(strs.begin(), strs.end()); for (auto&amp; str : strs) &#123; cout &lt;&lt; str &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; int main() &#123; string str; //C语言读取字符、数字 int a; char c; string s; scanf_s(&quot;%d&quot;, &amp;a); scanf(&quot;%c&quot;, &amp;c); scanf(&quot;%s&quot;, &amp;s); printf(&quot;%d&quot;, a); //读取字符 char ch; cin &gt;&gt; ch; ch = getchar(); while (cin.get(ch)) &#123; //获得单个字符 ; &#125; //读取字符串 cin &gt;&gt; str; //遇到空白停止 getline(cin, str); //读入一行字符串 &#125; 自带的宏常量int N = INT_MIN; int N = INT_MAX; const int INF = 0x3f3f3f3f; //通常用来代替最大值，防止运算过程中溢出 0x16进制 字符串判断函数isdigit(c) //判断c字符是不是数字 isalpha(c) //判断c字符是不是字母 isalnum(c) //判断c字符是不是数字或者字母 tolower(c) //转为小写 toupper(c) //转为大写 字符串和数值间的转换int num = 100; string str = to_string(num); //整形转字符串 int number = stoi(str); //字符串转为整形 stol()是字符串转为长整形 迭代器的二分vector&lt;int&gt; nums&#123;1,2,34,44,99&#125;; int k = lower_bound(nums.begin(), nums.end(), 56) - nums.begin(); //第一个大于等于目标值的迭代器位置 int k = upper_bound(nums.begin(), nums.end(), 56) - nums.begin(); // 找到第一个大于目标值的迭代器位置 字符串转为小写/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/ transform(str1.begin(), str1.end(), str2.begin(), ::toupper); transform(str1.begin(), str1.end(), str2.begin(), ::tolower); 小根堆priority_queue&lt;int&gt; pq; //默认是大根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; //小根堆 快速初始化数组// 注意：这个函数是按字节初始化的 memset(nums, 0, sizeof nums); memset(nums, -1, sizeof nums); memset(nums, 0x3f, sizeof nums); C++11的特性auto p = new ListNode(); // auto 关键字 Node* pre = nullptr // nullptr代替NULL unordered_map&lt;int,int&gt; mp; //哈希表 内部是无序的 unordered_set&lt;int&gt; st; //无序集合 bitsetuint32_t reverseBits(uint32_t n) &#123; string s = bitset&lt;32&gt;(n).to_string(); reverse(s.begin(), s.end()); return bitset&lt;32&gt;(s).to_ulong(); &#125; 字符串分割将字符串按照空格分割 string s = &quot;hello world my name is yao jun&quot;; stringstream ss(s); string str; int cnt = 0; while(ss &gt;&gt; str)&#123; cnt++; cout&lt;&lt;str&lt;&lt;endl; &#125; cout&lt;&lt;cnt&lt;&lt;endl; 执行结果： hello world my name is yao jun 7 四舍五入保留小数char str[10]; double num = 22.23434; sprintf(str, &quot;%.2f&quot;, num); string s = str; cout&lt;&lt;s&lt;&lt;endl; 字符串按格式拆分string a = &quot;12:59:36&quot;; char str2[100]; memcpy(str2, a.c_str(), strlen(a.c_str())); int u, v, w; sscanf(str2, &quot;%d:%d:%d&quot;, &amp;u, &amp;v, &amp;w); cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; 执行结果： 12 59 36 相同字符的字符串string s(10, &#39;a&#39;); cout&lt;&lt;s&lt;&lt;endl; 执行结果: aaaaaaaaaa 结构体排序struct node&#123; int a, b; // 从小到大排序 bool operator &lt; (const node&amp; node_)const&#123; if(a != node_.a) return a &lt; node_.a; return b &lt; node_.b; &#125; &#125;; int main()&#123; vector&lt;node&gt; tt; tt.push_back(&#123;1,5&#125;); tt.push_back(&#123;2,3&#125;); sort(tt.begin(), tt.end()); for(auto &amp;node: tt)&#123; cout&lt;&lt;node.a&lt;&lt;&quot; &quot;&lt;&lt;node.b&lt;&lt;endl; &#125; return 0; &#125; 执行结果： 1 5 2 3 优先队列自定义排序struct node&#123; int a, b; // 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面 bool operator &lt; (const node&amp; node_)const&#123; if(a != node_.a) return a &lt; node_.a; return b &lt; node_.b; &#125; &#125;; int main()&#123; priority_queue&lt;node&gt; pq; pq.push(&#123;1,5&#125;); pq.push(&#123;2,3&#125;); pq.push(&#123;2,5&#125;); while(!pq.empty()) &#123; cout&lt;&lt;pq.top().a&lt;&lt;&quot; &quot;&lt;&lt;pq.top().b&lt;&lt;endl; pq.pop(); &#125; return 0; &#125; 执行结果 2 5 2 3 1 5","categories":[{"name":"算法","slug":"算法","permalink":"http://goskp.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://goskp.github.io/tags/Algorithm/"}]},{"title":"QT(布局)","slug":"QT(布局)","date":"2022-09-29T10:53:52.000Z","updated":"2022-09-29T10:58:07.360Z","comments":true,"path":"2022/09/29/QT(布局)/","link":"","permalink":"http://goskp.github.io/2022/09/29/QT(%E5%B8%83%E5%B1%80)/","excerpt":"","text":"布局管理组(Layouts)什么是布局管理器？你一个窗口里面一般有很多widgets对吧，你如果要自己调它们的位置，大小的话会比较麻烦，而且当窗口变大的时候它里面的widgets又不会跟着变大，就很烦恼。所以，我们有这个东西，布局管理器，相当于一个小管家，你只要把widgets丢进去，他自己会帮你排好它的。 方法： 首先，创建好我们想要布局的widgets。 然后，我们创建 QBoxLayout 对象并将小部件添加到布局中。 最后，我们调用 QWidget::setLayout() 将 QBoxLayout 对象安装到小部件上。 此时，布局中的小部件将重新设置父对象，为上面调用setLayout()的窗口。 1，盒子布局(BoxLayout)QBoxLayout可以在水平方向或垂直方向上排列控件，分别派生了QHBoxLayout、QVBoxLayout子类。 QHBoxLayout：水平布局，在水平方向上排列控件，即：左右排列。 QVBoxLayout：垂直布局，在垂直方向上排列控件，即：上下排列。 水平布局、垂直布局除了构造时的方向（LeftToRight、TopToBottom）不同外，其它均相同。 公有函数 序号 函数&amp;描述 1 void addLayout(QLayout* layout,int stretch &#x3D; 0)将layout添加到框的末端，使用连续拉伸因子拉伸。 2 void addSpacerItem(QSpacerItem * spacerItem)将spaceeritem添加到该盒子布局的末尾，通常不使用这个函数，请使用addSpacing(int size) 3 void addSpacing(int size)添加一个大小为size的不可伸缩空间(QSpacerItem)到这个框布局的末尾 4 void addStretch(int stretch &#x3D; 0)添加一个可伸缩空间(一个QSpacerItem)，最小尺寸为零，拉伸因子stretch到这个框布局的末尾。 5 void addStrut(int size)限制盒子的垂直尺寸最小为size 6 void addWidget(QWidget* widget,int stretch &#x3D; 0,Qt::Alignment alignment &#x3D; 0)将小部件添加到此框布局的末尾，并使用拉伸因子拉伸和对齐对齐。 7 void setDirection(QBoxLayout::Direction direction)设置此布局的方向为direction。 8 void setSpacing(int spacing)设置小部件之间的间距 9 void setStretch(int index,int stretch)给index位置的控件设置拉伸因子stretch 10 bool setStretchFactor(QWidget* widget,int stretch)bool setStretchFactor(QWidget* widget,int stretch)设置小部件的拉伸因子，如果在布局中发现小部件(不包括子布局)，则返回true; 否则返回false。 下面我们以QHBoxLayout为例，来讲解QBoxLayout的常用功能。 简单布局 //创建需要布局的小部件 QLabel* nameLabel = new QLabel(&quot;name&quot;); QLineEdit* nameEdit = new QLineEdit; //创建布局 QBoxLayout* hlayout = new QBoxLayout(QBoxLayout::Direction::LeftToRight); //把小部件添加到布局 hlayout-&gt;addWidget(nameLabel); hlayout-&gt;addWidget(nameEdit); //给当前窗口设置布局 this-&gt;setLayout(hlayout); 布局嵌套 //姓名 QLabel* nameLabel = new QLabel(&quot;Name&quot;); QLineEdit* nameEdit = new QLineEdit; QBoxLayout* nameHlayout = new QBoxLayout(QBoxLayout::Direction::LeftToRight); nameHlayout-&gt;addWidget(nameLabel); nameHlayout-&gt;addWidget(nameEdit); //电话 QLabel* phoneLabel = new QLabel(&quot;Phone&quot;); QLineEdit* phoneEdit = new QLineEdit; QBoxLayout* phoneHlayout = new QBoxLayout(QBoxLayout::Direction::LeftToRight); phoneHlayout-&gt;addWidget(phoneLabel); phoneHlayout-&gt;addWidget(phoneEdit); //布局嵌套 QBoxLayout* mainlayout = new QBoxLayout(QBoxLayout::Direction::TopToBottom); mainlayout-&gt;addLayout(nameHlayout); mainlayout-&gt;addLayout(phoneHlayout); this-&gt;setLayout(mainlayout); 基本使用 创建五个按钮，添加到水平布局 QPushButton *btn1 = new QPushButton(&quot;One&quot;); QPushButton *btn2 = new QPushButton(&quot;Two&quot;); QPushButton *btn3 = new QPushButton(&quot;Three&quot;); QPushButton *btn4 = new QPushButton(&quot;Four&quot;); QPushButton *btn5 = new QPushButton(&quot;Five&quot;); QHBoxLayout* hlayout = new QHBoxLayout; hlayout-&gt;addWidget(btn1); hlayout-&gt;addWidget(btn2); hlayout-&gt;addWidget(btn3); hlayout-&gt;addWidget(btn4); hlayout-&gt;addWidget(btn5); this-&gt;setLayout(hlayout); 设置边距 void setMargin(int margin); void setContentsMargins(int left,int top,int right,int bottom); 这里我使用setMargin(0)将外边距设置为0。 设置间距 void setSpacing(int spacing) 添加拉伸空间(QSpacerItem) QHBoxLayout* hlayout = new QHBoxLayout; hlayout-&gt;addStretch(); //添加拉伸空间 hlayout-&gt;addWidget(btn1); ... 在第一个控件之前添加伸缩，这样所有的控件就会居右显示。 在最后一个控件之后添加伸缩，这样所有的控件就会居左显示。 在第一个控件之前，最后一个空间之后添加伸缩，这样所有的控件就会居中显示。 添加控件addWidget void addWidget(QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0) 默认是居中对齐的，我们把其中一个按钮的高度设置大一点，就可以看到非常明显了~ 下面，我们使用向上、向下对齐来设置其它控件。 QHBoxLayout* hlayout = new QHBoxLayout; hlayout-&gt;addStretch(); //添加拉伸空间 hlayout-&gt;addWidget(btn1,0,Qt::AlignmentFlag::AlignTop); hlayout-&gt;addWidget(btn2,0,Qt::AlignmentFlag::AlignTop); hlayout-&gt;addWidget(btn3,0); hlayout-&gt;addWidget(btn4,0,Qt::AlignmentFlag::AlignBottom); hlayout-&gt;addWidget(btn5,0,Qt::AlignmentFlag::AlignBottom); 设置布局方向 void setDirection(QBoxLayout::Direction direction) //可以设置从左到右、从右到左、从上到下、从下到上等。。。 setDirection(QBoxLayout::RightToLeft) setDirection(QBoxLayout::TopToBottom); 既然使用了QHBoxLayout，一般就不建议使用TopToBottom或者BottomToTop，如果实在确定不了方向，或者方向可以随意变化，那么建议使用QBoxLayout。 设置拉伸系数当窗体大小变化时，控件会根据拉伸系数来做相应的调整。 //设置小部件的拉伸因子，如果在布局中发现小部件(不包括子布局)，则返回true; 否则返回false。 bool setStretchFactor(QWidget *widget, int stretch) bool setStretchFactor(QLayout *layout, int stretch) hlayout-&gt;setStretchFactor(btn2,1); hlayout-&gt;setStretchFactor(btn3,2); 设置btn2的拉伸系数为1，btn3拉伸系数为2，当窗体变大时，会优先将btn3进行拉伸，当达到一定程度时，再拉伸btn2，btn2与btn3的宽度比例为1:2。 2，网格布局(GridLayout)网格布局也叫格栅布局(多行多列) QGridLayout占用它可用的空间(通过它的父布局或parentWidget())，将它分成行和列，并将它管理的每个小部件放入正确的单元格中。 列和行表现相同; 我们将讨论列，但行也有等价的函数。 每一列都有一个最小宽度和一个拉伸因子。 最小宽度是使用setColumnMinimumWidth()设置的最大宽度和该列中每个小部件的最小宽度。 拉伸因子使用setColumnStretch()设置，并确定列将获得的可用空间超过或超过必要的最小空间的多少。 公有函数 序号 函数&amp;描述 2 void addLayout(QLayout *layout, int row, int column, Qt::Alignment alignment &#x3D; 0)void addLayout(QLayout *layout, int row, int column, int rowSpan, int columnSpan, Qt::Alignment alignment &#x3D; 0)将layout放置在网格中的位置(row、column)。 左上角的位置是(0,0)。跨越多行&#x2F;多列。 该单元格将从跨rowSpan行和columnSpan列的行、列开始。 3 void addWidget(QWidget *widget, int row, int column, Qt::Alignment alignment &#x3D; 0)void addWidget(QWidget *widget, int fromRow, int fromColumn, int rowSpan, int columnSpan, Qt::Alignment alignment &#x3D; 0)同上 4 void setRowStretch(int row, int stretch)将row的拉伸因子设置为stretch 5 void setColumnStretch(int column, int stretch)将column的拉伸因子设置为stretch 6 voidsetRowMinimumHeight(int row, int minSize)将行的最小宽度设置为minSize像素。 7 voidsetColumnMinimumWidth(int column, int minSize)将列的最小宽度设置为minSize像素。 QLabel* imageLabel = new QLabel; QLineEdit* userNamaeEdit = new QLineEdit; QLineEdit* passwdEdit = new QLineEdit; QCheckBox* rememberCheckBox = new QCheckBox; QCheckBox* autoLoginCheckBox = new QCheckBox; QPushButton* registerBtn = new QPushButton; QPushButton* forgetBtn = new QPushButton; QPushButton* loginBtn = new QPushButton; //设置图片 imageLabel-&gt;setFixedSize(90,90); imageLabel-&gt;setPixmap(QPixmap(&quot;://images/loginIcon.png&quot;)); imageLabel-&gt;setScaledContents(true); //设置输入框 userNamaeEdit-&gt;setPlaceholderText(&quot;QQ号码/手机/邮箱&quot;); passwdEdit-&gt;setPlaceholderText(&quot;密码&quot;); //设置复选框 rememberCheckBox-&gt;setText(&quot;记住密码&quot;); autoLoginCheckBox-&gt;setText(&quot;自动登录&quot;); //设置按钮 registerBtn-&gt;setText(&quot;注册账号&quot;); forgetBtn-&gt;setText(&quot;找回密码&quot;); loginBtn-&gt;setText(&quot;登录&quot;); QGridLayout* layout = new QGridLayout; layout-&gt;addWidget(imageLabel,0,0,3,1); layout-&gt;addWidget(userNamaeEdit,0,1,1,2); layout-&gt;addWidget(registerBtn,0,3); layout-&gt;addWidget(passwdEdit,1,1,1,2); layout-&gt;addWidget(forgetBtn,1,3); layout-&gt;addWidget(rememberCheckBox,2,1); layout-&gt;addWidget(autoLoginCheckBox,2,2); layout-&gt;addWidget(loginBtn,3,1,1,2); layout-&gt;setHorizontalSpacing(10); layout-&gt;setVerticalSpacing(10); layout-&gt;setContentsMargins(20,20,20,20); this-&gt;setLayout(layout); 3，表单布局(FormLayout)QFormLayout类管理输入小部件的表单及其关联的标签 QFormLayout 是一个方便的布局类，它以两列形式布置其子项。 左列由标签组成，右列由“字段”小部件（行编辑器、旋转框等）组成。 传统上，这种两列表单布局是使用 QGridLayout 实现的。 QFormLayout 是一种更高级别的替代方案，具有以下优点： 遵守不同平台的外观和感觉准则例如，macOS Aqua 和 KDE 指南指定标签应该右对齐，而 Windows 和 GNOME 应用程序通常使用左对齐。 支持长行换行 对于显示较小的设备，QFormLayout可以设置为对长行进行换行，甚至对所有行进行换行。 创建标签-字段对，有非常方便的API我们可以通过addRow(const QString &amp;labelText, QWidget *field)来创建一个带有给定文本的QLabel及QWidget控件行，它们可以自动的设置为伙伴关系。 公有函数 序号 函数&amp;描述 1 void addRow(QWidget* label,QWidget* field)void addRow(QWidget* label,QLayout* field)使用给定的label和field在此表单布局的底部添加新行 2 void addRow(const QString &amp;labelText, QWidget* field)void addRow(const QString &amp;labelText, QLayout* field)这个重载会在后台自动创建一个以labelText作为文本的QLabel。 field被设置为新的QLabel的伙伴 3 void addRow(QWidget widget)void addRow(QLayout layout)在表单布局的末尾添加指定的小部件。 这个小部件横跨两列 9 void setRowWrapPolicy(QFormLayout::RowWrapPolicy policy)true 10 void setSpacing(int spacing)将垂直和水平间距设置为spacing。 11 void setVerticalSpacing(int spacing)将垂直间距设置为spacing 12 void setWidget(int row, QFormLayout::ItemRole role, QWidget *widget)将给定的row中的role设置为widget，必要时使用空行扩展布局。 如果单元格已被占用，则不插入小部件，并将错误消息发送到控制台。 QLineEdit* userEdit = new QLineEdit; QLineEdit* passwdEdit = new QLineEdit; QPushButton* loginBtn = new QPushButton(&quot;确定&quot;); QFormLayout* fromLayout = new QFormLayout; fromLayout-&gt;addRow(&quot;userName:&quot;,userEdit); fromLayout-&gt;addRow(&quot;password:&quot;,passwdEdit); fromLayout-&gt;addWidget(loginBtn); this-&gt;setLayout(fromLayout); 将其与下面使用QGridLayout编写的代码进行比较: QLineEdit* userEdit = new QLineEdit; QLineEdit* passwdEdit = new QLineEdit; QPushButton* loginBtn = new QPushButton(&quot;确定&quot;); QLabel*userLabel = new QLabel(&quot;userName:&quot;); QLabel*passwdLabel = new QLabel(&quot;passwdEdit:&quot;); QGridLayout* glayout = new QGridLayout; glayout-&gt;addWidget(userLabel,0,0); glayout-&gt;addWidget(userEdit,0,1); glayout-&gt;addWidget(passwdLabel,1,0); glayout-&gt;addWidget(passwdEdit,1,1); glayout-&gt;addWidget(loginBtn,2,1); this-&gt;setLayout(glayout); 设置换行策略 void setRowWrapPolicy(QFormLayout::RowWrapPolicy policy) 枚举 描述 效果 QFormLayout::DontWrapRows 字段总是放在它们的标签旁边(默认样式) QFormLayout::WrapLongRows 标签有足够的空间适应，如果字段对的最小大小大于可用空间，输入框会被换到下一行 QFormLayout::WrapAllRows 字段总是在它们的标签下面。 设置控件 void setWidget(int row, QFormLayout::ItemRole role, QWidget *widget) 将给定角色的给定行中的小部件设置为widget，必要时使用空行扩展布局。 内容 值 描述 QFormLayout::LabelRole 0 标签 QFormLayout::FieldRole 1 字段 QFormLayout::SpanningRole 2 跨标签和字段列的小部件 QFormLayout * flayout = new QFormLayout; flayout-&gt;setWidget(0,QFormLayout::ItemRole::LabelRole,new QLabel(&quot;LabelRole&quot;)); flayout-&gt;setWidget(0,QFormLayout::ItemRole::FieldRole,new QLineEdit(&quot;FieldRole&quot;)); flayout-&gt;setWidget(1,QFormLayout::ItemRole::SpanningRole,new QPushButton(&quot;SpanningRole&quot;)); this-&gt;setLayout(flayout); 4，堆栈布局(StackedLayout)QStackedLayout继承自QLayout。 QStackedLayout类提供了多页面切换的布局，一次只能看到一个界面。 QStackedLayout可用于创建类似于QTabWidget提供的用户界面。也有建立在QStackedLayout之上的便利类QStackedWidget sngnals //每当布局中的当前小部件发生变化时，都会发出此信号。 index指定新的当前小部件的索引，如果没有新的小部件，则-1 void currentChanged(int index) //每当从布局中删除小部件时，都会发出此信号，inded是删除的索引。 void widgetRemoved(int index) slots void setCurrentIndex(int index) void setCurrentWidget(QWidget *widget) 公有函数 序号 函数&amp;描述 2 int addWidget(QWidget *widget)把widget添加到布局中 5 int insertWidget(int index, QWidget *widget)把widget插入到指定的下标 6 void setStackingMode(QStackedLayout::StackingMode stackingMode)设置子小部件可见性的处理方式。 5，分割器(Splitter)QSplitter类实现了一个分离小部件。 splitter允许用户通过拖动子部件之间的边界来控制它们的大小。 任何数量的小部件都可以由单个拆分器控制。QSplitter的典型用法是创建几个小部件并使用 insertWidget()或addWidget()添加它们。 QSplitter *splitter = new QSplitter(this); splitter-&gt;addWidget(new QTextBrowser); splitter-&gt;addWidget(new QTextBrowser); splitter-&gt;addWidget(new QTextBrowser); splitter-&gt;setHandleWidth(2); splitter-&gt;setCollapsible(0,false); QSplitter *sp = new QSplitter(Qt::Orientation::Vertical,splitter); sp-&gt;addWidget(new QTextBrowser); sp-&gt;addWidget(new QTextBrowser);","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"QT(对话框)","slug":"QT(对话框)","date":"2022-09-25T23:06:17.000Z","updated":"2022-09-30T07:50:22.933Z","comments":true,"path":"2022/09/26/QT(对话框)/","link":"","permalink":"http://goskp.github.io/2022/09/26/QT(%E5%AF%B9%E8%AF%9D%E6%A1%86)/","excerpt":"","text":"QDialogQt中使用QDialog来实现对话框，QDialog继承自QWidget，对话框分为两种，一种是模态对话框、 另一种是非模态对话框。即阻塞和非阻塞对话框，而模态对话框又有两种：应用程序级别的和窗口级别的，分别指完成对话框之前阻塞整个应用和阻塞关联窗口。exec() 和 open() 分别为应用程序级别和窗口级别的模态对话框，show（）则为非模态对话框。 模态对话框：在弹出模态对话框时，除了该对话框整个应用程序窗口都无法接受用户响应，处于等待状态，直到模态对话框被关闭 半模态对话框：又叫做无模式对话框，即弹出非模态对话框时，用户仍然可以对其他窗口进行操作，不会因为这个对话框未关闭就不能操作其他窗口。 非模态对话框：半模态对话框区别于模态与非模态对话框，或者说是介于两者之间，也就是说半模态对话框会阻塞窗口的响应，但是不会影响后续代码的执行。 // 构造函数 QDialog::QDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); void setSizeGripEnabled(bool) //设置启用大小手柄 [virtual slot] void open() // 半模态显示窗口 [virtual slot] int QDialog::exec(); // 模态显示窗口 // 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted [virtual slot] void QDialog::accept(); // 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected [virtual slot] void QDialog::reject(); // 关闭对话框并将其结果代码设置为r。finished()信号将发出r;如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。 [virtual slot] void QDialog::done(int r); signals void QDialog::accepted(); void QDialog::rejected(); void QDialog::finished(int result); 示例 dialog-&gt;show(); dialog-&gt;exec(); dialog-&gt;open(); qDebug()&lt;&lt;&quot;大老虎，嗷嗷嗷~&quot;; connect(dialog,&amp;QDialog::finished,this,[](int res)&#123;qDebug()&lt;&lt;QDialog::DialogCode(res);&#125;); connect(dialog,&amp;QDialog::rejected,this,[]()&#123;qDebug()&lt;&lt;&quot;rejected&quot;;&#125;); connect(dialog,&amp;QDialog::accepted,this,[]()&#123;qDebug()&lt;&lt;&quot;accept&quot;;&#125;); QDialogButtonBoxQDialogButtongBox类是一个包含很多按钮的控件，在对话框中有多个按钮需要分组排列的按钮时，可以使用QDialogButtongBox类。 添加按钮 void addButton(QAbstractButton *button, QDialogButtonBox::ButtonRole role) QPushButton *addButton(const QString &amp;text, QDialogButtonBox::ButtonRole role) QPushButton *addButton(QDialogButtonBox::StandardButton button) void setStandardButtons(QDialogButtonBox::StandardButtons buttons) 示例： auto *yesBtn = dialogBtnBox-&gt;addButton(QDialogButtonBox::StandardButton::Yes); yesBtn-&gt;setText(&quot;确定&quot;); dialogBtnBox-&gt;addButton(QDialogButtonBox::StandardButton::Close)-&gt;setText(&quot;关闭&quot;); dialogBtnBox-&gt;addButton(&quot;查看帮助&quot;,QDialogButtonBox::ButtonRole::HelpRole); sngnals void accepted() //当单击按钮框中的按钮时将发出此信号，只要该按钮是用AcceptRole或YesRole定义的。 void clicked(QAbstractButton *button) //当单击按钮框中的按钮时，将发出此信号,具体按钮由button指定 void helpRequested() //当按钮框中的按钮被单击时，这个信号就会发出，只要它是用HelpRole定义的。 void rejected() //当单击按钮框中的按钮时，此信号将被触发，只要它是用RejectRole或NoRole定义的 示例： //dialog 为按钮组所在的对话框 connect(dialogBtnBox,&amp;QDialogButtonBox::accepted,this,[=]()&#123;qDebug()&lt;&lt;&quot;btnaccepted&quot;; dialog-&gt;accept();&#125;); connect(dialogBtnBox,&amp;QDialogButtonBox::clicked,this,[=]()&#123;qDebug()&lt;&lt;&quot;clicked&quot;;&#125;); connect(dialogBtnBox,&amp;QDialogButtonBox::rejected,this,[=]()&#123;qDebug()&lt;&lt;&quot;rejected&quot;; dialog-&gt;reject();&#125;); connect(dialogBtnBox,&amp;QDialogButtonBox::helpRequested,this,[=]()&#123;qDebug()&lt;&lt;&quot;helpRequested&quot;;&#125;); 2.1 QMessageBox QMessageBox 对话框类是 QDialog 类的子类, 通过这个类可以显示一些简单的提示框, 用于展示警告、错误、问题等信息。关于这个类我们只需要掌握一些静态方法的使用就可以了。 // 显示一个模态对话框, 将参数 text 的信息展示到窗口中 [static] void QMessageBox::about(QWidget *parent, const QString &amp;title, const QString &amp;text); /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口的标题 - text: 对话框窗口中显示的提示信息 - buttons: 对话框窗口中显示的按钮(一个或多个) - defaultButton 1. defaultButton指定按下Enter键时使用的按钮。 2. defaultButton必须引用在参数 buttons 中给定的按钮。 3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。 */ //显示带有标题标题和文本文本的简单关于框。 void about(QWidget *parent, const QString &amp;title, const QString &amp;text) void aboutQt(QWidget *parent, const QString &amp;title = QString()) // 显示一个信息模态对话框 [static] QMessageBox::StandardButton QMessageBox::information(QWidget *parent, const QString &amp;title, const QString &amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); // 显示一个错误模态对话框 [static] QMessageBox::StandardButton QMessageBox::critical(QWidget *parent, const QString &amp;title, const QString &amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); // 显示一个问题模态对话框 [static] QMessageBox::StandardButton QMessageBox::question(QWidget *parent, const QString &amp;title, const QString &amp;text, QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), QMessageBox::StandardButton defaultButton = NoButton); // 显示一个警告模态对话框 [static] QMessageBox::StandardButton QMessageBox::warning(QWidget *parent, const QString &amp;title, const QString &amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); ​ 示例 QMessageBox::about(this,&quot;关于Maye&quot;,&quot;我叫&lt;font style=\\&quot;color:red\\&quot;&gt;严炯强&lt;/font&gt;，今年十岁了。是一个内向而又聪明的女孩。\\ &lt;br&gt;我的爱好有:运动、画画、看书、做游戏、科学课和语文课。\\ &lt;br&gt;去年，我一共得了两张奖状。一张是运动小健将的奖状，另一张是百里路小学冬锻跳绳比赛二年级段女子组第一名的奖状。我明白:只要努力，必须会有收获的。\\ &lt;br&gt;每次我考到一百分的时候，爸爸妈妈就会奖励我，我也十分高兴。有一次我考了一百分，妈妈买了一个有轮子的书包给我。我考了一百分，爸爸总会带我去吃肯德基。\\ &lt;br&gt;所以，在新学期里，我要更加努力，再创佳绩!\\ &lt;br&gt;&lt;a href=\\&quot;www.bilibili.com\\&quot;&gt;我的个人主页&lt;/a&gt;&quot;); 2.2 QFileDialog QFileDialog 对话框类是 QDialog 类的子类, 通过这个类可以选择要打开&#x2F;保存的文件或者目录。关于这个类我们只需要掌握一些静态方法的使用就可以了。 /* 通用参数: - parent: 当前对话框窗口的父对象也就是父窗口 - caption: 当前对话框窗口的标题 - dir: 当前对话框窗口打开的默认目录 - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可 - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔 - 样式举例: - Images (*.png *.jpg) - Images (*.png *.jpg);;Text files (*.txt) - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器 */ // 打开一个目录, 得到这个目录的绝对路径 [static] QString QFileDialog::getExistingDirectory(QWidget *parent = nullptr, const QString &amp;caption = QString(), const QString &amp;dir = QString(), QFileDialog::Options options = ShowDirsOnly); // 打开一个文件, 得到这个文件的绝对路径 [static] QString QFileDialog::getOpenFileName(QWidget *parent = nullptr, const QString &amp;caption = QString(), const QString &amp;dir = QString(), const QString &amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); // 打开多个文件, 得到这多个文件的绝对路径 [static] QStringList QFileDialog::getOpenFileNames(QWidget *parent = nullptr, const QString &amp;caption = QString(), const QString &amp;dir = QString(), const QString &amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); // 打开一个目录, 使用这个目录来保存指定的文件 [static] QString QFileDialog::getSaveFileName(QWidget *parent = nullptr, const QString &amp;caption = QString(), const QString &amp;dir = QString(), const QString &amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); 2.3 QFontDialog QFont 字体类 QFont::QFont(); /* 参数: - family: 本地字库中的字体名, 通过 office 等文件软件可以查看 - pointSize: 字体的字号 - weight: 字体的粗细, 有效范围为 0 ~ 99 - italic: 字体是否倾斜显示, 默认不倾斜 */ QFont::QFont(const QString &amp;family, int pointSize = -1, int weight = -1, bool italic = false); // 设置字体 void QFont::setFamily(const QString &amp;family); // 根据字号设置字体大小 void QFont::setPointSize(int pointSize); // 根据像素设置字体大小 void QFont::setPixelSize(int pixelSize); // 设置字体的粗细程度, 有效范围: 0 ~ 99 void QFont::setWeight(int weight); // 设置字体是否加粗显示 void QFont::setBold(bool enable); // 设置字体是否要倾斜显示 void QFont::setItalic(bool enable); // 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名) QString QFont::family() const; bool QFont::italic() const; int QFont::pixelSize() const; int QFont::pointSize() const; bool QFont::bold() const; int QFont::weight() const; QFontDialog类的静态API [static] QFont QFontDialog::getFont(bool *ok, const QFont &amp;initial, QWidget *parent = nullptr, const QString &amp;title = QString(), QFontDialog::FontDialogOptions options = FontDialogOptions()); [static] QFont QFontDialog::getFont(bool *ok, QWidget *parent = nullptr); 窗口字体的设置 // QWidget 类 // 得到当前窗口使用的字体 const QWidget::QFont&amp; font() const; // 给当前窗口设置字体, 只对当前窗口类生效 void QWidget::setFont(const QFont &amp;); // QApplication 类 // 得到当前应用程序对象使用的字体 [static] QFont QApplication::font(); // 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口 [static] void QApplication::setFont(const QFont &amp;font, const char *className = nullptr); 2.4 QColorDialog 颜色类 QColor // 构造函数 QColor::QColor(Qt::GlobalColor color); QColor::QColor(int r, int g, int b, int a = ...); QColor::QColor(); // 参数 red, green, blue, alpha 取值范围是 0-255 void QColor::setRed(int red); void QColor::setGreen(int green); void QColor::setBlue(int blue); void QColor::setAlpha(int alpha); void QColor::setRgb(int r, int g, int b, int a = 255); int QColor::red() const; int QColor::green() const; int QColor::blue() const; int QColor::alpha() const; void QColor::getRgb(int *r, int *g, int *b, int *a = nullptr) const; QFontDialog类的静态API // 弹出颜色选择对话框, 并返回选中的颜色信息 [static] QColor QColorDialog::getColor(const QColor &amp;initial = Qt::white, QWidget *parent = nullptr, const QString &amp;title = QString(), QColorDialog::ColorDialogOptions options = ColorDialogOptions()); 2.5 QInputDialog[static] double QInputDialog::getDouble(QWidget *parent, const QString &amp;title, const QString &amp;label, double value = 0, double min = -2147483647, double max = 2147483647, int decimals = 1, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags()); [static] int QInputDialog::getInt(QWidget *parent, const QString &amp;title, const QString &amp;label, int value = 0, int min = -2147483647, int max = 2147483647, int step = 1, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags()); [static] QString QInputDialog::getItem(QWidget *parent, const QString &amp;title, const QString &amp;label, const QStringList &amp;items, int current = 0, bool editable = true, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone) [static] QString QInputDialog::getMultiLineText(QWidget *parent, const QString &amp;title, const QString &amp;label, const QString &amp;text = QString(), bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone); [static] QString QInputDialog::getText(QWidget *parent, const QString &amp;title, const QString &amp;label, QLineEdit::EchoMode mode = QLineEdit::Normal, const QString &amp;text = QString(), bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone); 2.6 QProgressDialog// 构造函数 /* 参数: - labelText: 对话框中显示的提示信息 - cancelButtonText: 取消按钮上显示的文本信息 - minimum: 进度条最小值 - maximum: 进度条最大值 - parent: 当前窗口的父对象 - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置 */ QProgressDialog::QProgressDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); QProgressDialog::QProgressDialog(const QString &amp;labelText, const QString &amp;cancelButtonText, int minimum, int maximum, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); // 设置取消按钮显示的文本信息 [slot] void QProgressDialog::setCancelButtonText(const QString &amp;cancelButtonText); // 公共成员函数和槽函数 QString QProgressDialog::labelText() const; void QProgressDialog::setLabelText(const QString &amp;text); // 得到进度条最小值 int QProgressDialog::minimum() const; // 设置进度条最小值 void QProgressDialog::setMinimum(int minimum); // 得到进度条最大值 int QProgressDialog::maximum() const; // 设置进度条最大值 void QProgressDialog::setMaximum(int maximum); // 设置进度条范围(最大和最小值) [slot] void QProgressDialog::setRange(int minimum, int maximum); // 得到进度条当前的值 int QProgressDialog::value() const; // 设置进度条当前的值 void QProgressDialog::setValue(int progress); bool QProgressDialog::autoReset() const; // 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。 void QProgressDialog::setAutoReset(bool reset); bool QProgressDialog::autoClose() const; // 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。 void QProgressDialog::setAutoClose(bool close); // 判断用户是否按下了取消键, 按下了返回true, 否则返回false bool wasCanceled() const; // 重置进度条 // 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。 [slot] void QProgressDialog::cancel(); // 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。 [slot] void QProgressDialog::reset(); // 信号 // 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。 [signal] void QProgressDialog::canceled(); // 设置窗口的显示状态(模态, 非模态) /* 参数: Qt::NonModal -&gt; 非模态 Qt::WindowModal -&gt; 模态, 阻塞父窗口 Qt::ApplicationModal -&gt; 模态, 阻塞应用程序中的所有窗口 */ void QWidget::setWindowModality(Qt::WindowModality windowModality);","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"QT(控件)","slug":"QT(控件)","date":"2022-09-23T08:07:57.000Z","updated":"2022-09-23T08:36:05.898Z","comments":true,"path":"2022/09/23/QT(控件)/","link":"","permalink":"http://goskp.github.io/2022/09/23/QT(%E6%8E%A7%E4%BB%B6)/","excerpt":"","text":"Qt最常用控件按钮抽象基类(QAbstractButton)简介QAbstractButton类是按钮部件的抽象基类，提供了按钮所共有的功能。 QAbstractButton类实现了一个抽象按钮，并且让它的子类来指定如何处理用户的动作，并指定如何绘制按钮。 QAbstractButton提供了点击和勾选按钮。QRadioButton和QCheckBox类只提供了勾选按钮，QPushButton和QToolButton提供了点击按钮，如果需要的话，它们还可以提供切换行为。 任何按钮，都可以显示一个包含文本和图标的标签。 setText(const QString&amp;) 设置文本 setIcon(const QIcon&amp;) 设置图标 信号与槽signals clicked，pressed，released信号 QPushButton*btn = new QPushButton(&quot;Touch Me&quot;,this); btn-&gt;move(100,100); //按钮按下释放之后会触发 connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;clicked&quot;;&#125;); //按钮按下触发 connect(btn,&amp;QPushButton::pressed,this,[]()&#123;qDebug()&lt;&lt;&quot;pressed&quot;;&#125;); //按钮释放触发 connect(btn,&amp;QPushButton::released,this,[]()&#123;qDebug()&lt;&lt;&quot;released&quot;;&#125;); toggled信号：每当切换按钮(toggleButton)改变其状态时，就会发出此信号。 btn-&gt;setCheckable(true); //设置按钮可选中 connect(btn,&amp;QPushButton::toggled,this,[=]() &#123; qDebug()&lt;&lt;&quot;toggled&quot;&lt;&lt;btn-&gt;isChecked(); &#125;); slots void animateClick(int msec &#x3D; 100) 定时自动点击按钮 void click() 自动点击按钮 void setIconSize(const QSize &amp;size) 设置图标大小，较小的图标可能会设置无效 void setChecked(bool) 设置是否选中按钮(checkable必须被启用) void toggle() 切换按钮的选中状态 其他函数 序号 函数&amp;描述 1 int void setAutoExclusive(bool)可选中按钮是否独占， 在独占按钮组(同一父对象为同一组)中，任何时候只能选中一个按钮 2 void setAutoRepeat(bool)如果启用，按钮按下不松开，pressed()、released()和clicked()信号会定期发出 3 void setAutoRepeatDelay(int)如果启用了autoRepeat，那么autoRepeatDelay将定义自动重复生效前的初始延迟(以毫秒为单位)。 4 void setAutoRepeatInterval(int)如果启用了autoRepeat，则autoRepeatInterval定义了自动重复间隔的长度，以毫秒为单位。 5 void setCheckable(bool)设置按钮是否能够被选中，默认是不能被选中的 6 void setDown(bool)设置按钮是否被按下 7 void setIcon(const QIcon &amp;icon)设置图标 8 void setShortcut(const QKeySequence &amp;key)设置快捷键 9 void setText(const QString &amp;text)设置文本 1，按钮(PushButton)最常用的控件之一，应用场景十分广泛。 信号与槽signals Inherits:QAbstractButton 继承自父类 slots void showMenu() 如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用) 常用函数 序号 函数&amp;描述 1 int void setAutoDefault(bool)设为自动默认按钮，按下Enter键时会自动按下按钮 2 void setDefault(bool)设为自动默认按钮，按下Enter键时会自动按下按钮 3 void setFlat(bool)去掉按钮的边框，让PushButton按钮跟背景色融为一体，在点击按钮时，会出现原来按钮背景。 4 void setMenu(QMenu *menu)设置菜单。 这将把按钮变成一个菜单按钮，在某些样式中，它将在按钮文本的右侧产生一个小三角形。 QMenu* menu = new QMenu(&quot;Menu&quot;); menu-&gt;addAction(&quot;大家好&quot;); menu-&gt;addAction(&quot;kpsun&quot;); btn-&gt;setMenu(menu); connect(menu,&amp;QMenu::triggered,this,[=](QAction*act) &#123; btn-&gt;setText(act-&gt;text()); &#125;); 2，工具按钮(ToolButton)QToolButton是一个特殊的Button, 提供快速访问特定的命令或选项。与普通命令按钮不同, QToolButton通常不显示文本标签, 而是显示图标。一般用在toolBar上 信号与槽signals Inherits:QAbstractButton 继承自父类 void triggered(QAction *action) 按钮绑定的菜单动作被触发 slots void setDefaultAction(QAction *action) 如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用) void setToolButtonStyle(Qt::ToolButtonStyle style) 设置工具按钮是否仅显示图标、仅显示文本，还是图标旁边/下面的文本。 void showMenu() QToolButton*toolbtn = new QToolButton(this); toolbtn-&gt;move(200,100); toolbtn-&gt;setText(&quot;hello&quot;); //设置图标 toolbtn-&gt;setIcon(style()-&gt;standardIcon (QStyle::StandardPixmap::SP_FileIcon)); //设置文字显示位置 toolbtn-&gt;setToolButtonStyle (Qt::ToolButtonStyle::ToolButtonTextUnderIcon); 常用函数 序号 函数&amp;描述 1 int void setArrowType(Qt::ArrowType type)此属性用于保存按钮是否显示箭头而不是普通图标 2 void setAutoRaise(bool enable)&lt;&#x2F;span去掉边框和背景，鼠标在按钮上面时，显示选中效果，按下时有下沉效果 3 void setMenu(QMenu *menu)设置弹出菜单 4 void setPopupMode(QToolButton::ToolbuttonPopupMode mode)描述如何将弹出菜单与工具按钮一起使用，默认设置为DelayedPopup 弹出菜单QMenu*menu = new QMenu; menu-&gt;addAction(&quot;C语言&quot;); menu-&gt;addAction(&quot;C++&quot;); toolbtn-&gt;setMenu(menu); //设置弹出模式，DelayedPopup延时弹出 MenuButtonPopup在右侧显示一个箭头 InstantPopup立即弹出 toolbtn-&gt;setPopupMode(QToolButton::DelayedPopup); //设置按钮菜单之后，右下角有一个小箭头，去掉箭头 toolbtn-&gt;setStyleSheet(&quot;QToolButton::menu-indicator &#123;image: none;&#125;&quot;); 3，单选按钮(RadioButton)QRadioButton部件提供了一个带有文本标签的单选按钮。 QRadioButton是一个可以切换选中（checked）或未选中（unchecked）状态的选项按钮。单选框通常呈现给用户一个“多选一”的选择。也就是说，在一组单选框中，一次只能选中一个单选框。 信号与槽signals Inherits:QAbstractButton 继承自父类 slots Inherits:QAbstractButton 继承自父类 常用函数 序号 函数&amp;描述 1 void setCheckState(Qt::CheckState state) 将复选框的复选状态设置为state。 如果不需要三状态支持，还可以使用QAbstractButton::setChecked()，它接受布尔值。 2 void setTristate(bool)该属性保存复选框是否是三状态复选框，默认为false，即复选框只有两个状态 使用方法 同一组(同一父对象)的单选按钮一次只能选中一个 QRadioButton*radiobtn = new QRadioButton(&quot;男&quot;,this); QRadioButton*radiobtn1 = new QRadioButton(&quot;女&quot;,this); //设置默认选中 radiobtn-&gt;setChecked(true); 同一组同时选中多个 QGroupBox* exampleGroup = new QGroupBox(&quot;esample&quot;,this); QLabel*label = new QLabel(&quot;你喜欢以下哪些宠物？&quot;); exampleGroup-&gt;move(300,300); QRadioButton *dogbtn = new QRadioButton(&quot;狗&quot;); QRadioButton *catbtn = new QRadioButton(&quot;猫&quot;); QRadioButton *snakebtn = new QRadioButton(&quot;蛇&quot;); QRadioButton *pigbtn = new QRadioButton(&quot;猪&quot;); dogbtn-&gt;setAutoExclusive(false); catbtn-&gt;setAutoExclusive(false); snakebtn-&gt;setAutoExclusive(false); pigbtn-&gt;setAutoExclusive(false); QVBoxLayout* layout = new QVBoxLayout; layout-&gt;addWidget(label); layout-&gt;addWidget(dogbtn); layout-&gt;addWidget(catbtn); layout-&gt;addWidget(snakebtn); layout-&gt;addWidget(pigbtn); exampleGroup-&gt;setLayout(layout); 不同组的单选按钮可以同时选中 QGroupBox* sexGroup = new QGroupBox(&quot;性别&quot;,this); QGroupBox* viewpointGroup = new QGroupBox(&quot;观点&quot;,this); sexGroup-&gt;move(200,300); viewpointGroup-&gt;move(300,300); QRadioButton*radiobtn = new QRadioButton(&quot;男&quot;,sexGroup); QRadioButton*radiobtn1 = new QRadioButton(&quot;女&quot;,sexGroup); QRadioButton*radiobtn2 = new QRadioButton(&quot;好&quot;,viewpointGroup); QRadioButton*radiobtn3 = new QRadioButton(&quot;坏&quot;,viewpointGroup); QHBoxLayout* sexLayout = new QHBoxLayout; sexLayout-&gt;addWidget(radiobtn); sexLayout-&gt;addWidget(radiobtn1); QHBoxLayout* viewpointLayout = new QHBoxLayout; viewpointLayout-&gt;addWidget(radiobtn2); viewpointLayout-&gt;addWidget(radiobtn3); sexGroup-&gt;setLayout(sexLayout); viewpointGroup-&gt;setLayout(viewpointLayout); 4，复选框(CheckBox)QCheckBox提供了一个带文本标签的复选框。 QCheckBox（复选框）和QRadioButton（单选框）都是选项按钮。这是因为它们都可以在开（选中）或者关（未选中）之间切换。区别是对用户选择的限制：单选框定义了“多选一”的选择，而复选框提供的是“多选多”的选择。 尽管在技术上可以通过复选框来实现单选框的行为，反之亦然，但还是强烈建议使用众所周知的约定。 信号与槽signals Inherits:QAbstractButton 继承自父类 void stateChanged(int state) 当复选框的状态发生变化时，即当用户选中或取消选中它时，就会发出这个信号。 slots Inherits:QAbstractButton 继承自父类 使用方法QGroupBox* exampleGroup = new QGroupBox(this); exampleGroup-&gt;move(300,300); QLabel*label = new QLabel(&quot;你喜欢以下哪些宠物？&quot;); QCheckBox *dogbtn = new QCheckBox(&quot;狗&quot;); QCheckBox *catbtn = new QCheckBox(&quot;猫&quot;); QCheckBox *snakebtn = new QCheckBox(&quot;蛇&quot;); QCheckBox *pigbtn = new QCheckBox(&quot;猪&quot;); QVBoxLayout* layout = new QVBoxLayout; layout-&gt;addWidget(label); layout-&gt;addWidget(dogbtn); layout-&gt;addWidget(catbtn); layout-&gt;addWidget(snakebtn); layout-&gt;addWidget(pigbtn); exampleGroup-&gt;setLayout(layout); 5，行编辑器(LineEdit)信号与槽signals Inherits:QAbstractButton 继承自父类 void clear() //清除行编辑的内容 void copy() const //将选中的文本复制到剪贴板(如果有的话)，并且echoMode()是Normal void cut() //剪切 void paste() //粘贴 void redo() //撤销 void selectAll() //选中所有 void setText(const QString &amp;) void undo() //反撤销 slots void showMenu() 如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用) //这个信号在光标移动时发出。前一个位置由oldPos给出，新位置由newPos给出 void cursorPositionChanged(int oldPos, int newPos) //编辑完成，按下Return或Enter键或行编辑失去焦点时将发出此信号 void editingFinished() //当用户按下一个不被认为是可接受输入的键时，就会发出这个信号。 例如，如果一个按键导致验证器的validate()调用返回Invalid。 另一种情况是试图输入超过行编辑的最大长度的字符。 void inputRejected() //编不编辑，当按下Return或Enter键时都发出此信号，失去焦点不会发 void returnPressed() //这个信号在选择改变时发出 void selectionChanged() //每当文本发生变化时，就会发出这个信号。与texttedited()不同，调用setText()改变文本，此信号也会发出。 void textChanged(const QString &amp;text) //只要文本被编辑，就会发出这个信号。 void textEdited(const QString &amp;text) 设置显示模式edit-&gt;setEchoMode(QLineEdit::EchoMode::Password); QLineEdit::Normal //显示输入的字符，这是默认值。 QLineEdit::NoEcho //不要显示任何东西 QLineEdit::Password //显示与平台相关的密码掩码字符，而不是实际输入的字符。 QLineEdit::PasswordEchoOnEdit //在编辑时显示已输入的字符，完成显示掩码字符 edit-&gt;setClearButtonEnabled(true); //启用清除按钮 设置输入掩码 掩码字符 含义 A ASCII字母字符是必须的，A-Z，a-z a ASCII 字母字符是允许的但不是必须的 N ASCII字母字符是必须的，A-Z，a-z， 0-9 n ASCII 字母字符是允许的但不是必须的 X 任何字符都可以，是必须需要的 x 任何字符都允许的，但不是必须需要的 9 ASCII 数字是必须要的，0-9 0 ASCII 数字是允许的，但不是必须要的 D ASCII 数字是必须要的，1-9 d ASCII 数字是允许的，但不是必须要的 # ASCII 数字是或加减符号允许的，但不是必须要的 H 十六进制数据字符是必须要的，A-F, a-f, 0-9 h 十六进制数据字符是允许的，但不是必须要的 B 二进制数据字符是必须要的，0-1 b 二进制数据字符是允许的，但不是必须要的 &gt; 所有的字符字母都都大写的 &lt; 所有的字符字幕都是小写的 ! 关闭大小写 ;c 终止输入掩码并将空白字符设置为c \\ 使用 \\ 去转义上面的字符，如果再需要显示上述字符的时候 输入日期 edit-&gt;setText(QDate::currentDate().toString(&quot;yyyy-MM-dd&quot;)); edit-&gt;setInputMask(&quot;9999-99-99&quot;); 输入秘钥 edit-&gt;setInputMask(&quot;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA&quot;); 设置验证器 只能输入整数 edit-&gt;setValidator(new QIntValidator(-90,90,this)); 只能输入浮点数，但是浮点数验证器不能限制范围，可以随便输入 edit-&gt;setValidator(new QDoubleValidator(-90.0,90.0,3,this)); 添加动作void QLineEdit::addAction(QAction *action, QLineEdit::ActionPosition position) QAction *QLineEdit::addAction(const QIcon &amp;icon, QLineEdit::ActionPosition position) QLineEdit *edit = new QLineEdit(this); edit-&gt;addAction(QIcon(&quot;://images/user.png&quot;),QLineEdit::ActionPosition::LeadingPosition); QAction *delAct = edit-&gt;addAction(QIcon(&quot;://images/delete.png&quot;),QLineEdit::ActionPosition::TrailingPosition); connect(delAct,&amp;QAction::triggered,[]() &#123; qDebug()&lt;&lt;&quot;delAct&quot;; &#125;); 6，标签(Label)QLabel小部件提供文本或图像显示 信号与槽signals //当用户点击链接时会发出此信号。 void linkActivated(const QString &amp;link) //当用户将鼠标悬停在链接上时会发出此信号。 void linkHovered(const QString &amp;link) slots void clear() void setMovie(QMovie *movie) void setNum(double num) void setNum(int num) void setPicture(const QPicture &amp;picture) void setPixmap(const QPixmap &amp;) void setText(const QString &amp;) 公有函数 序号 函数&amp;描述 1 void setAlignment(Qt::Alignment)设置对齐方式 2 void setBuddy(QWidget *buddy)将此标签的好友设置为buddy。当用户按下此标签指示的快捷键时，键盘焦点将转移到标签的好友小部件。伙伴机制仅适用于包含文本的 QLabel，其中一个字符以与号“&amp;”为前缀。 3 void setIndent(int)设置label的文本缩进，以像素为单位 4 void setMargin(int)设置边距 5 void setOpenExtrenalLinks(bool open)设置是否自动打开超链接 6 void setScaledContents(bool)设置内容缩放，确定标签是否将其内容缩放以填充所有可用空间。 7 void setSelection(int start,int len)设置对齐方式 8 void setTextFormat(Qt::TextFormat)设置标签文本格式 9 void setTextInteractionFlags(Qt::TextInteractionFlags flag)设置对齐方式 10 void setWordWrap(bool on)设置是否在需要时自动换行 Example: 显示文本 QLabel* label = new QLabel(&quot;我是萌萌哒的小可爱&quot;,this); label-&gt;setAlignment(Qt::AlignmentFlag::AlignCenter); label-&gt;setFixedWidth(100); //设置固定的宽度 label-&gt;setWordWrap(true); //当文本超过固定的宽度之后，自动换行 设置超链接：QLabel支持html文本 label-&gt;setText(&quot;&lt;a href=\\&quot;www.baidu.com\\&quot;&gt;百度一下&lt;/a&gt;&quot;); connect(label,&amp;QLabel::linkHovered,this,[=](const QString&amp; link)&#123;qDebug()&lt;&lt;&quot;linkHovered&quot;&lt;&lt;link;&#125;); connect(label,&amp;QLabel::linkActivated,this,[=](const QString&amp; link)&#123;qDebug()&lt;&lt;&quot;linkActivated&quot;&lt;&lt;link;&#125;); //设置自动打开超链接，而不是发出信号自己处理，这个设置之后会自动在浏览器打开连接 label-&gt;setOpenExternalLinks(true); 设置伙伴 QLabel* nameLabel = new QLabel(&quot;&amp;Name&quot;,this); QLineEdit * nameEdit = new QLineEdit; nameLabel-&gt;setBuddy(nameEdit); QLabel* phoneLabel = new QLabel(&quot;电话(&amp;P)&quot;,this); QLineEdit* phoneEdit = new QLineEdit; phoneLabel-&gt;setBuddy(phoneEdit); QGridLayout* layout = new QGridLayout; layout-&gt;addWidget(nameLabel,0,0); layout-&gt;addWidget(nameEdit,0,1); layout-&gt;addWidget(phoneLabel,1,0); layout-&gt;addWidget(phoneEdit,1,1); setLayout(layout); 显示图片 QLabel* label = new QLabel(this); label-&gt;setPixmap(QPixmap(&quot;://images/label_img.jpg&quot;)); //如上所示，显示的图片是固定的大小，如何让图片按我们想要的大小显示呢？ //1，设置Label的大小，如果有布局，会随着布局动态变化 label-&gt;setFixedSize(340,180); //2，设置内容缩放 label-&gt;setScaledContents(true); 显示Gif动图 QLabel* label = new QLabel(this); QMovie *movie = new QMovie(&quot;F:/MyCode/QtCode/QtCourse/DisplayWidgets/images/label_gif.gif&quot;); label-&gt;setMovie(movie); movie-&gt;start(); 7，分组框(GroupBox)信号与槽signals void clicked(bool checked = false) void toggled(bool on) slots void setChecked(bool checked) 公有函数 序号 函数&amp;描述 1 void setAlignment(Qt::Alignment)设置对齐方式 2 void setCheckAble(bool checkable)该分组框是否可以被选择 3 void setflat(bool flat)分组框通常由顶部有标题的包围框组成。 如果启用此属性，则大多数样式只绘制框架的顶部部分; 否则，将绘制整个框架。 4 void setTitle(const QString&amp; title)设置分组框的标题 QGroupBox* groupBox = new QGroupBox(this); groupBox-&gt;move(100,100); groupBox-&gt;resize(320,320); groupBox-&gt;setTitle(&quot;我是分组框&quot;); //groupBox-&gt;setAlignment(Qt::AlignCenter); //groupBox-&gt;setFlat(true); groupBox-&gt;setCheckable(true); connect(groupBox,&amp;QGroupBox::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;clicked&quot;;&#125;); connect(groupBox,&amp;QGroupBox::toggled,this,[]()&#123;qDebug()&lt;&lt;&quot;toggled&quot;;&#125;); QList&lt;QCheckBox*&gt; checkBoxs; for (int i = 0;i&lt;5;i++) &#123; checkBoxs.push_back(new QCheckBox(QString(&quot;checkBox%1&quot;).arg(i),groupBox)); checkBoxs[i]-&gt;move(10,i*40+20); &#125; groupBox-&gt;setChecked(true);","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"QT(QWidget)","slug":"QT(QWidget)","date":"2022-09-22T11:09:02.000Z","updated":"2022-09-30T07:54:42.163Z","comments":true,"path":"2022/09/22/QT(QWidget)/","link":"","permalink":"http://goskp.github.io/2022/09/22/QT(QWidget)/","excerpt":"","text":"1. QWidget QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject, 也就意味着所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收 // 构造函数 QWidget::QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); // 公共成员函数 // 给当前窗口设置父对象 void QWidget::setParent(QWidget *parent); void QWidget::setParent(QWidget *parent, Qt::WindowFlags f); // 获取当前窗口的父对象, 没有父对象返回 nullptr QWidget *QWidget::parentWidget() const; //------------- 窗口位置 ------------- // 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内 QRect QWidget::frameGeometry() const; // 得到相对于当前窗口父窗口的几何信息, 不包括边框 const QRect&amp; geometry() const; // 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框 void setGeometry(int x, int y, int w, int h); void setGeometry(const QRect &amp;); //此属性保存小部件的内部几何形状，不包括任何窗口框架,等于QRect(0,0, width()， height()) QRect rect(); //获取小控件在父控件中的位置 QPoint pos() const // 移动窗口, 重新设置窗口的位置 void move(int x, int y); void move(const QPoint &amp;); //------------- 窗口尺寸 ------------- // 获取当前窗口的尺寸信息 QSize size() const // 重新设置窗口的尺寸信息 void resize(int w, int h); void resize(const QSize &amp;); // 获取当前窗口的最大尺寸信息 QSize maximumSize() const; // 获取当前窗口的最小尺寸信息 QSize minimumSize() const; // 设置当前窗口固定的尺寸信息 void QWidget::setFixedSize(const QSize &amp;s); void QWidget::setFixedSize(int w, int h); // 设置当前窗口的最大尺寸信息 void setMaximumSize(const QSize &amp;); void setMaximumSize(int maxw, int maxh); // 设置当前窗口的最小尺寸信息 void setMinimumSize(const QSize &amp;); void setMinimumSize(int minw, int minh); // 获取当前窗口的高度 int height() const; // 获取当前窗口的最小高度 int minimumHeight() const; // 获取当前窗口的最大高度 int maximumHeight() const; // 给窗口设置固定的高度 void QWidget::setFixedHeight(int h); // 给窗口设置最大高度 void setMaximumHeight(int maxh); // 给窗口设置最小高度 void setMinimumHeight(int minh); // 获取当前窗口的宽度 int width() const; // 获取当前窗口的最小宽度 int minimumWidth() const; // 获取当前窗口的最大宽度 int maximumWidth() const; // 给窗口设置固定宽度 void QWidget::setFixedWidth(int w); // 给窗口设置最大宽度 void setMaximumWidth(int maxw); // 给窗口设置最小宽度 void setMinimumWidth(int minw); //------------- 窗口图标 ------------- // 得到当前窗口的图标 QIcon windowIcon() const; // 构造图标对象, 参数为图片的路径 QIcon::QIcon(const QString &amp;fileName); // 设置当前窗口的图标 void setWindowIcon(const QIcon &amp;icon); /*--Slots--*/ //------------- 窗口标题 ------------- // 得到当前窗口的标题 QString windowTitle() const; // 设置当前窗口的标题 void setWindowTitle(const QString &amp;); void setWindowModified(bool) // 判断窗口是否可用 bool isEnabled() const; // 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件 void setEnabled(bool); //------------- 窗口显示 ------------- // 关闭当前窗口 [slot] bool QWidget::close(); // 隐藏当前窗口 [slot] void QWidget::hide(); // 显示当前创建以及其子窗口 [slot] void QWidget::show(); //设置窗口是否可见 virtual void setVisible(bool visible) // 全屏显示当前窗口, 只对windows有效 [slot] void QWidget::showFullScreen(); // 窗口最大化显示, 只对windows有效 [slot] void QWidget::showMaximized(); // 窗口最小化显示, 只对windows有效 [slot] void QWidget::showMinimized(); // 将窗口回复为最大化/最小化之前的状态, 只对windows有效 [slot] void QWidget::showNormal(); //------------- 信号 ------------- // QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy); // 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号 [signal] void QWidget::customContextMenuRequested(const QPoint &amp;pos); // 窗口图标发生变化, 发射此信号 [signal] void QWidget::windowIconChanged(const QIcon &amp;icon); // 窗口标题发生变化, 发射此信号 [signal] void QWidget::windowTitleChanged(const QString &amp;title); 设置鼠标样式Qcursor//获取鼠标的全局坐标 [static] QPoint pos() [static] QPoint pos(const QScreen *screen) //将鼠标移动到全局的指定坐标 [static] void setPos(int x, int y) [static] void setPos(QScreen *screen, int x, int y) [static] void setPos(const QPoint &amp;p) [static] void setPos(QScreen *screen, const QPoint &amp;p) //QScreen在多屏幕的时候可用 iconfont图标下载网站 以下代码可以通过点击按钮切换并查看所有鼠标的(内置)形状 QPushButton*btn = new QPushButton(&quot;切换鼠标形状&quot;,this); connect(btn,&amp;QPushButton::clicked,this,[=]() &#123; static int i = 0; this-&gt;setCursor(Qt::CursorShape(i)); qDebug()&lt;&lt;&quot;切换成功&quot;&lt;&lt;Qt::CursorShape(i); i = (i+1)%25; &#125;); &#125; 除了内置形状之外，还可以自定义鼠标形状 QPixmap* cursorPixmaps[2]=&#123;new QPixmap(&quot;://images/cursor_one.png&quot;), new QPixmap(&quot;://images/cursor_two.png&quot;)&#125;; QPushButton*btn = new QPushButton(&quot;切换鼠标样式&quot;,this); connect(btn,&amp;QPushButton::clicked,this,[=]() &#123; static int i = 0; setCursor(QCursor(*cursorPixmaps[i])); i = (i+1)%2; &#125;); setWhatsThis 先创建三个按钮 QPushButton*btn1 = new QPushButton(&quot;open&quot;,this); QPushButton*btn2 = new QPushButton(&quot;new&quot;,this); QPushButton*btn3 = new QPushButton(&quot;look&quot;,this); btn2-&gt;move(100,0); btn3-&gt;move(200,0); btn1-&gt;setToolTip(&quot;打开文件&quot;); btn1-&gt;setWhatsThis(&quot;open a new file&quot;); btn2-&gt;setToolTip(&quot;新建文件&quot;); btn2-&gt;setWhatsThis(&quot;create a new file&quot;); btn3-&gt;setToolTip(&quot;查看&quot;); btn3-&gt;setWhatsThis(&quot;查看其他按钮的详细信息&quot;); connect(btn3,&amp;QPushButton::clicked,this,[=]() &#123; QWhatsThis::enterWhatsThisMode(); &#125;); 运行程序后按Shift + F1会出现当前获得焦点的widget的whatsThis信息 调用QWhatsThis的静态函数enterWhatsThisMode进入whatsThis模式，此时当鼠标移动到设置了whatsThis的widget上光标会出现一个问号，再点击则会出现whatsThis的窗口。 设置窗口图标 修改窗口和任务栏显示的图标 this-&gt;setWindowIcon(QIcon(&quot;://images/snowBall.png&quot;)); 设置应用程序图标 1，创建一个图标格式(ico)的文件，可以将一个普通的图片转成.ico格式的图标文件 图片格式在线转换 2，将转换好的ico文件放到源文件所在目录，即和.pro文件同级目录 3，在.pro项目文件中添加如下代码zay.ico 即图标名 RC_ICONS += zay.ico QWidget槽函数show,hide,setVisible,setHidden,close 小结 0，在Qt中如果一定要自己释放对象，官方推荐使用[slot] void QObject::deleteLater()来释放对象 1，[slot] void setVisible(bool visible) 设置Widget可见或不可见 2，slot] void QWidget::setHidden(bool *hidden*) 1号的马甲 3，[slot] void QWidget::show() 1号的马甲 4，[slot] void QWidget::hide() 1号的马甲 5，[slot] bool QWidget::close() 看情况调用4号或者0号(该部件是否有父部件) virtual void setVisible(bool visible); inline void setHidden(bool hidden) &#123; setVisible(!hidden); &#125; inline void show() &#123; setVisible(true); &#125; inline void hide() &#123; setVisible(false); &#125; 不可见，是Widget不在界面上显示，但不代表对象被析构！ //[1]创建关闭自己的按钮 QPushButton* closeBtn = new QPushButton(&quot;closeSelf&quot;,this); connect(closeBtn,&amp;QPushButton::clicked,this,&amp;Widget::close); //点击右上角关闭按钮会销毁窗口 connect(this,&amp;QObject::destroyed,this,[]()&#123;qDebug()&lt;&lt;&quot;this destroyed&quot;;&#125;); //[2]创建子窗口 QWidget* subWidget = new QWidget; subWidget-&gt;setWindowTitle(&quot;subWidget&quot;); subWidget-&gt;show(); //subWidget-&gt;setAttribute(Qt::WidgetAttribute::WA_DeleteOnClose); //点击关闭按钮时销毁窗口 connect(subWidget,&amp;QWidget::destroyed,this,[=]()&#123;qDebug()&lt;&lt;&quot;subWidget destroyed&quot;;&#125;); //[3]创建关闭子窗口的按钮 QPushButton*closeSubWidgetBtn = new QPushButton(&quot;closeSubWidget&quot;,this); closeSubWidgetBtn-&gt;move(100,0); connect(closeSubWidgetBtn,&amp;QPushButton::clicked,subWidget,[=]()&#123; subWidget-&gt;close(); subWidget-&gt;deleteLater(); //推荐这样销毁对象 qDebug()&lt;&lt;subWidget; &#125;); //[4]创建显示子窗口的按钮 QPushButton*showSubWidgetBtn = new QPushButton(&quot;showSubWidget&quot;,this); showSubWidgetBtn-&gt;move(200,0); connect(showSubWidgetBtn,&amp;QPushButton::clicked,subWidget,&amp;QWidget::show); 坐标转换QPoint mapFrom(const QWidget *parent, const QPoint &amp;pos) const QPoint mapFromGlobal(const QPoint &amp;pos) const QPoint mapFromParent(const QPoint &amp;pos) const QPoint mapTo(const QWidget *parent, const QPoint &amp;pos) const QPoint mapToGlobal(const QPoint &amp;pos) const QPoint mapToParent(const QPoint &amp;pos) const 这几个函数都是转换相对坐标系用的. 用另一个坐标系统的坐标值, 来表达当前坐标系统中某个坐标所指向的某个点, 记住: 一定要先确两个坐标系统再确定一个点 相对坐标：获取自己相对于父控件的位置 QWidget::pos() 绝对坐标：将当前控件的相对位置转换为屏幕绝对位置 QWidget::mapToGlobal() 绝对坐标转为相对坐标：将绝对位置对应到控件的相对位置 QWidget::mapFromGlobal() 设置窗口标志 用Qt写一个窗口，如果继承QDialog，那窗口就只有关闭按钮，如果继承QWidget，那么就有关闭，最大化，最小化三个按钮 //仅仅显示关闭按钮，添加一个帮助按钮? this-&gt;setWindowFlags(Qt::WindowType::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint); //从窗口标志中移除帮助按钮标志 this-&gt;setWindowFlags(windowFlags() &amp; ~Qt::WindowContextHelpButtonHint); //移除标志或单纯添加一个标志，可以用一下简单的函数 true为设置，false为移除 this-&gt;setWindowFlag(Qt::WindowContextHelpButtonHint,false); 设置窗口状态 将窗口状态设置为windowState。 窗口状态是附录二中状态的组合。 如果窗口不可见(即isVisible()返回false)，窗口状态将在调用show()时生效。 对于可见窗口，更改是立即的。 例如，要在全屏模式和普通模式之间切换，请使用以下代码: w-&gt;setWindowState(w-&gt;windowState() ^ Qt::WindowFullScreen); 为了恢复和激活最小化的窗口(同时保持其最大化和&#x2F;或全屏状态)，使用以下方法: w-&gt;setWindowState((w-&gt;windowState() &amp; ~Qt::WindowMinimized) | Qt::WindowActive); 调用这个函数将隐藏小部件。 必须调用show()使小部件再次可见，在某些窗口系统中，Qt::WindowActive不是立即的，在某些情况下可能会被忽略。 设置属性 setAttribute用来设置小部件的属性，testAttribute查看是否设置了某种属性。 常用属性 枚举 值(十进制) 描述 Qt::WA_AcceptDrops 78 允许来自拖放操作的数据被拖放到小部件上(参见QWidget::setAcceptDrops()) Qt::WA_AlwaysShowToolTips 84 为非活动窗口启用工具提示 Qt::WA_CustomWhatsThis 47 表示小部件希望在“这是什么?”模式下继续正常运行。 这是由小部件的作者设置的。 Qt::WA_DeleteOnClose 55 使Qt在小部件接受关闭事件时删除该小部件 Qt::WA_MouseTracking 2 指示小部件启用了鼠标跟踪。 参见QWidget:: mouseTracking Qt::WA_TranslucentBackground 120 指示小部件应该有一个半透明的背景，也就是说，小部件的任何非透明区域都将是半透明的，因为小部件将有一个alpha通道。 设置此标志将导致设置WA_NoSystemBackground。 在Windows上，小部件还需要设置Qt:: framesswindowhint窗口标志。 该标志由小部件的作者设置或清除。 发布程序Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll，如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe(这个文件在Qt安装目录的bin文件下可以找到) 不同的编译器和版本需要使用不同的windeployqt版本打包 以官方 Qt 5.14.2+MinGW32 开发环境为例： 1，通过Qt命令行运行windeployqt工具，开始菜单-&gt;Qt 5.14.2-&gt;5.4-&gt;MinGW 4.9 (32-bit)-&gt;Qt 5.14.2 (MinGW 7.3.0 32-bit) 把需要打包的Qt可执行程序拷贝到一个单独的文件夹里面，然后再把命令行工作目录切换到该文件夹 最后执行命令windeployqt maye.exe 2. 资源文件 .qrc 需要我们给窗口设置图标 // 创建图标对象 QIcon::QIcon(const QString &amp;fileName) // QWidget类的 公共成员函数 void setWindowIcon(const QIcon &amp;icon) // 给窗口设置图标 // 弊端: 发布的exe 必须要加载 d:\\\\pic\\\\1.ico 如果对应的目录中么有图片, 图标就无法被加载 // 发布exe 需要额外发布图片, 将其部署到某个目录中 setWindowIcon(QIcon(&quot;d:\\\\pic\\\\1.ico&quot;)); 此枚举类型用于为小部件指定各种窗口系统属性。 它们相当不寻常，但在少数情况下是必要的。 其中一些标志取决于底层窗口管理器是否支持它们。 枚举 值(十六进制) 描述 Qt::Widget 0x00000000 这是QWidget的默认类型。 这种类型的小部件如果有父部件，则为子部件，如果没有父部件，则为独立窗口。 Qt::Window 0x00000001 指示小部件是一个窗口，通常带有窗口系统框架和标题栏，而不管小部件是否有父窗口。 Qt::Dialog 0x00000002| Window 指示小部件是一个窗口，应该装饰为一个对话框(即，通常在标题栏中没有最大化或最小化按钮)。 Qt::Sheet 0x00000004| Window 指示窗口是macOS上的工作表。 由于使用工作表意味着窗口模式，推荐的方法是使用QWidget::setWindowModality()，或QDialog::open() Qt::Drawer Sheet | Dialog 指示小部件是macOS上的一个抽屉 Qt::Popup 0x00000008| Window 指示小部件是弹出式顶级窗口，即它是模态窗口，但具有适合于弹出式菜单的窗口系统框架。 Qt::Tool Popup | Dialog 指示小部件是工具窗口。 工具窗口通常是一个小窗口，比通常的标题栏和装饰更小，通常用于工具按钮集合 Qt::ToolTip Popup | Sheet 指示小部件是一个工具提示。 这在内部用于实现工具提示 Qt::SplashScreen ToolTip | Dialog 表示该窗口为启动画面。 这是QSplashScreen的默认类型 Qt::Desktop 0x00000010| Window 指示此小部件是桌面。 这是QDesktopWidget(此类已经过时)的类型 Qt::SubWindow 0x00000012 指示此小部件是子窗口，例如QMdiSubWindow小部件 Qt::ForeignWindow 0x00000020| Window 表示此窗口对象是一个句柄，表示由另一个进程或手动使用本机代码创建的本机平台窗口。 Qt::CoverWindow 0x00000040| Window 指示该窗口表示覆盖窗口，该窗口在某些平台上最小化应用程序时显示。 窗口提示可以有多个(不一定会生效，看平台是否支持) 枚举 值(十六进制) 描述 Qt::FramelessWindowHint 0x00000800 产生一个无边框的窗口。 用户不能通过窗口系统移动或调整无边框窗口的大小 Qt::NoDropShadowWindowHint 0x40000000 去掉窗口阴影 Qt::CustomizeWindowHint 0x02000000 关闭默认的窗口标题提示 Qt::WindowTitleHint 0x00001000 给窗口一个标题栏 Qt::WindowSystemMenuHint 0x00002000 添加一个窗口系统菜单，可能还有一个关闭按钮(例如在Mac上)。 如果你需要隐藏或显示关闭按钮，使用WindowCloseButtonHint更便于移植。 Qt::WindowMinimizeButtonHint 0x00004000 添加一个最小化按钮 Qt::WindowMaximizeButtonHint 0x00008000 添加一个最大化按钮 Qt::WindowMinMaxButtonsHint WindowMinimizeButtonHint |WindowMaximizeButtonHint 添加最小化和最大化按钮 Qt::WindowCloseButtonHint 0x08000000 添加一个关闭按钮 Qt::WindowContextHelpButtonHint 0x00010000 向对话框添加上下文帮助按钮 Qt::WindowStaysOnTopHint 0x00040000 通知窗口系统该窗口应该位于所有其他窗口的顶部 Qt::WindowStaysOnBottomHint 0x04000000 通知窗口系统该窗口应位于所有其他窗口的底部 附录二 窗口状态 Qt::WindowState 枚举 值 描述 Qt::WindowNoState 0x00000000 窗口没有状态设置(正常状态) Qt::WindowMinimized 0x00000001 窗口被最小化(即图标化) Qt::WindowMaximized 0x00000002 窗户周围有一个框架，使其最大化 Qt::WindowFullScreen 0x00000004 窗口填充了整个屏幕，周围没有任何边框 Qt::WindowActive 0x00000008 该窗口是活动窗口，即它有键盘焦点","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"QT(信号和槽)","slug":"QT(信号和槽)","date":"2022-09-06T04:08:32.000Z","updated":"2022-09-30T07:50:36.531Z","comments":true,"path":"2022/09/06/QT(信号和槽)/","link":"","permalink":"http://goskp.github.io/2022/09/06/QT(%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD)/","excerpt":"","text":"1. 信号和槽概述 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式(发布-订阅模式)。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。 1.1 信号的本质信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。 因此根据上述的描述我们得到一个结论：信号的本质就是事件，比如： 按钮单击、双击 窗口刷新 鼠标移动、鼠标按下、鼠标释放 键盘输入 那么在Qt中信号是通过什么形式呈现给使用者的呢？ 我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。 对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号。 信号的呈现形式就是函数， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。 在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。 1.2 槽的本质槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private或 protected），可以具有任何参数，可以被重载，也可以被直接调用(但是不能有默认参数)。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。 举个简单的例子： 女朋友说：“我肚子饿了！”，于是我带她去吃饭。 上边例子中相当于女朋友发出了一个信号， 我收到了信号并其将其处理掉了。 女朋友 -&gt; 发送信号的对象, 信号内容: 我饿了 我 -&gt; 接收信号的对象并且处理掉了这个信号, 处理动作: 带她去吃饭 在Qt中槽函数的所有者也是某个类的实例对象。 写信：发件人 信的内容 收件人 收到信做事情 1.3 信号和槽的关系在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起，好比牛郎和织女想要相会必须要有喜鹊为他们搭桥一样。 信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是： [static] QMetaObject::Connection QObject::connect( const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection); 参数: sender: 发出信号的对象 signal: sender对象的信号，信号是一个函数 receiver: 信号接收者 method: receiver对象的槽函数, 当检测到sender发出了signal信号, receiver对象调用method方法 connect函数相对于做了信号处理动作的注册,调用conenct连接信号与槽时，sender对象的信号并没有产生, 因此receiver对象的method也不会被调用,method槽函数本质是一个回调函数, 调用的时机是信号产生之后。 调用槽函数是Qt框架来执行的,connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功。 2. 标准信号槽使用2.1 标准信号&#x2F;槽在Qt提供的很多类中都可以对用户触发的某些特定事件进行检测, 当事件被触发后就会产生对应的信号, 这些信号都是Qt类内部自带的, 因此称之为标准信号。 同样的，在Qt的很多类内部为我了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。 系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该看当前类从父类继承下来了哪些信号，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个 2.2 使用 功能实现： 点击窗口上的按钮, 关闭窗口 按钮: 信号发出者 -&gt; QPushButton 窗口: 信号的接收者和处理者 -&gt; QWidget // 单击按钮发出的信号 [signal] void QAbstractButton::clicked(bool checked = false) // 关闭窗口的槽函数 [slot] bool QWidget::close(); // 单击按钮关闭窗口 connect(ui-&gt;closewindow, &amp;QPushButton::clicked, this, &amp;MainWindow::close); 3. 自定义信号槽使用 Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。 如果想要使用自定义的信号和槽, 首先要编写新的类并且让其继承Qt的某些标准类,我们自己编写的类想要在Qt中使用使用信号槽机制, 那么必须要满足的如下条件: 这个类必须从QObject类或者是其子类进行派生 在定义类的第一行头文件中加入 Q_OBJECT 宏 // 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏： class MyMainWindow : public QWidget &#123; Q_OBJECT public: ...... &#125; 3.1 自定义信号 信号是类的成员函数 返回值是 void 类型 参数可以随意指定, 信号也支持重载 信号需要使用 signals 关键字进行声明, 使用方法类似于public等关键字 信号函数只需要声明, 不需要定义(没有函数体实现) 在程序中发送自定义信号: 发送信号的本质就是调用信号函数 emit mysignals(); //发送信号 emit是一个空宏，没有特殊含义，仅用来表示这个语句是发射一个信号，不写当然可以，但是不推荐。 // 举例: 信号重载 // Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以) class MyButton : public QPushButton &#123; Q_OBJECT signals: void testsignal(); void testsignal(int a); &#125;; //qRegisterMetaType 信号参数的作用是数据传递, 谁调用信号函数谁就指定实参，实参最终会被传递给槽函数 3.2 自定义槽 槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的。 特点： 返回值是 void 类型 槽函数也支持重载 槽函数参数个数, 需要看连接的信号的参数个数 槽函数的参数是用来接收信号发送的数据的, 信号的参数就是需要发送的数据 举例: 信号函数: void testsig(int a, double b); 槽函数: void testslot(int a, double b); 总结: 槽函数的参数应该和对应的信号的参数个数, 类型一一对应 信号的参数可以大于等于槽函数的参数个数，未被槽函数接受的数据会被忽略 信号函数: void testsig(int a, double b); 槽函数: void testslot(int a); 槽函数的类型: 成员函数 普通成员函数 静态成员函数 全局函数 lambda表达式(匿名函数) 槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写) public slots: private slots: protected slots: 场景举例 // 女朋友饿了, 我请她吃饭 // class GirlFriend // class OneSelf class GirlFriend:public QObject &#123; Q_OBJECT public: GirlFriend(QObject*parent = nullptr):QObject(parent) &#123;&#125; signals: void hungry(); public slots: &#125;; class OneSelf:public QObject &#123; Q_OBJECT public: OneSelf(QObject*parent = nullptr):QObject(parent) &#123;&#125; void goEat() &#123; qDebug()&lt;&lt;&quot;goEat&quot;; &#125; static void goEatFood() &#123; qDebug()&lt;&lt;&quot;goEatFood&quot;; &#125; signals: public slots: void onHungry() &#123; qDebug()&lt;&lt;&quot;宝贝饿了呀，多喝热水哟~&quot;; &#125; &#125;; class Widget : public QWidget &#123; Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); public slots: void onBtnClicked(); private: GirlFriend *girl; OneSelf* self; &#125;; widget.cpp #include &quot;widget.h&quot; #include&lt;QPushButton&gt; Widget::Widget(QWidget *parent) : QWidget(parent) &#123; girl = new GirlFriend(this); self = new OneSelf(this); //连接槽函数 connect(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::onHungry); //连接普通成员函数 connect(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEat); //连接静态成员函数 connect(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEatFood); QPushButton*btn = new QPushButton(&quot;按下就饿了&quot;,this); //通过widget间接发送girl的hungry信号 connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::onBtnClicked); //连接信号，直接发送girl的hungry信号 //connect(btn,&amp;QPushButton::clicked,girl,&amp;GirlFriend::hungry); &#125; Widget::~Widget() &#123; &#125; void Widget::onBtnClicked() &#123; emit girl-&gt;hungry(); &#125; 4. 信号槽拓展4.1 信号槽使用拓展 一个信号可以连接多个槽函数, 发送一个信号有多个处理动作 需要写多个connect连接 信号的接收者可以是一个对象, 也可以是多个对象 一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的 写多个connect就可以 信号可以连接信号 信号接收者可以不出来接收的信号, 继续发出新的信号 -&gt; 传递了数据, 并没有进行处理 QPushButton*btn = new QPushButton(&quot;one&quot;,this); QPushButton*btn2 = new QPushButton(&quot;two&quot;,this); btn2-&gt;move(100,0); //点击btn按钮，会让btn2按钮发出clicked信号 connect(btn,&amp;QPushButton::clicked,btn2,&amp;QPushButton::clicked); connect(btn2,&amp;QPushButton::clicked,this,&amp;Widget::onClicked); void Widget::onClicked() &#123; qDebug()&lt;&lt;&quot;okok&quot;; &#125; 信号槽是可以断开的 disconnect(const QObject *sender, &amp;QObject::signal, const QObject *receiver, &amp;QObject::method); 4.2 信号槽的连接方式 Qt5的连接方式 // 语法: QMetaObject::Connection QObject::connect( const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection); // 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测 connect(const QObject *sender, &amp;QObject::signal, const QObject *receiver, &amp;QObject::method); Qt4的连接方式 这种旧的信号槽连接方式在Qt5中是支持的, 但是不推荐使用, 因为这种方式在进行信号槽连接的时候, 信号槽函数通过宏SIGNAL和SLOT转换为字符串类型。 因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测， 如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位。 // Qt4的信号槽连接方式 [static] QMetaObject::Connection QObject::connect( const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection); connect(const QObject *sender,SIGNAL(信号函数名(参数1, 参数2, ...)), const QObject *receiver,SLOT(槽函数名(参数1, 参数2, ...))); 应用举例 class Me : public QObject &#123; Q_OBJECT // Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略 public slots: void eat(); void eat(QString somthing); signals: void hungury(); void hungury(QString somthing); &#125;; 基于上面写的信号与槽，我们来处理如下逻辑: 我饿了, 我要吃东西 分析: 信号的发出者是我自己, 信号的接收者也是我自己 Me m; // Qt4处理方式 注意不要把信号与槽的名字写错了，因为是转为字符串写错了不会报错，但是连接会失败 connect(&amp;m, SIGNAL(eat()), &amp;m, SLOT(hungury())); connect(&amp;m, SIGNAL(eat(QString)), &amp;m, SLOT(hungury(QString))); // Qt5处理方式 connect(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury); // error:no matching member function for call to &#39;connect&#39; 为什么Qt4的方式没有错误，Qt5的方式却有问题了呢？ Qt4的方式在传信号和槽的时候用了宏进行强转，而且都带了参数，不会有二义性问题产生 Qt5中，信号和槽都有重载，此事connect函数根本就不知道你要使用的是重载中的哪一个，所以只能报错咯！ 如何解决Qt5中的信号和槽重载中的二义性问题呢？ 一，通过函数指针解决 //信号 void (Me::*funchungury)() = &amp;Me::hungury; void (Me::*funchungury_QString)(QString) = &amp;Me::hungury; //槽 void (Me::*funceat)() = &amp;Me::eat; void (Me::*funceat_QString)(QString) = &amp;Me::eat; //有参连接 connect(me,funchungury_QString,me,funceat_QString); //无参连接 connect(me,funchungury,me,funceat); 二，通过Qt提供的重载类(QOverload)解决 //有参连接 connect(this,QOverload&lt;QString&gt;::of(&amp;MyButton::hungury),this,QOverload&lt;QString&gt;::of(&amp;MyButton::eat)); //无参连接 connect(this,QOverload&lt;&gt;::of(&amp;MyButton::hungury),this,QOverload&lt;&gt;::of(&amp;MyButton::eat)); 总结 Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生 当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响 当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针 4.3 Lambda表达式QPushButton*btn = new QPushButton(&quot;touch me&quot;,this); QPushButton*btn2 = new QPushButton(&quot;天王盖地虎&quot;,this); btn2-&gt;move(100,0); //禁止用&amp;引用捕获临时变量，因为函数结束变量会销毁，在lambda中使用会产生错误 //应该使用按值捕获 = connect(btn,&amp;QPushButton::clicked,this,[=]() &#123; static int flag = false; //可以这样用 if (!flag) &#123; btn2-&gt;setText(&quot;小鸡顿蘑菇&quot;); &#125; else &#123; btn2-&gt;setText(&quot;天王盖地虎&quot;); &#125; flag = !flag; &#125;); Lambda表达式是C++11最重要也是最常用的特性之一，是现代编程语言的一个特点，简洁，提高了代码的效率并且可以使程序更加灵活，Qt是完全支持c++语法的， 因此在Qt中也可以使用Lambda表达式。 Lambda表达式就是一个匿名函数， 语法格式如下： [capture](params) opt -&gt; ret &#123;body;&#125;; - capture: 捕获列表 - params: 参数列表 - opt: 函数选项 - ret: 返回值类型 - body: 函数体 // 示例代码-&gt;匿名函数的调用: int ret = [](int a) -&gt; int &#123; return a+1; &#125;(100); 关于Lambda表达式的细节介绍: 捕获列表: 捕获一定范围内的变量 [] - 不捕捉任何变量 [&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获) [=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获) 拷贝的副本在匿名函数体内部是只读的 [=, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo [bar] - 按值捕获 bar 变量, 同时不捕获其他变量 [&amp;bar] - 按值捕获 bar 变量, 同时不捕获其他变量 [this] - 捕获当前类中的this指针 让lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项 参数列表: 和普通函数的参数列表一样 opt 选项 –&gt; 可以省略 mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身） exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(); 返回值类型: 标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略 函数体: 函数的实现，这部分不能省略，但函数体可以为空。 Qt内存回收机制一、简介​ Qt内存管理机制：Qt 在内部能够维护对象的层次结构。对于可视元素，这种层次结构就是子组件与父组件的关系；对于非可视元素，则是一个对象与另一个对象的从属关系。在 Qt 中，在 Qt 中，删除父对象会将其子对象一起删除。 C++中delete 和 new 必须配对使用(一 一对应)：delete少了，则内存泄露，多了麻烦更大。Qt中使用了new却很少delete，因为QObject的类及其继承的类，设置了parent（也可在构造时使用setParent函数或parent的addChild）故parent被delete时，这个parent的相关所有child都会自动delete，不用用户手动处理。但parent是不区分它的child是new出来的还是在栈上分配的。这体现delete的强大，可以释放掉任何的对象，而delete栈上对象就会导致内存出错，这需要了解Qt的半自动的内存管理。另一个问题：child不知道它自己是否被delete掉了，故可能会出现野指针。那就要了解Qt的智能指针QPointer。 在Qt中，最基础和核心的类是：QObject，QObject内部有一个list，会保存children，还有一个指针保存parent，当自己析构时，会自己从parent列表中删除并且析构所有的children。 1、内存管理（1）QObject及其派生类的对象，如果其parent非nullptr，那么其parent析构时会析构该对象。 （2）父子关系：父对象、子对象、父子关系。这是Qt中所特有的，与类的继承关系无关，传递参数是与parent有关（基类、派生类，或父类、子类，这是对于派生体系来说的，与parent无关）。 2、内存问题例子#include &lt;QPushButton&gt; Widget::Widget(QWidget *parent) &#123; QLabel *label = new QLabel(&quot;Hello Qt!&quot;); label-&gt;show(); &#125; 分析：label 既没有指定parent，也没有对其调用delete，所以会造成内存泄漏。 改进方式： 分配对象到栈上而不是堆上 #include &lt;QLabel&gt; Widget::Widget(QWidget *parent) &#123; QLabel label(&quot;Hello Qt!&quot;); label.show(); &#125; 分析：构造函数执行完毕，对象生命周期结束会被自动析构，窗口上的控件消失不见 使用指定父对象的方式自动管理内存 class MyPushButton:public QPushButton &#123; public: using QPushButton::QPushButton; ~MyPushButton() &#123; qDebug()&lt;&lt;&quot;MyPushButton 析构~&quot;; &#125; &#125;; Widget::Widget(QWidget *parent) &#123; QPushButton* btn2 = new MyPushButton(&quot;第二个按钮&quot;,this); btn2-&gt;move(100,0); &#125; //运行之后关掉窗口，应用程序输出显示：MyPushButton 析构~","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"QT(常用数据类型)","slug":"QT(常用数据类型)","date":"2022-09-01T07:32:46.000Z","updated":"2022-09-22T11:03:53.806Z","comments":true,"path":"2022/09/01/QT(常用数据类型)/","link":"","permalink":"http://goskp.github.io/2022/09/01/QT(%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)/","excerpt":"","text":"项目文件main.cpp 主函数所在的文件 #ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; //Qt标准窗口类头文件 class Widget : public QWidget //自己的类继承自Qwidget类 &#123; Q_OBJECT //使用信号与槽机制，必须包含该宏 public: Widget(QWidget *parent = nullptr); ~Widget(); &#125;; #endif // WIDGET_H widget.cpp 窗口类源文件 #include &quot;widget.h&quot; Widget::Widget(QWidget *parent) : QWidget(parent) &#123; &#125; Widget::~Widget() &#123; &#125; HelloQt.pro Qt项目文件，注释需要用#号 #项目编译时需要加载哪些模块 QT += core gui # 如果当前Qt版本大于4, 要添加一个额外的模块: widgets # Qt 5中对gui模块进行了拆分, 将 widgets 独立出来了 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets # 让Qt支持c++11标准 CONFIG += c++11 #如果您使用任何已标记为不推荐使用的Qt功能，则以下定义使您的编译器发出警告（确切的警告取决于您的编译器）。 #请参考不推荐使用的API的文档，以了解如何将您的代码移植远离它。 DEFINES += QT_DEPRECATED_WARNINGS #如果使用过时的API，您还可以使代码无法编译。 #为此，请取消注释以下行。 #您也可以选择仅在特定版本的Qt之前禁用已弃用的API。 #DEFINES + = QT_DISABLE_DEPRECATED_BEFORE = 0x060000 ＃禁用所有在Qt 6.0.0之前弃用的API # 项目中的源文件 删除后，项目里不会显示所有的源文件 SOURCES += \\ main.cpp \\ widget.cpp # 项目中的头文件 HEADERS += \\ widget.h #部署的默认规则 qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin #嵌入式 else: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin #unix !isEmpty(target.path): INSTALLS += target pro是Qt的工程文件，这个文件是给qmake用来生成Makefile用的。 如果了解makefile的人应该知道，Makefile的三个关键点就是目标，依赖，命令。这里也很类似。pro文件中可以指明这个Qt项目的头文件，源文件，链接的外部库，目标文件名，模板(生成什么样的Makefile)，版本配置(debug/release)等。 常用qmake变量 .pro中变量 含义 示例 TEMPLATE 模板变量指定生成makefile(app:应用程序&#x2F;lib:库) TEMPLATE &#x3D; app QT 指定加载的Qt模块(core&#x2F;gui&#x2F;widgets…) QT +&#x3D; widgtes DESTDIR 指定生成的应用程序放置的目录 DESTDIR +&#x3D; ..&#x2F;bin TARGET 指定生成的应用程序名 TARGET &#x3D; hello HEADERS 工程中包含的头文件 HEADERS +&#x3D; hello.h FORMS 工程中包含的.ui设计文件 FORMS +&#x3D; hello.ui SOURCES 工程中包含的源文件 SOURCES +&#x3D; main.cpp hello.cpp RESOURCES 工程中包含的资源文件 RESOURCES +&#x3D; qrc&#x2F;hello.qrc LIBS 引入的lib文件的路径 -L：引入路径 LIBS +&#x3D; -L. CONFIG 用来告诉qmake关于应用程序的配置信息 CONFIG+&#x3D; qt warn_on release UI_DIR 指定.ui文件转化成ui_*.h文件的存放目录 UI_DIR +&#x3D; forms RCC_DIR 指定将.qrc文件转换成qrc_*.h文件的存放目录 RCC_DIR +&#x3D; ..&#x2F;tmp MOC_DIR 指定将含Q_OBJECT的头文件转换成标准.h文件的存放目录 MOC_DIR +&#x3D; ..&#x2F;tmp OBJECTS_DIR 指定目标文件(obj)的存放目录 OBJECTS_DIR +&#x3D; ..&#x2F;tmp DEPENDPATH 程序编译时依赖的相关路径 DEPENDPATH +&#x3D; . forms include qrc sources INCLUDEPATH 头文件包含路径 INCLUDEPATH +&#x3D; . DEFINES 增加预处理器宏（gcc的-D选项）。 DEFINES +&#x3D; USE_MY_STUFF QMAKE_CFLAGS 设置c编译器flag参数 QMAKE_CFLAGS +&#x3D; -g QMAKE_CXXFLAGS 设置c++编译器flag参数 QMAKE_CXXFLAGS +&#x3D; -g QMAKE_LFLAGS 设置链接器flag参数 QMAKE_LFLAGS +&#x3D; -rdynamic 常用快捷键 运行 Ctrl + r 编译 Ctrl + b 注释 Ctrl + &#x2F; 字体缩放 Ctrl + 鼠标滚轮 查找&#x2F;替换 Ctrl + f 整行移动 Ctrl + Shift + ↑ 或 ↓ 自动对齐 Ctrl + i 帮助文档 第一种：Qt Creator 直接查看 F1 第二种：打开独立的帮助文档程序 assistant 同名.h 和 .cpp 之间的切换 F4 快速添加函数的定义 Alt + Enter 鼠标移动到函数申明上 修改变量名，并应用到所有用到该变量的地方 Ctrl + Shift +r 快速打开输出窗口 Alt + 数字键(1-8) 书签功能,即在某行代码处进行标记,方便以后找到。书签也可以添加文字标注。 按Ctrl + M 添加&#x2F;删除书签 按Ctrl + . 查找并移动到下一个标签 基础类型因为Qt是一个C++框架, 因此C++中所有的语法和数据类型在Qt中都是被支持的, 但是Qt中也定义了一些属于自己的数据类型 QT基本数据类型定义在#include &lt;QtGlobal&gt; 中，QT基本数据类型有： 类型名称 注释 备注 qint8 signed char 有符号8位数据 qint16 signed short 16位数据类型 qint32 signed short 32位有符号数据类型 qint64 long long int 或(__int64) 64位有符号数据类型，Windows中定义为__int64 qintptr qint32 或 qint64 指针类型 根据系统类型不同而不同，32位系统为qint32、64位系统为qint64 qlonglong long long int 或(__int64) Windows中定义为__int64 qptrdiff qint32 或 qint64 根据系统类型不同而不同，32位系统为qint32、64位系统为qint64 qreal double 或 float 除非配置了-qreal float选项，否则默认为double quint8 unsigned char 无符号8位数据类型 quint16 unsigned short 无符号16位数据类型 quint32 unsigned int 无符号32位数据类型 quint64 unsigned long long int 或 (unsigned __int64) 无符号64比特数据类型，Windows中定义为unsigned __int64 quintptr quint32 或 quint64 根据系统类型不同而不同，32位系统为quint32、64位系统为quint64 qulonglong unsigned long long int 或 (unsigned __int64) Windows中定义为__int64 uchar unsigned char 无符号字符类型 uint unsigned int 无符号整型 ulong unsigned long 无符号长整型 ushort unsigned short 无符号短整型 qsizetype size_t log输出 在Qt中进行log输出, 一般不使用c中的printf, 也不是使用C++中的cout, Qt框架提供了专门用于日志输出的类, 头文件名为 QDebug。 基本分类 qDebug：调试信息提示 qInfo ：输出信息 qWarning ：一般的警告提示 qCritical ：严重的错误提示 qFatal ：致命错误提示，会直接中断程序 C风格输出 qDebug(&quot;我是%s，今年%d岁了~&quot;,&quot;kpsun&quot;,17); qInfo(&quot;kpsun%d&quot;,666); qWarning(&quot;hello %s&quot;,&quot;warning&quot;); qCritical(&quot;helo %s&quot;,&quot;critical&quot;); qFatal(&quot;hello %s&quot;,&quot;qFatal&quot;); //致命错误会直接中断程序 C++风格 qDebug()&lt;&lt;&quot;好帅&quot;&lt;&lt;endl; qInfo()&lt;&lt;&quot;qInfo&quot;&lt;&lt;endl; qWarning()&lt;&lt;&quot;qWarnning&quot;&lt;&lt;endl; qCritical()&lt;&lt;&quot;qCritical&quot;&lt;&lt;endl; #qFatal()&lt;&lt;&quot;qFatal&quot;&lt;&lt;endl; //致命错误不能用&lt;&lt;输出 字符串类型 C &#x3D;&gt; char* C++ &#x3D;&gt; std::string Qt &#x3D;&gt; QByteArray, QString QByteArray 在Qt中QByteArray可以看做是C语言中 char*的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。 构造函数 // 构造空对象, 里边没有数据 QByteArray::QByteArray(); // 将data中的size个字符进行构造, 得到一个字节数组对象 // 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data) QByteArray::QByteArray(const char *data, int size = -1); // 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组 QByteArray::QByteArray(int size, char ch); 数据操作 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray &amp;QByteArray::append(const QByteArray &amp;ba); void QByteArray::push_back(const QByteArray &amp;other); // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray &amp;QByteArray::prepend(const QByteArray &amp;ba); void QByteArray::push_front(const QByteArray &amp;other); // 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始) // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray &amp;QByteArray::insert(int i, const QByteArray &amp;ba); // 删除数据 // 从大字符串中删除len个字符, 从第pos个字符的位置开始删除 QByteArray &amp;QByteArray::remove(int pos, int len); // 从字符数组的尾部删除 n 个字节 void QByteArray::chop(int n); // 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除) void QByteArray::truncate(int pos); // 将对象中的数据清空, 使其为null void QByteArray::clear(); // 字符串替换 // 将字节数组中的 子字符串 before 替换为 after // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray &amp;QByteArray::replace(const QByteArray &amp;before, const QByteArray &amp;after); 子字符串查找和判断 // 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false bool QByteArray::contains(const QByteArray &amp;ba) const; bool QByteArray::contains(const char *ba) const; // 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false bool QByteArray::contains(char ch) const; // 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false bool QByteArray::startsWith(const QByteArray &amp;ba) const; bool QByteArray::startsWith(const char *ba) const; // 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false bool QByteArray::startsWith(char ch) const; // 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false bool QByteArray::endsWith(const QByteArray &amp;ba) const; bool QByteArray::endsWith(const char *ba) const; // 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false bool QByteArray::endsWith(char ch) const; 遍历 // 使用迭代器 iterator QByteArray::begin(); iterator QByteArray::end(); // 使用数组的方式进行遍历 // i的取值范围 0 &lt;= i &lt; size() char QByteArray::at(int i) const; char QByteArray::operator[](int i) const; 查看字节数 // 返回字节数组对象中字符的个数 int QByteArray::length() const; int QByteArray::size() const; int QByteArray::count() const; // 返回字节数组对象中 子字符串ba 出现的次数 int QByteArray::count(const QByteArray &amp;ba) const; int QByteArray::count(const char *ba) const; // 返回字节数组对象中 字符串ch 出现的次数 int QByteArray::count(char ch) const; 类型转换 // 将QByteArray类型的字符串 转换为 char* 类型 char *QByteArray::data(); const char *QByteArray::data() const; // int, short, long, float, double -&gt; QByteArray // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray &amp;QByteArray::setNum(int n, int base = 10); QByteArray &amp;QByteArray::setNum(short n, int base = 10); QByteArray &amp;QByteArray::setNum(qlonglong n, int base = 10); QByteArray &amp;QByteArray::setNum(float n, char f = &#39;g&#39;, int prec = 6); QByteArray &amp;QByteArray::setNum(double n, char f = &#39;g&#39;, int prec = 6); [static] QByteArray QByteArray::number(int n, int base = 10); [static] QByteArray QByteArray::number(qlonglong n, int base = 10); [static] QByteArray QByteArray::number(double n, char f = &#39;g&#39;, int prec = 6); // QByteArray -&gt; int, short, long, float, double int QByteArray::toInt(bool *ok = Q_NULLPTR, int base = 10) const; short QByteArray::toShort(bool *ok = Q_NULLPTR, int base = 10) const; long QByteArray::toLong(bool *ok = Q_NULLPTR, int base = 10) const; float QByteArray::toFloat(bool *ok = Q_NULLPTR) const; double QByteArray::toDouble(bool *ok = Q_NULLPTR) const; // std::string -&gt; QByteArray [static] QByteArray QByteArray::fromStdString(const std::string &amp;str); // QByteArray -&gt; std::string std::string QByteArray::toStdString() const; // 所有字符转换为大写 QByteArray QByteArray::toUpper() const; // 所有字符转换为小写 QByteArray QByteArray::toLower() const; QString QString也是封装了字符串, 但是内部的编码为utf8, UTF-8属于Unicode字符集, 它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符，这样可以将世界上几乎所有语言的常用字符收录其中。 构造函数// 构造一个空字符串对象 QString(); // 将 char* 字符串 转换为 QString 类型 QString(const char *str); // 将 QByteArray 转换为 QString 类型 QString(const QByteArray &amp;ba); // 其他重载的同名构造函数可参考Qt帮助文档, 此处略 数据操作// 尾部追加数据 QString&amp; append(const QString &amp;str); QString&amp; append(const char *str); QString&amp; append(const QByteArray &amp;ba); void push_back(const QString &amp;other); // 头部添加数据 QString&amp; prepend(const QString &amp;str); QString&amp; prepend(const char *str); QString&amp; prepend(const QByteArray &amp;ba); void QString::push_front(const QString &amp;other); // 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始) QString&amp; insert(int position, const QString &amp;str); QString&amp; insert(int position, const char *str); QString&amp; insert(int position, const QByteArray &amp;str); // 删除数据 // 从大字符串中删除len个字符, 从第pos个字符的位置开始删除 QString&amp; remove(int position, int n); // 从字符串的尾部删除 n 个字符 void chop(int n); // 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除) void truncate(int position); // 将对象中的数据清空, 使其为null void clear(); // 字符串替换 // 将字节数组中的 子字符串 before 替换为 after // 参数 cs 为是否区分大小写, 默认区分大小写 QString&amp; replace(const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive); 子字符串查找和判断// 参数 cs 为是否区分大小写, 默认区分大小写 // 其他重载的同名函数可参考Qt帮助文档, 此处略 // 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false bool contains(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; // 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false bool startsWith(const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; // 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false bool endsWith(const QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 遍历// 使用迭代器 iterator begin(); iterator end(); // 使用数组的方式进行遍历 const QChar at(int position) const const QChar operator[](int position) const; 查看字节数// 返回字节数组对象中字符的个数 int length() const; int size() const; int count() const; // 返回字节串对象中 子字符串 str 出现的次数 // 参数 cs 为是否区分大小写, 默认区分大小写 int count(const QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 类型转换// int, short, long, float, double -&gt; QString // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString&amp; setNum(int n, int base = 10); QString&amp; setNum(short n, int base = 10); QString&amp; setNum(long n, int base = 10); QString&amp; setNum(float n, char format = &#39;g&#39;, int precision = 6); QString&amp;QString::setNum(double n, char format = &#39;g&#39;, int precision = 6); [static] QString QString::number(long n, int base = 10); [static] QString QString::number(int n, int base = 10); [static] QString QString::number(double n, char format = &#39;g&#39;, int precision = 6); // QString -&gt; int, short, long, float, double int QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const; short QString::toShort(bool *ok = Q_NULLPTR, int base = 10) const; long QString::toLong(bool *ok = Q_NULLPTR, int base = 10) const float QString::toFloat(bool *ok = Q_NULLPTR) const; double QString::toDouble(bool *ok = Q_NULLPTR) const; // 所有字符转换为大写 QString QString::toUpper() const; // 所有字符转换为小写 QString QString::toLower() const; 字符串格式化C语言中有sprintf()函数，QString也提供了一个asprintf()函数。 QString res = QString::asprintf(&quot;fileName:%s size:%d&quot;,&quot;./av.jpg&quot;,20); qDebug()&lt;&lt;res&lt;&lt;endl; 不过QString还提供的另一种格式化字符串输出的函数arg()，更为方便。 QString arg(const QString &amp;a, int fieldWidth = 0, QChar fillChar = QLatin1Char( &#39; &#39; )) const; QString arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( &#39; &#39; )) const; //用于填充字符串中的%1,%2…为给定格式的整形数字，其中第一个参数是要填充的数字，第二个参数为最小宽度，第三个参数为进制，第四个参数为当原始数字长度不足最小宽度时用于填充的字符 // 示例程序 QString str = QString(&quot;%1 %2 %3&quot;).arg(1).arg(2); str = str.arg(&quot;hello&quot;); qDebug()&lt;&lt;str&lt;&lt;endl; //&quot;hello 2 1&quot; QString text = QString(&quot;%1:%2:%3&quot;).arg(1,2,10,QChar(&#39;0&#39;)).arg(35).arg(59); qDebug()&lt;&lt;text&lt;&lt;endl; //&quot;01:35:59&quot; 3.2 不同字符串类型相互转换// std::string -&gt; QString [static] QString QString::fromStdString(const std::string &amp;str); // QString -&gt; std::string std::string QString::toStdString() const; #QString -&gt; QByteArray // 转换为本地编码, 跟随操作系统 QByteArray QString::toLocal8Bit() const; // 转换为 Latin-1 编码的字符串 不支持中文 QByteArray QString::toLatin1() const; // 转换为 utf8 编码格式的字符串 (常用) QByteArray QString::toUtf8() const; #QByteArray -&gt; QString //使用QString的构造函数即可 4. QVariant QVariant(变体数据类型)这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。 QVariant 这个类型充当着最常见的数据类型的联合。QVariant 可以保存很多Qt的数据类型，包括QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、 QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString，并且还有C++基本类型，如 int、float等。 4.1 标准类型 将标准类型转换为QVariant类型 // 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个 QVariant(int val); QVariant(bool val); QVariant(double val); QVariant(const char *val); QVariant(const QByteArray &amp;val); QVariant(const QString &amp;val); ...... // 使用设置函数也可以将支持的类型的数据设置到QVariant对象中 // 这里的 T 类型, 就是QVariant支持的类型 void setValue(const T &amp;value); // 该函数行为和 setValue() 函数完全相同 [static] QVariant fromValue(const T &amp;value); Exmple QVariant v(5); QVariant v; v.setValue(5); QVariant v = QVariant::fromValue(5); int i = v.toInt(); // i is now 5 QString s = v.toString(); // s is now &quot;5&quot; 判断 QVariant中封装的实际数据类型 Type 是枚举类型 //获取类型，返回的是一个枚举类型;如QVariant::Int ... Type type() const; //获取类型名 const char *typeName() const; //根据类型id(枚举)获取类型名(字符串) [static] const char *typeToName(int typeId); //根据类型名(字符串)获取类型id(枚举) [static] Type nameToType(const char *name); 将QVariant对象转换为实际的数据类型 //在转换之前可以先判断能够转换成对应的类型 bool canConvert(int targetTypeId) const bool canConvert() const bool toBool() const; QByteArray toByteArray() const; double toDouble(bool *ok = Q_NULLPTR) const; float toFloat(bool *ok = Q_NULLPTR) const; int toInt(bool *ok = Q_NULLPTR) const; QString toString() const; ...... T value() const //v.value&lt;int&gt;(); 4.2 自定义类型 除了标准类型, 我们自定义的类型也可以使用QVariant类进行封装, 被QVariant存储的数据类型需要有一个默认的构造函数和一个拷贝构造函数。为了实现这个功能，首先必须使用Q_DECLARE_METATYPE()宏。通常会将这个宏放在类的声明所在头文件的下面， 原型为： Q_DECLARE_METATYPE(Type) 使用的具体步骤如下: 第一步: 定义类型，并注册 //自定义类型 class Animal &#123; public: Animal()&#123;&#125; //必须要有默认构造函数 //拷贝构造函数也必须有，不过没有深、浅拷贝时，用默认的即可 Animal(QString name):_name(name)&#123;&#125; void show() &#123; qDebug()&lt;&lt;&quot;Animal show name is :&quot;&lt;&lt; _name &lt;&lt;endl; &#125; private: QString _name; &#125;; //自定义类型注册 Q_DECLARE_METATYPE(Animal); 第二步: 使用forvalue()存储对象 int main() &#123; //QVariant vt(Animal(&quot;snake&quot;)); //不可以通过构造函数存自定义类型 QVariant vt; //有以下两种方法可以，存自定义类型 vt = QVariant::fromValue(Animal(&quot;dog&quot;)); //① vt.setValue(Animal(&quot;cat&quot;)); //② //如果能转换到Animal类型，就转换 if(vt.canConvert&lt;Animal&gt;()) &#123; Animal animal = vt.value&lt;Animal&gt;(); animal.show(); &#125; return 0; &#125; 操作涉及的API如下: // 如果当前QVariant对象可用转换为对应的模板类型 T, 返回true, 否则返回false bool canConvert() const; // 将当前QVariant对象转换为实际的 T 类型 T value() const; 位置和尺寸 在QT中我们常见的 点, 线, 尺寸, 矩形 都被进行了封装。 QPoint QPoint类封装了我们常用用到的坐标点 (x, y), 常用的 API如下: void QPoint::setX(int x); void QPoint::setY(int y); int QPoint::x() const; int &amp;QPoint::rx(); int QPoint::y() const; int &amp;QPoint::ry(); //如果x和y坐标都为0则返回true，否则返回false bool isNull() const //返回x()和y()的绝对值之和，传统上称为从原点到该点的向量的“曼哈顿长度”。 //(p1-p2).manhattanLength(); int manhattanLength() const //返回一个交换了x和y坐标的点: QPoint&#123;1, 2&#125;.transposed() // &#123;2, 1&#125; QPoint transposed() const // 直接通过坐标对象进行算术运算: 加减乘除 QPoint &amp;QPoint::operator*=(float factor); QPoint &amp;QPoint::operator*=(double factor); QPoint &amp;QPoint::operator*=(int factor); QPoint &amp;QPoint::operator+=(const QPoint &amp;point); QPoint &amp;QPoint::operator-=(const QPoint &amp;point); QPoint &amp;QPoint::operator/=(qreal divisor); ... QLine QLine是一个直线类, 封装了两个坐标点 (两点确定一条直线) 常用API如下: // 设置直线的起点坐标 void setP1(const QPoint &amp;p1); // 设置直线的终点坐标 void setP2(const QPoint &amp;p2); void setPoints(const QPoint &amp;p1, const QPoint &amp;p2); void setLine(int x1, int y1, int x2, int y2); QPoint p1() const; // 返回直线的起始点坐标 QPoint p2() const; // 返回直线的终点坐标 QPoint center() const; // 返回值直线的中心点坐标, (p1() + p2()) / 2 int x1() const; // 返回值直线起点的 x 坐标 int y1() const; // 返回值直线起点的 y 坐标 int x2() const; // 返回值直线终点的 x 坐标 int y2() const; // 返回值直线终点的 y 坐标 int dx() const //返回直线向量的水平分量 int dy() const //返回直线向量的垂直分量 // 用给定的坐标点平移这条直线 void translate(const QPoint &amp;offset); void translate(int dx, int dy); // 用给定的坐标点平移这条直线, 返回平移之后的坐标点(不会改变这条线的坐标) QLine translated(const QPoint &amp;offset) const; QLine translated(int dx, int dy) const; // 直线对象进行比较 bool operator!=(const QLine &amp;line) const; bool operator==(const QLine &amp;line) const; QSize 在QT中QSize类用来形容长度和宽度, 常用的API如下: void setWidth(int width) void setHeight(int height); int width() const; // 得到宽度 int &amp;rwidth(); // 得到宽度的引用 int height() const; // 得到高度 int &amp;rheight(); // 得到高度的引用 void transpose(); // 交换高度和宽度的值 QSize transposed() const; // 交换高度和宽度的值, 返回交换之后的尺寸信息 //返回一个大小，宽为当前大小与other的最小值，高为当前大小与other的最小值 QSize boundedTo(const QSize&amp; oterSize) //返回一个大小，宽为当前大小与other的最大值，高为当前大小与other的最大值 QSize expandedTo(const QSize &amp;otherSize) const /* 根据指定的模式，按给定的宽度和高度缩放矩形: 如果mode为Qt::IgnoreAspectRatio，则大小设置为(width, height)。 如果mode为Qt::KeepAspectRatio，当前大小将在内部缩放到一个尽可能大的矩形(宽度，高度)，保持高宽比。 如果mode是Qt::KeepAspectRatioByExpanding，当前大小被缩放到一个矩形，尽可能小的外部(宽度，高度)，保持长宽比。 */ void scale(int width, int height, Qt::AspectRatioMode mode) void scale(const QSize &amp;size, Qt::AspectRatioMode mode) QSize scaled(int width, int height, Qt::AspectRatioMode mode) const QSize scaled(const QSize &amp;s, Qt::AspectRatioMode mode) const // 进行算法运算: 加减乘除 QSize &amp;operator*=(qreal factor); QSize &amp;operator+=(const QSize &amp;size); QSize &amp;operator-=(const QSize &amp;size); QSize &amp;operator/=(qreal divisor); QRect 在Qt中使用 QRect类来描述一个矩形, 常用的API如下: // 构造一个空对象 QRect::QRect(); // 基于左上角坐标, 和右下角坐标构造一个矩形对象 QRect::QRect(const QPoint &amp;topLeft, const QPoint &amp;bottomRight); // 基于左上角坐标, 和 宽度, 高度构造一个矩形对象 QRect::QRect(const QPoint &amp;topLeft, const QSize &amp;size); // 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象 QRect::QRect(int x, int y, int width, int height); // 设置矩形的尺寸信息, 左上角坐标不变 void QRect::setSize(const QSize &amp;size); // 设置矩形左上角坐标为(x,y), 大小为(width, height) void QRect::setRect(int x, int y, int width, int height); // 设置矩形宽度 void QRect::setWidth(int width); // 设置矩形高度 void QRect::setHeight(int height); // 返回值矩形左上角坐标 QPoint QRect::topLeft() const; // 返回矩形右上角坐标 // 该坐标点值为: QPoint(left() + width() -1, top()) QPoint QRect::topRight() const; // 返回矩形左下角坐标 // 该坐标点值为: QPoint(left(), top() + height() - 1) QPoint QRect::bottomLeft() const; // 返回矩形右下角坐标 // 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1) QPoint QRect::bottomRight() const; // 返回矩形中心点坐标 QPoint QRect::center() const; // 返回矩形上边缘y轴坐标 int QRect::top() const; int QRect::y() const; // 返回值矩形下边缘y轴坐标 int QRect::bottom() const; // 返回矩形左边缘 x轴坐标 int QRect::x() const; int QRect::left() const; // 返回矩形右边缘x轴坐标 int QRect::right() const; // 返回矩形的高度 int QRect::width() const; // 返回矩形的宽度 int QRect::height() const; // 返回矩形的尺寸信息 QSize QRect::size() const; //调整矩形的尺寸 （左上角和右下角坐标偏移量） void QRect::adjust(int dx1, int dy1, int dx2, int dy2) QRect QRect::adjusted(int dx1, int dy1, int dx2, int dy2) const QPoint，QLine，QSize，QRect各自都还有浮点型版本的，分别是QPointF，QLineF，QSizeF，QRectF，函数基本一样 日期和时间QDate// 构造函数 QDate::QDate(); QDate::QDate(int y, int m, int d); // 公共成员函数 // 重新设置日期对象中的日期 bool QDate::setDate(int year, int month, int day); // 给日期对象添加 ndays 天 QDate QDate::addDays(qint64 ndays) const; // 给日期对象添加 nmonths 月 QDate QDate::addMonths(int nmonths) const; // 给日期对象添加 nyears 月 QDate QDate::addYears(int nyears) const; // 得到日期对象中的年/月/日 int QDate::year() const; int QDate::month() const; int QDate::day() const; void QDate::getDate(int *year, int *month, int *day) const; /*日期对象格式化 d - 没有前导零的日子 (1 to 31) dd - 前导为0的日子 (01 to 31) ddd - 显示(缩写) 周一、周二、周三、周四、周五、周六、周日 dddd - 显示(完整) 星期一、星期二、星期三、星期四、星期五、星期六、星期日 M - 没有前导零的月份(1到12) MM - 前导零的月份(01到12) MMM - 缩写 1月、2月、3月... MMMM - 完整 一月、二月、三月... yy - 两个数字的年 (00 to 99) yyyy - 以四位数表示的年份 */ QString QDate::toString(const QString &amp;format) const; // 操作符重载 ==&gt; 日期比较 bool QDate::operator!=(const QDate &amp;d) const; bool QDate::operator&lt;(const QDate &amp;d) const; bool QDate::operator&lt;=(const QDate &amp;d) const; bool QDate::operator==(const QDate &amp;d) const; bool QDate::operator&gt;(const QDate &amp;d) const; bool QDate::operator&gt;=(const QDate &amp;d) const; // 静态函数 -&gt; 得到本地的当前日期 [static] QDate QDate::currentDate(); QTime// 构造函数 QTime::QTime(); /* h ==&gt; must be in the range 0 to 23 m and s ==&gt; must be in the range 0 to 59 ms ==&gt; must be in the range 0 to 999 */ QTime::QTime(int h, int m, int s = 0, int ms = 0); // 公共成员函数 // Returns true if the set time is valid; otherwise returns false. bool QTime::setHMS(int h, int m, int s, int ms = 0); QTime QTime::addSecs(int s) const; QTime QTime::addMSecs(int ms) const; // 示例代码 QTime n(14, 0, 0); // n == 14:00:00 QTime t; t = n.addSecs(70); // t == 14:01:10 t = n.addSecs(-70); // t == 13:58:50 t = n.addSecs(10 * 60 * 60 + 5); // t == 00:00:05 t = n.addSecs(-15 * 60 * 60); // t == 23:00:00 // 从时间对象中取出 时/分/秒/毫秒 // Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid. int QTime::hour() const; // Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid. int QTime::minute() const; // Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid. int QTime::second() const; // Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid. int QTime::msec() const; // 时间格式化 /* -- 时 h ==&gt; The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display) hh ==&gt; The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display) H ==&gt; The hour without a leading zero (0 to 23, even with AM/PM display) HH ==&gt; The hour with a leading zero (00 to 23, even with AM/PM display) -- 分 m ==&gt; The minute without a leading zero (0 to 59) mm ==&gt; The minute with a leading zero (00 to 59) -- 秒 s ==&gt; The whole second, without any leading zero (0 to 59) ss ==&gt; The whole second, with a leading zero where applicable (00 to 59) -- 毫秒 zzz ==&gt; The fractional part of the second, to millisecond precision, including trailing zeroes where applicable (000 to 999). -- 上午或者下午 AP or A ==&gt; 使用AM/PM(大写) 描述上下午, 中文系统显示汉字 ap or a ==&gt; 使用am/pm(小写) 描述上下午, 中文系统显示汉字 */ QString QTime::toString(const QString &amp;format) const; // 操作符重载 ==&gt; 时间比较 bool QTime::operator!=(const QTime &amp;t) const; bool QTime::operator&lt;(const QTime &amp;t) const; bool QTime::operator&lt;=(const QTime &amp;t) const; bool QTime::operator==(const QTime &amp;t) const; bool QTime::operator&gt;(const QTime &amp;t) const; bool QTime::operator&gt;=(const QTime &amp;t) const; // 静态函数 -&gt; 得到当前时间 [static] QTime QTime::currentTime(); 经时计时器QTime的经时计时器已经过时了，推荐使用QElapsedTimer。 //QTime已废弃的函数 // 开始计时 void QTime::start(); // 计时结束 int QTime::elapsed() const; // 重新计时 int QTime::restart(); // 推荐使用的API函数 // QElapsedTimer 类 void QElapsedTimer::start(); qint64 QElapsedTimer::restart(); qint64 QElapsedTimer::elapsed() const; 主要的使用方法就是测量一个操作耗时多久，例子如下： QElapsedTimer elapse; elapse.start(); for(int i = 0;i&lt;10000000;i++); qDebug()&lt;&lt;elapse.elapsed()&lt;&lt;endl; QDateTime// 构造函数 QDateTime::QDateTime(); QDateTime::QDateTime(const QDate &amp;date, const QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime); // 公共成员函数 // 设置日期 void QDateTime::setDate(const QDate &amp;date); // 设置时间 void QDateTime::setTime(const QTime &amp;time); // 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数 QDateTime QDateTime::addYears(int nyears) const; QDateTime QDateTime::addMonths(int nmonths) const; QDateTime QDateTime::addDays(qint64 ndays) const; QDateTime QDateTime::addSecs(qint64 s) const; QDateTime QDateTime::addMSecs(qint64 msecs) const; // 得到对象中的日期 QDate QDateTime::date() const; // 得到对象中的时间 QTime QDateTime::time() const; // 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数 QString QDateTime::toString(const QString &amp;format) const; // 操作符重载 ==&gt; 日期时间对象的比较 bool QDateTime::operator!=(const QDateTime &amp;other) const; bool QDateTime::operator&lt;(const QDateTime &amp;other) const; bool QDateTime::operator&lt;=(const QDateTime &amp;other) const; bool QDateTime::operator==(const QDateTime &amp;other) const; bool QDateTime::operator&gt;(const QDateTime &amp;other) const; bool QDateTime::operator&gt;=(const QDateTime &amp;other) const; // 静态函数 // 得到当前时区的日期和时间(本地设置的时区对应的日期和时间) [static] QDateTime QDateTime::currentDateTime(); containerQt中提供了一组通用的基于模板的容器类（container class）。可以用来存储指定的项（items）,与STL(C++标准模板库)相比，Qt中的容器更轻量，更安全，功能更强大。 序列式容器 QList QLinkedList QVector QStack QQueue 对于大多数应用程序，QList是最好的类型。虽然它是作为数组列表实现的，但是它提供了非常快的前置和附加。如果你真的需要一个链表，使用QLinkedList;如果您希望您的项目占用连续的内存位置，请使用QVector。QStack和QQueue是提供LIFO和FIFO语义的便利类。 关联式容器 QMap QMultiMap QHash QMultiHash QSet “multi”容器方便地支持与单个键相关联的多个值。“hash”容器通过使用哈希函数而不是对排序集进行二进制搜索，从而提供更快的查找。 作为特殊情况，QCache和QContiguousCache类在有限的缓存存储中提供了对象的高效散列查找。 遍历容器Qt提供了两种遍历容器的风格： java风格的迭代器和stl风格的迭代器。java风格的迭代器更容易使用并提供高级功能，而STL风格的迭代器稍微更高效，可以与Qt和STL的通用算法一起使用。 java风格 容器 只读迭代器 读写迭代器 QList,QQueue QListIterator QMutableListIterator QLinkedList QLinkedListIterator QMutableLinkedListIterator QVector,QStack QVectorIterator QMutableVectorIterator QSet QSetIterator QMutableSetIterator QMap&lt;Key,T&gt;,QMultiMap&lt;Key,T&gt; QMapIterator QMutableMapIterator QHash&lt;Key,T&gt;,QMultiHash&lt;Key,T&gt; QHashIterator QMutableHashIterator STL风格 容器 只读迭代器 读写迭代器 QList,QQueue QList::const_iterator QList::iterator QLinkedList QLinkedList::const_iterator QLinkedList::iterator QVector,QStack QVector::const_iterator QVector::iterator QSet QSet::const_iterator QSet::iterator QMap&lt;Key,T&gt;,QMultiMap&lt;Key,T&gt; QMap::const_iterator QMap::iterator QHash&lt;Key,T&gt;,QMultiHash&lt;Key,T&gt; QHash::const_iterator QHash::iterator QList&lt;int&gt; list; list&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5; QListIterator&lt;int&gt; it(list); while (it.hasNext()) &#123; qDebug()&lt;&lt;it.next(); &#125; 序列式容器QListQList模板提供了一个列表，实际上是一个指针数组，当项目数小于1000时，可以实现快速的插入删除操作 QList 是 Qt 的通用容器类之一。它将项目存储在一个列表中，该列表提供基于索引的快速访问和基于索引的插入和删除。QList、QLinkedList 和 QVector 提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。 使用概述： QVector 应该是您的默认首选。 QVector 通常会比 QList 提供更好的性能，因为 QVector 总是将其项按顺序存储在内存中，其中 QList 将在堆上分配它的项，除非 sizeof(T) &lt;&#x3D; sizeof(void *) 并且 T 已使用 Q_DECLARE_TYPEINFO 声明为 Q_MOVABLE_TYPE 或 Q_PRIMITIVE_TYPE。 然而，QList 在整个 Qt API 被大量使用，用于传递参数和返回值。 使用 QList可以很方便的与这些 API 进行交互。 如果您需要一个真正的链表，它保证常量时间内插入列表，并且使用迭代器指向项而不是索引，那么请使用QLinkedList。 公有函数 添加数据 //支持流插入 QList&lt;int&gt;()&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5; void append(const T &amp;value) void append(const QList&lt;T&gt; &amp;value) void insert(int i, const T &amp;value) QList::iterator insert(QList::iterator before, const T &amp;value) void prepend(const T &amp;value) void push_back(const T &amp;value) void push_front(const T &amp;value) 获取数据 T &amp;back() const T &amp;back() const T &amp;first() const T &amp;first() const T &amp;front() const T &amp;front() const T &amp;last() const T &amp;last() const const T &amp;constFirst() const const T &amp;constLast() const //返回下标为i的元素，如果下标i不合法，则返回defaultValue T value(int i) const T value(int i, const T &amp;defaultValue) const const T &amp;at(int i) const T &amp;operator[](int i) const T &amp;operator[](int i) const //返回从位置pos开始的子列表。如果length为-1(默认)，则包含pos中的所有元素; QList&lt;T&gt; mid(int pos, int length = -1) const 删除数据 void clear() QList::iterator erase(QList::iterator pos) QList::iterator erase(QList::iterator begin, QList::iterator end) void pop_back() void pop_front() //删除元素 int removeAll(const T &amp;value) bool removeOne(const T &amp;value) void removeAt(int i) void removeFirst() void removeLast() //删除元素并返回它，如果不使用返回值，removeAt()会更高效 T takeAt(int i) T takeFirst() T takeLast() 查找&#x2F;替换 //返回value在列表中第一次出现的索引位置，从索引位置from向前搜索。 如果没有匹配的项，则返回-1。 int indexOf(const T &amp;value, int from = 0) const //返回value在列表中最后一次出现的索引位置，从索引位置from反向搜索。如果from是-1(默认值)，则搜索从最后一项开始。如果没有匹配的项，则返回-1。 int lastIndexOf(const T &amp;value, int from = -1) const //将索引位置为i的项替换为value void replace(int i, const T &amp;value) //如果列表中包含值的出现，则返回true; 否则返回false。 该函数要求值类型具有operator==()的实现。 bool contains(const T &amp;value) const 交换&#x2F;移动 //将索引位置from到索引位置to //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;] move(1,4)-&gt; [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;B&quot;, &quot;F&quot;] void move(int from, int to) void swap(QList&lt;T&gt; &amp;other) //交换下标i j的元素 void swapItemsAt(int i, int j) 判断函数 int count(const T &amp;value) const int count() const int size() const int length() const bool empty() const bool isEmpty() const //如果列表第一项/后一项等于value,则返回true; 否则返回false。 bool startsWith(const T &amp;value) const bool endsWith(const T &amp;value) const //预分配空间大小 void reserve(int alloc) 和其他容器互转 QSet&lt;T&gt; toSet() const std::list&lt;T&gt; toStdList() const QVector&lt;T&gt; toVector() const [static] QList&lt;T&gt; fromSet(const QSet&lt;T&gt; &amp;set) [static] QList&lt;T&gt; fromStdList(const std::list&lt;T&gt; &amp;list) [static] QList&lt;T&gt; fromVector(const QVector&lt;T&gt; &amp;vector) QStringListQStringList继承自QList。 它提供基于索引的快速访问以及快速插入和删除。 将字符串列表作为值参数传递既快速又安全。 QList的所有功能也适用于QStringList。 例如，可以使用isEmpty()来测试列表是否为空，还可以调用append()、prepend()、insert()、replace()、removeAll()、removeAt()、removeFirst()、removeLast()和removeOne()等函数来修改QStringList。 此外，QStringList提供了一些方便的函数，使处理字符串列表更容易: 判断是否包含某个字符串 bool contains(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const bool contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const bool contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const 过滤：返回包含子字符串str的所有字符串的列表 QStringList filter(const QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const QStringList filter(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const QStringList filter(const QRegExp &amp;rx) const QStringList filter(const QRegularExpression &amp;re) const 查找 //从左往右查找 int indexOf(const QRegExp &amp;rx, int from = 0) const int indexOf(QStringView str, int from = 0) const int indexOf(QLatin1String str, int from = 0) const int indexOf(QRegExp &amp;rx, int from = 0) const int indexOf(const QRegularExpression &amp;re, int from = 0) const //从右往左查找 int lastIndexOf(const QRegExp &amp;rx, int from = -1) const int lastIndexOf(QStringView str, int from = -1) const int lastIndexOf(QLatin1String str, int from = -1) const int lastIndexOf(QRegExp &amp;rx, int from = -1) const int lastIndexOf(const QRegularExpression &amp;re, int from = -1) const 连接：将QStringList中的所有字符串连接为一个字符串，每个元素由给定的分隔符(可以是空串)分隔。 //支持流插入 &lt;&lt; QString join(const QString &amp;separator) const QString join(QStringView separator) const QString join(QLatin1String separator) const QString join(QChar separator) const 删除：从QStringList中删除重复的元素。 返回已删除元素的数量。 int removeDuplicates() 替换：返回一个字符串列表，其中每个字符串在找到before文本时都将before文本替换为after文本 QStringList &amp;replaceInStrings(const QString &amp;before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive) QStringList &amp;replaceInStrings(QStringView before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive) QStringList &amp;replaceInStrings(const QString &amp;before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive) QStringList &amp;replaceInStrings(QStringView before, const QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive) QStringList &amp;replaceInStrings(const QRegExp &amp;rx, const QString &amp;after) QStringList &amp;replaceInStrings(const QRegularExpression &amp;re, const QString &amp;after) 排序：升序 void sort(Qt::CaseSensitivity cs = Qt::CaseSensitive) QLinkedList单链表 QVector//返回vector底层数组指针。只要不重新分配vector对象，指针就保持有效。 这个函数在将vector传递给接受普通c++数组的函数时非常有用。 T *data() const T *data() const //将value赋给向量中的所有项。 如果size不同于-1(默认值)，则vector的大小将被调整为size之前的大小。 QVector&lt;T&gt; &amp;fill(const T &amp;value, int size = -1) QStackT pop() void push(const T &amp;t) void swap(QStack&lt;T&gt; &amp;other) T &amp;top() const T &amp;top() const QQueue//删除队头并返回它 T dequeue() //将值t加到队尾 void enqueue(const T &amp;t) //返回队头的引用 T &amp;head() const T &amp;head() const void swap(QQueue&lt;T&gt; &amp;other) 关联式容器QMapQMap&lt;Key, T&gt; 是 Qt 的通用容器类之一。 它存储(键，值)对，并提供与键关联的值的快速查找。 QMap 和 QHash 提供非常相似的功能。 区别在于： QHash 提供比 QMap 更快的平均查找速度。 在迭代 QHash 时，项目是任意排序的。 使用 QMap，项目总是按键排序。 QHash 的键类型必须提供 operator&#x3D;&#x3D;() 和全局 qHash(Key) 函数。 QMap 的键类型必须提供 operator&lt;() 指定总顺序。 从 Qt 5.8.1 开始，使用指针类型作为键也是安全的，即使底层 operator&lt;() 不提供全序。 公有函数 添加数据 //插入新的键值对，如果已经有一个键为key的项，则该项的值将被value替换；如果有多个键为key的项，则最近插入的项的值将被value替换。 QMap::iterator insert(const Key &amp;key, const T &amp;value) QMap::iterator insert(QMap::const_iterator pos, const Key &amp;key, const T &amp;value) //插入新的键值对，如果在map中已经有一个具有相同键的项，这个函数将创建一个新的项 QMap::iterator insertMulti(const Key &amp;key, const T &amp;value) QMap::iterator insertMulti(QMap::const_iterator pos, const Key &amp;key, const T &amp;value) 获取数据 T &amp;first() const T &amp;first() const const Key &amp;firstKey() const const Key key(const T &amp;value, const Key &amp;defaultKey = Key()) const QList&lt;Key&gt; keys() const QList&lt;Key&gt; keys(const T &amp;value) const T &amp;last() const T &amp;last() const const Key &amp;lastKey() const //返回一个列表，该列表包含映射中的所有键。 在映射中出现多次的键在返回的列表中只出现一次。 QList&lt;Key&gt; uniqueKeys() const //将其他map中的所有项目插入到该map中。 QMap&lt;Key, T&gt; &amp;unite(const QMap&lt;Key, T&gt; &amp;other) const T value(const Key &amp;key, const T &amp;defaultValue = T()) const QList&lt;T&gt; values() const QList&lt;T&gt; values(const Key &amp;key) const T &amp;operator[](const Key &amp;key) const T operator[](const Key &amp;key) const 删除数据 void clear() QMap::iterator erase(QMap::iterator pos) int remove(const Key &amp;key) T take(const Key &amp;key) 查找 bool contains(const Key &amp;key) const /* 返回两个迭代器 迭代器1：是指向当前 map 容器中第一个大于或等于 key 的键值对的迭代器（lowerBound()）。 迭代器2：是指向当前 map 容器中第一个大于 key 的键值对的迭代器。（upperBound()） */ QPair&lt;QMap::iterator, QMap::iterator&gt; equal_range(const Key &amp;key) QPair&lt;QMap::const_iterator, QMap::const_iterator&gt; equal_range(const Key &amp;key) const QMap::iterator find(const Key &amp;key) QMap::const_iterator find(const Key &amp;key) const QMap::iterator lowerBound(const Key &amp;key) QMap::const_iterator lowerBound(const Key &amp;key) const QMap::iterator upperBound(const Key &amp;key) QMap::const_iterator upperBound(const Key &amp;key) const 判断 int count(const Key &amp;key) const int count() const int size() const bool empty() const bool isEmpty() const QMultiMap 插入和替换：插入新的键值对。 如果已经有一个键为key的项，则该项的值将被value替换。 如果有多个键为key的项，则最近插入的项的值将被value替换。 typename QMap&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value) QHash 添加数据 QHash::iterator insert(const Key &amp;key, const T &amp;value) QHash::iterator insertMulti(const Key &amp;key, const T &amp;value) 获取数据 const Key key(const T &amp;value) const const Key key(const T &amp;value, const Key &amp;defaultKey) const QList&lt;Key&gt; keys() const QList&lt;Key&gt; keys(const T &amp;value) const QList&lt;Key&gt; uniqueKeys() const QHash&lt;K, V&gt; &amp;unite(const QHash&lt;K, V&gt; &amp;other) const T value(const Key &amp;key) const const T value(const Key &amp;key, const T &amp;defaultValue) const QList&lt;T&gt; values() const QList&lt;T&gt; values(const Key &amp;key) const 删除数据 void clear() QHash::iterator erase(QHash::const_iterator pos) QHash::iterator erase(QHash::iterator pos) QPair&lt;QHash::iterator, QHash::iterator&gt; equal_range(const Key &amp;key) QPair&lt;QHash::const_iterator, QHash::const_iterator&gt; equal_range(const Key &amp;key) const int remove(const Key &amp;key) T take(const Key &amp;key) 查找 bool contains(const Key &amp;key) const QHash::iterator find(const Key &amp;key) QHash::const_iterator find(const Key &amp;key) const 判断 int count(const Key &amp;key) const int count() const int size() const bool empty() const QMultiHash继承自QHash typename QHash&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value) 案例 class Grade //班级 &#123; public: Grade(int number, const QString&amp; GradeName) :number(number),name(GradeName) &#123;&#125; friend QDebug operator&lt;&lt;(QDebug out, const Grade&amp; stu); friend bool operator==(const Grade&amp; left, const Grade&amp; right); friend uint qHash(const Grade&amp; stu, uint seed = 0); private: int number; //班级号 QString name; &#125;; QDebug operator&lt;&lt;(QDebug out, const Grade&amp; stu) &#123; out &lt;&lt; &quot;[&quot; &lt;&lt; stu.number &lt;&lt;&quot;,&quot; &lt;&lt; stu.name &lt;&lt; &quot;]&quot;; return out; &#125; bool operator==(const Grade&amp; left, const Grade&amp; right) &#123; return (left.number == right.number); &#125; uint qHash(const Grade&amp; stu, uint seed) &#123; return stu.number; &#125; int main(int argc, char *argv[]) &#123; QCoreApplication a(argc, argv); QHash&lt;Grade, QString&gt; hash; hash.insert(Grade(1403, &quot;安卓&quot;), &quot;张三&quot;); hash.insert(Grade(1406, &quot;苹果&quot;), &quot;李四&quot;); qDebug() &lt;&lt; hash; return a.exec(); &#125; QSet 添加数据 QSet::iterator insert(const T &amp;value) 获取数据 QList&lt;T&gt; values() const QList&lt;T&gt; toList() const 删除数据 void clear() QSet::iterator erase(QSet::const_iterator pos) QSet::iterator erase(QSet::iterator pos) bool remove(const T &amp;value) 查找 bool contains(const T &amp;value) const bool contains(const QSet&lt;T&gt; &amp;other) const QSet::const_iterator find(const T &amp;value) const QSet::iterator find(const T &amp;value) 其他 int count() const bool empty() const bool isEmpty() const int size() const 交集，差集，并集 //并集：ohter集合中不在这个集合中的每一项都被插入到这个集合中。 返回对该集合的引用。 QSet&lt;T&gt; &amp;unite(const QSet&lt;T&gt; &amp;other) //差集：从该集合中删除包含在ohter集合中的所有项。 返回对该集合的引用。 QSet&lt;T&gt; &amp;QSet::subtract(const QSet&lt;T&gt; &amp;other) //交集：从该集合中删除ohter集合中不包含的所有项。 返回对该集合的引用。 QSet&lt;T&gt; &amp;intersect(const QSet&lt;T&gt; &amp;other) //如果该集合与ohter集合至少有一个共同项，则返回true。 bool intersects(const QSet&lt;T&gt; &amp;other) const 算法直接使用STL中的算法 QtGlobalQt类的头文件都会包含该头文件，所以不用再显式定义了 T qAbs(const T &amp;t) //求绝对值 //返回value限定在min至max范围之内的值 const T &amp;qBound(const T &amp;min, const T &amp;val, const T &amp;max) //如果p1和p2近似相等，返回true bool qFuzzyCompare(double p1, double p2) bool qFuzzyCompare(float p1, float p2) //如果浮点数约等于0，返回true bool qFuzzyIsNull(double d) bool qFuzzyIsNull(float f) //返回无穷大的数 double qInf() //求最大值和最小值 const T &amp;qMax(const T &amp;a, const T &amp;b) const T &amp;qMin(const T &amp;a, const T &amp;b) //四舍五入到最近的整数 qint64 qRound64(double d) qint64 qRound64(float d) int qRound(double d) int qRound(float d) //获得Qt版本 const char *qVersion() QtMath常用函数qreal qAcos(qreal v) qreal qAsin(qreal v) qreal qAtan2(qreal y, qreal x) qreal qAtan(qreal v) int qCeil(qreal v) qreal qCos(qreal v) //角度转弧度 float qDegreesToRadians(float degrees) double qDegreesToRadians(double degrees) qreal qExp(qreal v) qreal qFabs(qreal v) int qFloor(qreal v) qreal qLn(qreal v) quint32 qNextPowerOfTwo(quint32 value) quint64 qNextPowerOfTwo(quint64 value) quint32 qNextPowerOfTwo(qint32 value) quint64 qNextPowerOfTwo(qint64 value) qreal qPow(qreal x, qreal y) float qRadiansToDegrees(float radians) double qRadiansToDegrees(double radians) qreal qSin(qreal v) qreal qSqrt(qreal v) qreal qTan(qreal v) 宏 宏 含义 M_E 自然对数的底 （欧拉数） M_LOG2E 以2为底e的对数 M_LOG10E 以10为底的e的对数 M_LN2 2的自然对数 M_LN10 10的自然对数 M_PI π M_PI_2 π&#x2F;2 M_PI_4 π&#x2F;4 M_1_PI 1&#x2F;π M_2_PI 2&#x2F;π M_2_SQRTPI 2除以π的平方根，2 &#x2F;√π M_SQRT2 根号2 M_SQRT1_2 1&#x2F;√π","categories":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"}]},{"title":"Rust(1)","slug":"Rust(1)","date":"2022-08-31T10:39:55.000Z","updated":"2022-09-30T07:52:32.646Z","comments":true,"path":"2022/08/31/Rust(1)/","link":"","permalink":"http://goskp.github.io/2022/08/31/Rust(1)/","excerpt":"","text":"参考视频: Rust编程语言入门教程（Rust语言&#x2F;Rust权威指南配套) ahead-of-time语言 安装验证 rustc –version rust帮助文档: rustup doc 编译: rustc main.rs 在windows上还会生成一个.pdb文件 rustc只适合编译简单的rust程序 Cargo : cargo new hello_cargo 可以使用其他的VCS,或不适用VCS,cargo new 的时候使用 -vcs这个flag 代码的包称作crate cargo.toml Cargo构建项目 cargo build cargo.lock,不要乱动这个文件 构建和运行Cargo项目 cargo run cargo check 检查代码,确保能通过编译,但是不产生任何可执行文件 为发布构建 cargo build –release 尽量用Cargo [package] name = &quot;hello_cargo&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] rand = &quot;0.8.4&quot; use std::io; //prelude use std::cmp::Ordering; use rand::Rng; //trait fn main() &#123; println!(&quot;guess the number of bytes to read_line&quot;); let secret_number = rand::thread_rng().gen_range(1..1024); println!(&quot;secret number: &#123;&#125;&quot;, secret_number); let _res = 1; //mut可以改变 let mut guess = String::new(); //返回字符串新的实例 //new:创建一个空的字符串 //&amp; : 表示参数是引用类型 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); //io:Result Ok, Err //&#123;&#125;: 占位符, 对应后面变量的值 let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;); println!(&quot;number: &#123;&#125;&quot;,guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; println!(&quot;To Win!&quot;), &#125; &#125; use rand::Rng; use std::cmp::Ordering; use std::io; //prelude //trait fn main() &#123; let secret_number = rand::thread_rng().gen_range(1..1024); loop &#123; println!(&quot;guess the number of bytes to read_line&quot;); let mut guess = String::new(); //返回字符串新的实例 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); let guess: u32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; println!(&quot;number: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; &#123; println!(&quot;To Win!&quot;); break; &#125; &#125; &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://goskp.github.io/tags/Rust/"}]},{"title":"数据结构-回溯法(DP,Queen)","slug":"数据结构-回溯法(DP,Queen)","date":"2022-07-22T08:19:29.000Z","updated":"2022-09-04T08:28:41.206Z","comments":true,"path":"2022/07/22/数据结构-回溯法(DP,Queen)/","link":"","permalink":"http://goskp.github.io/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%9E%E6%BA%AF%E6%B3%95(DP,Queen)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-动态规划(DP)","slug":"数据结构-动态规划(DP)","date":"2022-07-20T08:18:50.000Z","updated":"2022-09-04T08:28:26.255Z","comments":true,"path":"2022/07/20/数据结构-动态规划(DP)/","link":"","permalink":"http://goskp.github.io/2022/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(DP)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-排序算法(sort)","slug":"数据结构-排序算法(sort)","date":"2022-07-18T02:35:06.000Z","updated":"2022-09-04T08:11:47.442Z","comments":true,"path":"2022/07/18/数据结构-排序算法(sort)/","link":"","permalink":"http://goskp.github.io/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(sort)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 冒泡排序 思路:基于比较 循环比较相邻两个元素 如果不符合要求 就交换 最后那个已然符合要求 每次冒出来一个 所以循环 len-1 次 可以达成目标 void BubbleSort(int* arr, int len) &#123; for (int i = 0; i &lt; len - 1; ++i) &#123; for (int j = 0; j &lt; len - 1 - i; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; 选择排序 思路:每次选择最小的，放到应该放的位置 选 len-1 完事 void SelectSort(int* arr, int len) &#123; int min_idx; int tmp; for (int i = 0; i &lt; len - 1; ++i) &#123; min_idx = i; for (int j = i + 1; j &lt; len; ++j) &#123; min_idx = ((arr[min_idx] &lt; arr[j]) ? min_idx : j); &#125; tmp = arr[i]; arr[i] = arr[min_idx]; arr[min_idx] = tmp; // TraverArray(arr, len, false); &#125; &#125; 可以优化的选择排序(插入排序) 思路:把待排数组的第一个元素看成是一个有序数组,然后一个个的把其他元素插入到这个有序数组中去 临时存储待插入数据 从待插数据的前一个位置开始 从后往前找插入位置 没找到插入位置前 往后覆盖 找到插入位置 结束循环 然后待插数据覆盖当前位置 void InsertSort(int* arr, int len) &#123; int pre_idx; int current; for (int i = 1; i &lt; len; ++i) &#123; pre_idx = i - 1; current = arr[i]; while (pre_idx &gt;= 0 &amp;&amp; arr[pre_idx] &gt; current) &#123; arr[pre_idx + 1] = arr[pre_idx]; pre_idx--; &#125; arr[pre_idx + 1] = current; &#125; &#125; 希尔排序 思路:先分组 在组内做插入排序 一般是先分成 len&#x2F;2 组 然后分成 len&#x2F;2&#x2F;2 组 ​ 。。。。 ​ 2组 最后 1组 组的数量 我们称之为 步长 step： len&#x2F;2 len&#x2F;4 … 2 1 void ShellSort(int* arr, int len) &#123; for (int grap = len / 2; grap &gt; 0; grap /= 2) &#123; for (int i = grap; i &lt; len; ++i) &#123; int j = i; int current = arr[i]; while (j - grap &gt;= 0 &amp;&amp; current &lt; arr[j - grap]) &#123; arr[j] = arr[j - grap]; j = j - grap; &#125; arr[j] = current; &#125; &#125; &#125; 简单总结一下: 冒泡排序 每次冒出一个 选择排序 每次选出一个放到合适位置 插入排序 把左边一个元素看成一个有序数组 从第二个元素起把元素一个个的插入到有序数组中 希尔排序 按步长 分组 组内作插入排序 截止到目前,这四种基于比较的排序算法,都不稳定,数据一换,可能效率就会改变很多. 下面阐述一下分治思想二分查找: mid &#x3D; l + (r-l)&#x2F;2;分组排序 快速排序 把数据分成两组 左边的 比中间值小 右边的比中间值大 假定 a[l]是中间值 temp &#x3D; a[l] 循环让l和r并拢 如果l小于r 循环继续 循环判断 a[r] 是否大于temp 如果大于 r– 如果不大于 循环结束 循环结束后 a[l] &#x3D; a[r] 循环判断 a[l] 是否小于temp 如果小于 l++ 如果不小于 循环结束 循环结束后 a[r] &#x3D; a[l] l和r并拢后 temp覆盖 a[l] l和r并拢后 left - l 小于 temp l+1 到right 大于temp left到l 继续分组 l+1 到right 继续分组 直到 无法拆分 左边的继续分两组 右边的继续分两组 一直到无法分割为止 计数排序 void CountSort(int* arr, int len) &#123; int* count_arr = (int*)calloc(sizeof(int), 100); assert(count_arr); for (int i = 0; i &lt; len; ++i) &#123; count_arr[arr[i]]++; //把数据当做数组下标去记录当前数据的个数 &#125; int* sort_arr = (int*)malloc(sizeof(int) * len); assert(sort_arr); for (int i = 1; i &lt; 100; ++i) &#123; //求和 count_arr[i] += count_arr[i - 1]; &#125; //取数据 for (int i = len; i &gt; 0; --i) &#123; sort_arr[count_arr[arr[i - 1]] - 1] = arr[i - 1]; count_arr[arr[i - 1]]--; &#125; memcpy(arr, sort_arr, len * sizeof(int)); free(count_arr); free(sort_arr); &#125; 快速排序 //交换辅助函数 void Swap(int* arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; //改变基准 int Partition(int* arr, int left, int right) &#123; int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; ++i) &#123; if (arr[i] &lt; arr[pivot]) &#123; Swap(arr, i, index); index++; &#125; &#125; Swap(arr, pivot, index - 1); return index - 1; &#125; void Quick(int* arr, int left, int right) &#123; if (left &lt; right) &#123; int partition_index = Partition(arr, left, right); Quick(arr, left, partition_index - 1); Quick(arr, partition_index + 1, right); &#125; &#125; //统一接口 void QuickSort(int* arr, int len) &#123; Quick(arr, 0, len - 1); &#125; 归并排序 思路:把两个有序数组合并成一个有序数组 创建临时数组 一个个比较把两个有序数组中的元素逐个放到临时数组中 把剩下的放到临时数组中 临时数组覆盖待排序数组 /普通的归并排序 void BasicMerge(int* arr, int f_begin, int f_end, int s_begin, int s_end, int* new_arr) &#123; int index = f_begin; int f = f_begin; int s = s_begin; while (f &lt;= f_end &amp;&amp; s &lt;= s_end) &#123; if (arr[f] &lt;= arr[s]) &#123; new_arr[++index] = arr[++f]; &#125; else &#123; new_arr[++index] = arr[++s]; &#125; &#125; //处理剩下元素 while (f &lt;= f_end) &#123; new_arr[++index] = arr[++f]; &#125; while (s &lt;= s_end) &#123; new_arr[++index] = arr[++s]; &#125; // 1 2 3 3-1 = 2 其实元素有三个 memcpy(arr + f_begin, new_arr + f_begin, sizeof(int) * (s_end - f_begin + 1)); &#125; void Merge(int* arr, int left, int right, int* new_arr) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; Merge(arr, left, mid, new_arr); Merge(arr, mid + 1, right, new_arr); BasicMerge(arr, left, mid, mid + 1, right, new_arr); &#125; //统一接口 void MergeSort(int* arr, int len) &#123; int* tmp = (int*)malloc(sizeof(int) * len); Merge(arr, 0, len - 1, tmp); free(tmp); &#125; 基数排序与桶排序 基数排序思路:数组下标天然有序 限制超级多 只能是正整数 (如果有负数，转成正数先) 不能重复 需要特别注意空间 桶排序思路:先把数据分成若干个桶，然后桶内用其他排序方式排序，排完之后再合并 非常稳定 空间换时间 //获取当前数字的任意位上的数字 int GetPosNumber(int num, int pos) &#123; int tmp = 1; for (int i = 0; i &lt; pos - 1; ++i) &#123; tmp *= 10; &#125; return (num / tmp) % 10; &#125; //获取数组最大值 int GetMaxNumber(int* arr, int len) &#123; int max = arr[0]; for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; max = arr[i]; &#125; &#125; return max; &#125; //求最大值的位数 int GetMaxNumberCount(int num) &#123; int count = 1; while (num / 10) &#123; count++; num /= 10; &#125; return count; &#125; //桶排序 void BucketSort(int* arr, int len, int pos) &#123; int* bucket_arr[10] = &#123;NULL&#125;; for (int i = 0; i &lt; 10; i++) &#123; //初始化为0 如果数据中有0的数据，换一个标记 bucket_arr[i] = (int*)calloc(sizeof(int), len); assert(bucket_arr[i]); &#125; //装桶 for (int i = 0; i &lt; len; ++i) &#123; int index = GetPosNumber(arr[i], pos); for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[index][j] == 0) &#123; bucket_arr[index][j] = arr[i]; break; &#125; &#125; &#125; //出桶 int k = 0; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[i][j] != 0) &#123; arr[k] = bucket_arr[i][j]; bucket_arr[i][j] = 0; k++; &#125; &#125; &#125; &#125; //基数排序 void RadixSort(int* arr, int len) &#123; int max_num = GetMaxNumber(arr, len); int loop = GetMaxNumberCount(max_num); for (int i = 1; i &lt;= loop; ++i) &#123; BucketSort(arr, len, i); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-分而治之","slug":"数据结构-分而治之","date":"2022-07-17T08:18:25.000Z","updated":"2022-09-04T08:28:30.477Z","comments":true,"path":"2022/07/17/数据结构-分而治之/","link":"","permalink":"http://goskp.github.io/2022/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-贪心算法(graph)","slug":"数据结构-贪心算法(graph)","date":"2022-07-16T08:17:58.000Z","updated":"2022-09-04T08:28:46.279Z","comments":true,"path":"2022/07/16/数据结构-贪心算法(graph)/","link":"","permalink":"http://goskp.github.io/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95(graph)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-深度/广度优先(DFS,BFS)","slug":"数据结构-深度广度优先(DFS,BFS)","date":"2022-07-15T08:17:01.000Z","updated":"2022-09-04T08:29:11.486Z","comments":true,"path":"2022/07/15/数据结构-深度广度优先(DFS,BFS)/","link":"","permalink":"http://goskp.github.io/2022/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88(DFS,BFS)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-图(graph)","slug":"数据结构-图(graph)","date":"2022-07-13T08:16:30.000Z","updated":"2022-09-17T13:14:44.714Z","comments":true,"path":"2022/07/13/数据结构-图(graph)/","link":"","permalink":"http://goskp.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE(graph)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 边和顶点关系: 设n为顶点数,e为边或弧的条数 对无向图: 0 &lt;= e &lt;= n(n - 1)/2 有向图: 0 &lt;= e &lt;= n(n - 1) 对于有向图,每个顶点至多有n - 1条边与其他的n - 1个顶点相连,则n个顶点至多有n(n - 1)条边,但对于无向图,每条边连接2个顶点,故最多n(n - 1) / 2 矩阵法存储: //矩阵法存储有向带权图 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const int MAX = 10; typedef char VertexType[8]; //顶点类型 typedef int VRType; //权值描述 typedef struct Graph &#123; int arc_num; //边数 int vex_num; //顶点数 VertexType vertex[MAX]; //顶点数组 VRType matrix[MAX][MAX]; //权值 &#125; GRAPH, *LPGRAPH; //找顶点的序号 int SearchIndex(LPGRAPH p_graph, VertexType x) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; if (strcmp(p_graph-&gt;vertex[i], x) == 0) &#123; return i; &#125; &#125; return -1; &#125; LPGRAPH CreateGraph() &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); printf(&quot;input arc_num,ver_num:&quot;); scanf(&quot;%d%d&quot;, &amp;p_graph-&gt;arc_num, p_graph-&gt;vex_num); printf(&quot;input %d vex:&quot;, p_graph-&gt;vertex); //顶点数组 for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; scanf(&quot;%s&quot;, p_graph-&gt;vertex[i]); &#125; memset(p_graph-&gt;matrix, 0, sizeof(int) * 100); printf(&quot;input arc:&quot;); VertexType v1, v2; VRType vrt; //权值 for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; scanf(&quot;%s%s%d&quot;, v1, v2, &amp;vrt); //定位,找到在矩阵中的行列 int pos_row = SearchIndex(p_graph, v1); int pos_col = SearchIndex(p_graph, v2); p_graph-&gt;matrix[pos_row][pos_col] = vrt; &#125; return p_graph; &#125; //遍历图 void PrintGraph(LPGRAPH p_graph) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;\\t%s&quot;, p_graph-&gt;vertex[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;%s\\t&quot;, p_graph-&gt;vertex[i]); for (int j = 0; j &lt; p_graph-&gt;vex_num; ++j) &#123; printf(&quot;%d\\t&quot;, p_graph-&gt;matrix[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125; LPGRAPH CreateGraphByFile(const char* file_name) &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); FILE* read = fopen(file_name, &quot;r&quot;); fscanf(read, &quot;%d\\t%d\\n&quot;, &amp;p_graph-&gt;arc_num, &amp;p_graph-&gt;vex_num); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; fscanf(read, &quot;%s&quot;, p_graph-&gt;vertex[i]); &#125; fscanf(read, &quot;\\n&quot;); memset(p_graph-&gt;matrix, 0, sizeof(int) * 100); VertexType v1, v2; VRType vrt; //权值 for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; fscanf(read, &quot;%s\\t%s\\t%d\\n&quot;, v1, v2, &amp;vrt); //定位,找到在矩阵中的行列 int pos_row = SearchIndex(p_graph, v1); int pos_col = SearchIndex(p_graph, v2); p_graph-&gt;matrix[pos_row][pos_col] = vrt; &#125; fclose(read); return p_graph; &#125; int main(void) &#123; LPGRAPH p_graph = CreateGraphByFile(&quot;graph.txt&quot;); PrintGraph(p_graph); return 0; &#125; graph.txt: 5 5 A B C D E A B 1 A C 2 B C 3 C D 4 D E 5 邻接表存储: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; const int MAX = 10; typedef char VertexType[8]; typedef struct ArcNode &#123; int ver_index; struct ArcNode* p_next; &#125; NODE, *LPNODE; LPNODE CreateNode(int ver_index) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); p_new_node-&gt;ver_index = ver_index; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void MyPushFront(NODE** p_head_node, int ver_index) &#123; LPNODE p_new_node = CreateNode(ver_index); p_new_node-&gt;p_next = (*p_head_node); (*p_head_node) = p_new_node; &#125; //顶点信息 typedef struct VNode &#123; VertexType data; LPNODE first_node; &#125; VNODE, *LPVNODE, ARRAY[MAX]; //图 typedef struct graph &#123; int arc_num; int vex_num; ARRAY vertex; //结构体数组 &#125; GRAPH, *LPGRAPH; //定位 int SearchByVextex(LPGRAPH p_graph, VertexType x) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; if (strcmp(p_graph-&gt;vertex[i].data, x) == 0) &#123; return i; &#125; &#125; return -1; &#125; LPGRAPH CreateGraph() &#123; LPGRAPH p_graph = (LPGRAPH)malloc(sizeof(GRAPH)); printf(&quot;input arc_num,ver_num:&quot;); scanf(&quot;%d%d&quot;, &amp;p_graph-&gt;arc_num, &amp;p_graph-&gt;vex_num); printf(&quot;input %d vex:\\n&quot;, p_graph-&gt;vex_num); for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; scanf(&quot;%s&quot;, p_graph-&gt;vertex[i].data); p_graph-&gt;vertex[i].first_node = NULL; &#125; VertexType v1, v2; int pos_v1; int pos_v2; printf(&quot;input arc:\\n&quot;); for (int i = 0; i &lt; p_graph-&gt;arc_num; ++i) &#123; scanf(&quot;%s%s&quot;, v1, v2); pos_v1 = SearchByVextex(p_graph, v1); pos_v2 = SearchByVextex(p_graph, v2); MyPushFront(&amp;p_graph-&gt;vertex[pos_v1].first_node, pos_v2); MyPushFront(&amp;p_graph-&gt;vertex[pos_v2].first_node, pos_v1); &#125; return p_graph; &#125; void PrintGraph(LPGRAPH p_graph) &#123; for (int i = 0; i &lt; p_graph-&gt;vex_num; ++i) &#123; printf(&quot;%s\\t&quot;, p_graph-&gt;vertex[i].data); LPNODE p_move = p_graph-&gt;vertex[i].first_node; while (p_move) &#123; printf(&quot;%s--&gt;&quot;, p_graph-&gt;vertex[p_move-&gt;ver_index].data); p_move = p_move-&gt;p_next; &#125; printf(&quot;\\n&quot;); &#125; &#125; int main(void) &#123; LPGRAPH p_graph = CreateGraph(); PrintGraph(p_graph); return 0; &#125; /* input arc_num,ver_num:7 5 input 5 vex: A B C D E input arc: A B A D D C C B C E D E B E */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-红黑树(RB)","slug":"数据结构-红黑树(RB)","date":"2022-07-12T08:15:41.000Z","updated":"2022-09-04T08:28:39.294Z","comments":true,"path":"2022/07/12/数据结构-红黑树(RB)/","link":"","permalink":"http://goskp.github.io/2022/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91(RB)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-平衡二叉树(AVL)","slug":"数据结构-平衡二叉树(AVL)","date":"2022-07-11T08:15:25.000Z","updated":"2022-09-04T08:28:43.639Z","comments":true,"path":"2022/07/11/数据结构-平衡二叉树(AVL)/","link":"","permalink":"http://goskp.github.io/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-分支定界(C++描述)","slug":"数据结构-分支定界(C++描述)","date":"2022-07-10T08:14:33.000Z","updated":"2022-09-04T12:46:46.614Z","comments":true,"path":"2022/07/10/数据结构-分支定界(C++描述)/","link":"","permalink":"http://goskp.github.io/2022/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C(C++%E6%8F%8F%E8%BF%B0)/","excerpt":"","text":"#include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;limits&gt; #include &lt;queue&gt; #include &lt;vector&gt; typedef class Node &#123; public: Node(int index, int weight) : index(index), weight(weight) &#123;&#125; Node() : index(0), weight(0) &#123;&#125; Node(const Node&amp; object) : index(object.index), weight(object.weight) &#123;&#125; //优先队列的比较内容 friend bool operator&lt;(const Node&amp; one, const Node&amp; two) &#123; return one.weight &gt; two.weight; &#125; public: int index; //顶点 int weight; //权值 &#125; NODE; typedef class Path &#123; public: // std::numeric_limits&lt;int&gt;::max() 最大的正整数 Path() : index(0), weight(std::numeric_limits&lt;int&gt;::max()) &#123;&#125; public: int index; int weight; &#125; PATH; //求解最短路径 typedef class ShortPath &#123; public: ShortPath(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; object, int end) : edge(-1), end(end), node_count(object.size()), graph(object) &#123;&#125; void PrintPath(); void GetShortPath(); private: //矩阵 std::vector&lt;std::vector&lt;int&gt;&gt; graph; int node_count; //顶点数 const int edge; //权值 const int end; //结束位置 std::vector&lt;int&gt; path_index; //最短路径 int short_path; //最短路径的长度 &#125; SHORTPATH; void SHORTPATH::PrintPath() &#123; std::cout &lt;&lt; &quot;weight_min:&quot; &lt;&lt; short_path &lt;&lt; std::endl; std::cout &lt;&lt; &quot;path:&quot;; copy(path_index.begin(), path_index.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)); std::cout &lt;&lt; std::endl; &#125; void SHORTPATH::GetShortPath() &#123; std::vector&lt;PATH&gt; my_path(node_count); //初始化路径容器的大小 std::priority_queue&lt;NODE, std::vector&lt;NODE&gt;&gt; min_heap; //小顶堆 min_heap.push(NODE(0, 0)); //出口入队 while (true) &#123; NODE top = min_heap.top(); min_heap.pop(); if (top.index == end) &#123; break; &#125; for (int i = 0; i &lt; node_count; ++i) &#123; //剪枝过程 if (graph[top.index][i] != edge &amp;&amp; top.weight + graph[top.index][i] &lt; my_path[i].weight) &#123; min_heap.push(NODE(i, top.weight + graph[top.index][i])); my_path[i].index = top.index; my_path[i].weight = top.weight + graph[top.index][i]; &#125; &#125; if (min_heap.empty()) &#123; break; &#125; &#125; short_path = my_path[end].weight; int index = end; path_index.push_back(index); while (true) &#123; index = my_path[index].index; path_index.push_back(index); if (index == 0) &#123; break; &#125; &#125; &#125; int main(int argc, char** argv) &#123; const int size = 11; std::vector&lt;std::vector&lt;int&gt;&gt; graph(size); for (int i = 0; i &lt; size; ++i) &#123; graph[i].resize(size); &#125; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size; ++j) &#123; graph[i][j] = -1; &#125; &#125; //描述图 graph[0][1] = 2; graph[0][2] = 3; graph[0][3] = 4; graph[1][2] = 3; graph[1][5] = 2; graph[1][4] = 7; graph[2][5] = 9; graph[2][6] = 2; graph[3][6] = 2; graph[4][7] = 3; graph[4][8] = 3; graph[5][8] = 3; graph[5][6] = 1; graph[6][9] = 1; graph[6][8] = 5; graph[7][10] = 3; graph[8][10] = 2; graph[9][8] = 2; graph[9][10] = 2; SHORTPATH short_path(graph, 10); short_path.GetShortPath(); short_path.PrintPath(); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈夫曼树(tree)","slug":"数据结构-哈夫曼树(tree)","date":"2022-07-09T08:06:00.000Z","updated":"2022-09-04T08:28:36.054Z","comments":true,"path":"2022/07/09/数据结构-哈夫曼树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 哈夫曼树:","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉搜索树(tree)","slug":"数据结构-二叉搜索树(tree)","date":"2022-07-08T11:34:11.000Z","updated":"2022-09-04T08:29:01.257Z","comments":true,"path":"2022/07/08/数据结构-二叉搜索树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 描述二叉搜索树单一类型://处理二叉搜索树的数据 typedef struct DatePair &#123; int first; //比较准备 char second[20]; //字符串数据为例 &#125; DATA, *LPDATA; //二叉树结点类型 typedef struct TreeNode &#123; DATA data; struct TreeNode* p_left_child; struct TreeNode* p_right_child; &#125; NODE, *LPNODE; //二叉搜索树 BST typedef struct BinarySearchTree &#123; LPNODE p_root; //用一个根节点表述整个树 int tree_size; //结点个数 &#125; BST, *LPBST; 创建结点://创建结点 LPNODE CreateTreeNode(DATA data) &#123; LPNODE p_new_tree_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_tree_node) &#123; return NULL; &#125; p_new_tree_node-&gt;data = data; p_new_tree_node-&gt;p_left_child = NULL; p_new_tree_node-&gt;p_right_child = NULL; return p_new_tree_node; &#125; 描述二叉搜索树最初状态://描述二叉搜索树最初状态 LPBST CreateBinarySearchTree() &#123; LPBST p_binary_search_tree = (LPBST)malloc(sizeof(BST)); if (NULL == p_binary_search_tree) &#123; return NULL; &#125; p_binary_search_tree-&gt;p_root = NULL; p_binary_search_tree-&gt;tree_size = 0; return p_binary_search_tree; &#125; 万金油://万金油 int Size(LPBST p_tree) &#123; return p_tree-&gt;tree_size; &#125; int Empty(LPBST p_tree) &#123; return p_tree-&gt;tree_size == 0; &#125; 二叉搜索树的插入://二叉搜索树的插入 void InsertTreeNode(LPBST p_tree, DATA data) &#123; LPNODE p_new_tree_node = CreateTreeNode(data); //找合适的位置 LPNODE p_move = p_tree-&gt;p_root; LPNODE p_move_parent = NULL; while (NULL != p_move) &#123; p_move_parent = p_move; if (data.first &lt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_left_child; &#125; else if (data.first &gt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_right_child; &#125; else &#123; //相等采用覆盖的方式 strcpy(p_move-&gt;data.second, data.second); return; &#125; &#125; //分析查找结果 if (p_tree-&gt;p_root == NULL) &#123; p_tree-&gt;p_root = p_new_tree_node; &#125; else &#123; //如果不为NULL,考虑插在parent左边还是右边 if (p_move_parent-&gt;data.first &gt; data.first) &#123; p_move_parent-&gt;p_left_child = p_new_tree_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_new_tree_node; &#125; &#125; p_tree-&gt;tree_size++; &#125; 二叉搜索树的遍历:void PrintNode(LPNODE p_cur_node) &#123; printf(&quot;%d:%s\\n&quot;, p_cur_node-&gt;data.first, p_cur_node-&gt;data.second); &#125; //二叉搜索树中序遍历 void MidOrderBinaryTree(LPNODE p_tree) &#123; if (NULL != p_tree) &#123; MidOrderBinaryTree(p_tree-&gt;p_left_child); PrintNode(p_tree); MidOrderBinaryTree(p_tree-&gt;p_right_child); &#125; &#125; 查找树结点LPNODE SearchBST(LPBST p_tree, int first) &#123; LPNODE p_move = p_tree-&gt;p_root; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; if (p_move-&gt;data.first &gt; first) &#123; p_move = p_move-&gt;p_left_child; &#125; else &#123; p_move = p_move-&gt;p_right_child; &#125; &#125; return p_move; &#125; 测试数据:int main(int argc, char* argv[]) &#123; LPBST p_binary_search_tree = CreateBinarySearchTree(); DATA data[8] = &#123;10, &quot;倪妮&quot;, 18, &quot;睿睿&quot;, 3, &quot;王冰冰&quot;, 8, &quot;bug&quot;, 12, &quot;gg&quot;, 2, &quot;MM&quot;, 7, &quot;HH&quot;, 4, &quot;王菲&quot;&#125;; for (int i = 0; i &lt; 8; ++i) &#123; InsertTreeNode(p_binary_search_tree, data[i]); &#125; MidOrderBinaryTree(p_binary_search_tree-&gt;p_root); LPNODE result = SearchBST(p_binary_search_tree,100); if (NULL == result) &#123; printf(&quot;未找到相关信息\\n&quot;); &#125; printf(&quot;18:%s\\n&quot;,SearchBST(p_binary_search_tree,18)-&gt;data.second); return 0; &#125; 二叉搜索树的删除://二叉搜索树的删除 void DeleteNode(LPBST p_tree, int first) &#123; LPNODE p_move = p_tree-&gt;p_root; LPNODE p_move_parent = NULL; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; p_move_parent = p_move; if (first &lt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_left_child; &#125; else if (first &gt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_right_child; &#125; else &#123; break; &#125; &#125; //分析结果 if (NULL == p_move) &#123; printf(&quot;无此处,删除失败\\n&quot;); return; &#125; else if (p_move-&gt;p_left_child != NULL &amp;&amp; p_move-&gt;p_right_child != NULL) &#123; //左右子树都健在的情况 LPNODE p_move_node = p_move-&gt;p_left_child; LPNODE p_move_node_parent = p_move; while (NULL != p_move_node-&gt;p_right_child) &#123; p_move_node_parent = p_move_node; p_move_node = p_move_node-&gt;p_right_child; &#125; LPNODE p_new_node = CreateTreeNode(p_move_node-&gt;data); p_new_node-&gt;p_left_child = p_move-&gt;p_left_child; p_new_node-&gt;p_left_child = p_move-&gt;p_right_child; //分类讨论父节点是否存在 if (NULL == p_move_parent) &#123; p_tree-&gt;p_root = p_new_node; &#125; else if (p_move == p_move_parent-&gt;p_left_child) &#123; p_move_parent-&gt;p_left_child = p_new_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_new_node; &#125; //调整二叉树 //改变删除指针的位置 if (p_move_node_parent == p_move) &#123; //调整的结点在左边 p_move_parent = p_new_node; &#125; else &#123; p_move_parent = p_move_node_parent; &#125; free(p_move); //原来的结点干掉 p_move = p_move_node; //删除指针调整到要调节的位置 &#125; //只有一边的情况的删除 LPNODE p_side_node = NULL; if (NULL != p_move-&gt;p_left_child) &#123; p_side_node = p_move-&gt;p_left_child; &#125; else &#123; p_side_node = p_move-&gt;p_right_child; &#125; if (p_tree-&gt;p_root == p_move) &#123; p_tree-&gt;p_root = p_side_node; &#125; else &#123; if (p_move == p_move_parent-&gt;p_left_child) &#123; p_move_parent-&gt;p_left_child = p_side_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_side_node; &#125; &#125; free(p_move); p_tree-&gt;tree_size--; &#125; 测试数据:printf(&quot;删除3结点:\\n&quot;); DeleteNode(p_binary_search_tree,3); printf(&quot;中序遍历二叉搜素树:\\n&quot;); MidOrderBinaryTree(p_binary_search_tree-&gt;p_root);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉树(tree)","slug":"数据结构-二叉树(tree)","date":"2022-07-07T00:26:46.000Z","updated":"2022-09-04T08:10:38.361Z","comments":true,"path":"2022/07/07/数据结构-二叉树(tree)/","link":"","permalink":"http://goskp.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 最容易想到的创建方法 先创建结点,在根据树结构链接树结点 //结构体描述 typedef struct TreeNode &#123; char data; struct TreeNode* p_left_child; struct TreeNode* p_right_child; &#125; TREE, *LPTREE; //暴力创建法 LPTREE CreateTreeNode(char data) &#123; LPTREE p_tree_node = (LPTREE)malloc(sizeof(TREE)); p_tree_node-&gt;data = data; p_tree_node-&gt;p_left_child = NULL; p_tree_node-&gt;p_right_child = NULL; return p_tree_node; &#125; //插入树 void InsertTreeNode(LPTREE p_parent, LPTREE p_left_child, LPTREE p_right_child) &#123; p_parent-&gt;p_left_child = p_left_child; p_parent-&gt;p_right_child = p_right_child; &#125; int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 递归遍历: //先序遍历 void PreOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; printf(&quot;%c\\t&quot;, p_root-&gt;data); PreOrderTree(p_root-&gt;p_left_child); PreOrderTree(p_root-&gt;p_right_child); &#125; &#125; //中序 void MidOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; MidOrderTree(p_root-&gt;p_left_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); MidOrderTree(p_root-&gt;p_right_child); &#125; &#125; //后序 void LastOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; LastOrderTree(p_root-&gt;p_left_child); LastOrderTree(p_root-&gt;p_right_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); &#125; &#125; 递归法创建二叉树//递归创建 void CreateTree(LPTREE* p_tree) &#123; char user_key = &#39;\\0&#39;; scanf(&quot;%c&quot;, &amp;user_key); if (user_key == &#39;#&#39;) &#123; *p_tree = NULL; &#125; else &#123; *p_tree = (TREE*)malloc(sizeof(TREE)); (*p_tree)-&gt;data = user_key; CreateTree(&amp;(*p_tree)-&gt;p_left_child); CreateTree(&amp;(*p_tree)-&gt;p_right_child); &#125; &#125; int main(int argc, char** argv) &#123; //测试数据:ABD#G###CE##F## LPTREE A = NULL; CreateTree(&amp;A); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 先序遍历:A B D G C E F 中序遍历:D G B A E C F 后序遍历:G D B E F C A 层次遍历://层次遍历,(队列) void LayerOrder(LPTREE p_root) &#123; //准备一个移动结点 LPTREE p_move = p_root; //准备一个队列 LPTREE p_queue[1024]; int front = 0; int tail = 0; p_queue[tail++] = p_move; printf(&quot;%c\\t&quot;, p_move-&gt;data); while (front != tail) &#123; //出队 p_move = p_queue[front++]; //如果有左子树,左子树入队,右子树同理 if (p_move-&gt;p_left_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_left_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_left_child-&gt;data); &#125; if (p_move-&gt;p_right_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_right_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_right_child-&gt;data); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); // LPTREE A = NULL; // CreateTree(&amp;A); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); printf(&quot;层次遍历:&quot;); LayerOrder(A); return 0; &#125; 非递归遍历(通过栈的方式): 先序: //非递归遍历 //先序遍历 // 1.一直走走左子树,边走边打印相关结点数据,ABD,把走过的结点入栈,不然回退不了,当前栈里元素:DBA // 2.p_move = D, 栈里还剩下BA, 出栈后,p_move走右边,做同样的事情 void PreOrderTreeByStack(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (stack_top != -1 || NULL != p_move) &#123; //往左边走,边走边打印,走过的路入栈 while (p_move) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_stack[++stack_top] = p_move; //走过的地方入栈 p_move = p_move-&gt;p_left_child; &#125; //出栈 if (stack_top != -1) &#123; p_move = p_stack[stack_top--]; //出站后往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 中序: //中序遍历的非递归方式 //左边一直走,不做打印,入栈即可 //出栈的时候,打印结点,再去找右边 void MidOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (NULL != p_move || stack_top != -1) &#123; while (p_move) &#123; //入栈 p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; if (stack_top != -1) &#123; //出栈 p_move = p_stack[stack_top--]; printf(&quot;%c\\t&quot;, p_move-&gt;data); //往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 后序: //后续非递归遍历 //把最后一次访问过的结点标注 void LastOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return NULL; &#125; LPTREE p_stack[1000]; int stack_top = -1; LPTREE p_move = p_root; LPTREE p_last_visit = NULL; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; while (stack_top != -1) &#123; p_move = p_stack[stack_top--]; // D if (p_move-&gt;p_right_child == NULL || p_move-&gt;p_right_child == p_last_visit) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_last_visit = p_move; &#125; else &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_right_child; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; &#125; &#125; &#125; 测试数据: int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;非递归前序遍历:&quot;); PreOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归中序遍历:&quot;); MidOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归后序遍历:&quot;); LastOrderTreeByStack(A); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-堆(heap)","slug":"数据结构-堆(heap)","date":"2022-07-06T04:50:51.000Z","updated":"2022-09-04T08:28:58.080Z","comments":true,"path":"2022/07/06/数据结构-堆(heap)/","link":"","permalink":"http://goskp.github.io/2022/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86(heap)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 系统堆: malloc, new出来的内存,可以随便拿,随便取人为堆: 引申出的一种特定堆,按照二叉树形式排列的一种堆大顶堆: 数组中依次插入元素: 从下标1开始依次插入元素, ++cur_size 形成二叉树形式: 父结点的下标等于孩子结点的一半 相邻的层数相比,上面的元素要比下面的大 描述大顶堆单一结构://存10个元素, 第0个位置不存放元素 const int g_MAX = 11; typedef struct &#123; int* p_heap_data; int heap_size; &#125; HEAP, *LPHEAP; 创建堆:LPHEAP CreateHeap() &#123; LPHEAP p_heap = (LPHEAP)malloc(sizeof(HEAP)); if (NULL == p_heap) &#123; return NULL; &#125; p_heap-&gt;heap_size = 0; p_heap-&gt;p_heap_data = (int*)malloc(sizeof(int) * g_MAX); return p_heap; &#125; 形成二叉树:void CreateBigHeap(LPHEAP p_heap, int cur_pos) &#123; while (cur_pos &gt; 1) &#123; int max = p_heap-&gt;p_heap_data[cur_pos]; //假设当前下标为最大元素 int parent_index = cur_pos / 2; //父结点的下标 //父结点与最大元素相比,如果当前元素大,就交换 if (max &gt; p_heap-&gt;p_heap_data[parent_index]) &#123; //父结点与当前结点元素交换 p_heap-&gt;p_heap_data[cur_pos] = p_heap-&gt;p_heap_data[parent_index]; p_heap-&gt;p_heap_data[parent_index] = max; //当前下标变为父结点 cur_pos = parent_index; &#125; else &#123; break; &#125; &#125; &#125; 向堆中插入元素:void InsertHeap(LPHEAP p_heap, int new_data) &#123; if (p_heap-&gt;heap_size == g_MAX - 1) &#123; return; &#125; //直接插在当前下标 p_heap-&gt;p_heap_data[++p_heap-&gt;heap_size] = new_data; CreateBigHeap(p_heap, p_heap-&gt;heap_size); &#125; 遍历大顶堆:void PrintHeap(LPHEAP p_heap) &#123; for (int i = 1; i &lt;= p_heap-&gt;heap_size; ++i) &#123; printf(&quot;%d\\t&quot;, p_heap-&gt;p_heap_data[i]); &#125; putchar(&#39;\\n&#39;); &#125; 有序出堆://出堆 //先将堆顶,再找下面一层最大的依次抛出 int OutHeap(LPHEAP p_heap) &#123; int max = p_heap-&gt;p_heap_data[1]; //大顶堆第一个元素就是最大的 int cur_pos = 1; //当前下标 int child_pos = cur_pos * 2; //孩子结点序号 while (child_pos &lt;= p_heap-&gt;heap_size) &#123; int tmp = p_heap-&gt;p_heap_data[child_pos]; //每一层的第一个 //同一层上进行左右结点比较 if (child_pos + 1 &lt;= p_heap-&gt;p_heap_data &amp;&amp; //左边的元素小于右边的元素 tmp &lt; p_heap-&gt;p_heap_data[child_pos + 1]) &#123; tmp = p_heap-&gt;p_heap_data[++child_pos]; &#125; //向下去找 p_heap-&gt;p_heap_data[cur_pos] = tmp; cur_pos = child_pos; child_pos *= 2; &#125; p_heap-&gt;p_heap_data[cur_pos]=p_heap-&gt;p_heap_data[p_heap-&gt;heap_size]; --p_heap-&gt;heap_size; return max; &#125; int Size(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size; &#125; int Empty(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size == 0; &#125; //测试数据 int main(int argc, char** argv) &#123; srand((unsigned int)time(NULL)); LPHEAP p_heap = CreateHeap(); for (int i = 0; i &lt; 10; ++i) &#123; InsertHeap(p_heap, rand() % 100); &#125; printf(&quot;存储情况:&quot;); PrintHeap(p_heap); putchar(&#39;\\n&#39;); printf(&quot;堆排序:&quot;); while(!Empty(p_heap)) &#123; printf(&quot;%d\\t&quot;,OutHeap(p_heap)); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希表(hash)","slug":"数据结构-哈希表(hash)","date":"2022-07-05T10:06:58.000Z","updated":"2022-09-04T08:10:28.968Z","comments":true,"path":"2022/07/05/数据结构-哈希表(hash)/","link":"","permalink":"http://goskp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 链式结构描述哈希表// 保证有序性插入 //产生相同的就以当前结点为表头创建链表插在后面 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct DataType &#123; int key; char element[20]; &#125;; struct Node &#123; struct DataType data; struct Node* p_next; &#125;; struct Node* CreateNode(struct DataType data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //散列表结点的描述 struct SkipListNode &#123; struct DataType data; struct Node* p_first_node; //横向链表的第一个结点 struct SkipListNode* p_next; //纵向,第一列的链表链接 &#125;; struct SkipListNode* CreateSkipListNode(struct DataType data) &#123; struct SkipListNode* p_new_node = (struct SkipListNode*)malloc(sizeof(struct SkipListNode)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_first_node = NULL; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //描述哈希结构 struct ListHash &#123; struct SkipListNode* p_head_node; int hash_size; int divisor; &#125;; //创建哈希结构 struct ListHash* CreateHash(int divisor) &#123; struct ListHash* p_hash = (struct ListHash*)malloc(sizeof(struct ListHash)); if (NULL == p_hash) &#123; return NULL; &#125; p_hash-&gt;divisor = divisor; p_hash-&gt;hash_size = 0; p_hash-&gt;p_head_node = NULL; return p_hash; &#125; void InsertHash(struct ListHash* p_hash, struct DataType data) &#123; int data_hash_pos = data.key % p_hash-&gt;divisor; //变成散列表结点 struct SkipListNode* p_new_skip_node = CreateSkipListNode(data); //头结点为空,直接充当表头,无头链表 if (p_hash-&gt;p_head_node == NULL) &#123; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; return; &#125; else &#123; //头结点不为空 struct SkipListNode* p_move = p_hash-&gt;p_head_node; struct SkipListNode* p_move_left = NULL; //存在哈希冲突 //第一个结点的key大于元素的key:无表头链表的表头法插入 if (p_move-&gt;data.key % p_hash-&gt;divisor &gt; data_hash_pos) &#123; p_new_skip_node-&gt;p_next = p_hash-&gt;p_head_node; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; &#125; else &#123; //找到合适的位置,(找到了,没找到,相同的(键相同,hash地址相同)) //第一次大于要插入元素哈希地址的位置 while (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) &lt; data_hash_pos) &#123; p_move_left = p_move; p_move = p_move_left-&gt;p_next; &#125; //存在冲突,则插入到横向链表中 if (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) == data_hash_pos) &#123; if (p_move-&gt;data.key == data.key) &#123; //键相同采用覆盖的方式 strcpy(p_move-&gt;data.element, data.element); &#125; else &#123; //横向插入 struct Node* p_new_node = CreateNode(data); struct Node* p_move_ = p_move-&gt;p_first_node; if (NULL == p_move_left) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; //横向中冲突的元素是否存在相同的键 while (p_move_ != NULL &amp;&amp; p_move_-&gt;data.key != data.key) &#123; p_move_ = p_move_-&gt;p_next; &#125; if (NULL == p_move_) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; strcpy(p_move_-&gt;data.element, data.element); &#125; &#125; &#125; &#125; else &#123; //不存在冲突的情况,直接插在纵向链表中 p_move_left-&gt;p_next = p_new_skip_node; p_new_skip_node-&gt;p_next = p_move; p_hash-&gt;hash_size++; &#125; &#125; &#125; &#125; void PrintHash(struct ListHash* p_hash) &#123; struct SkipListNode* p_move = p_hash-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d:%s\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); //横向遍历 struct Node* p_move_ = p_move-&gt;p_first_node; while (NULL != p_move_) &#123; printf(&quot;%d:%s\\t\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); p_move_ = p_move_-&gt;p_next; &#125; putchar(&#39;\\n&#39;); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; struct ListHash* p_hash = CreateHash(10); struct DataType array[] = &#123; 1,&quot;王菲&quot;,12,&quot;刘亦菲&quot;,11,&quot;LZG&quot;,15,&quot;Baby&quot;,1,&quot;睿睿&quot; ,22,&quot;王菲&quot;,32,&quot;Oracle&quot;,56,&quot;LZG&quot;,75,&quot;Baby&quot;,80,&quot;睿睿&quot; &#125;; for (int i = 0; i &lt; 10; ++i) &#123; InsertHash(p_hash, array[i]); &#125; PrintHash(p_hash); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希存储(hash)","slug":"数据结构-哈希存储(hash)","date":"2022-07-05T09:12:58.000Z","updated":"2022-09-04T08:10:23.688Z","comments":true,"path":"2022/07/05/数据结构-哈希存储(hash)/","link":"","permalink":"http://goskp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss Hash基础(hash叫做哈希,又称为散列)哈希构造函数(用来求hash地址的,不是指针),人为的地址 取余法: h(k) &#x3D; k % p h(key) &#x3D; key % p p &#x3D; 10(p由自己决定) h(10) &#x3D; 10 % 10 &#x3D; 0; h(14) &#x3D; 14 % 10 &#x3D; 4; 直接定址: h(k) &#x3D; k array[12] &#x3D; 12; array[13] &#x3D; 13 随机数法: rand(); 哈希冲突: 不同的元素会产生相同的哈希地址 如何处理哈希冲突 开放地址法: 产生冲突的元素存放到空的空间中 邻接表-&gt;图: 在冲突位置创建一个链表 任何有冲突的元素都存到此链表中 数组描述Hash结构:为数据构建关键字:typedef struct Pair &#123; int hash_address; //为数据构建一个关键字,用来产生hash地址 char element[20]; &#125; DATA, *LPDATA; Hash结构:typedef struct HashTable &#123; LPDATA* table; //注意这里是二级指针 int divisor; //除数, 采用取余法 key%p, p就是divisor int hash_size; //当前元素个数 &#125; HASH, *LPHASH; 创建Hash表LPHASH CreateHash(int divisor) &#123; LPHASH p_hash_table = (LPHASH)malloc(sizeof(HASH)); if (NULL == p_hash_table) &#123; return NULL; &#125; //初始化hash表 p_hash_table-&gt;hash_size = 0; p_hash_table-&gt;divisor = divisor; //动态内存申请HashTable p_hash_table-&gt;table = (LPDATA*)malloc(sizeof(LPDATA) * p_hash_table-&gt;divisor); // p_hash_table[i]:一级指针 for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; p_hash_table-&gt;table[i] = NULL; &#125; return p_hash_table; &#125; 获取Hash地址:int SearchHashAddress(LPHASH p_hash_table, int data_address) &#123; //因为存在哈希地址,所以我这里单独封装一个函数做这个事情 int pos = data_address % p_hash_table-&gt;divisor; int cur_pos = pos; //查找结束的结果 do &#123; //没有值就可以存到里面 if (p_hash_table-&gt;table[cur_pos] == NULL || p_hash_table-&gt;table[cur_pos]-&gt;hash_address == data_address) &#123; return cur_pos; &#125; cur_pos = (cur_pos + 1) % p_hash_table-&gt;divisor; &#125; while (cur_pos != pos); return cur_pos; &#125; 向Hash表中插入数据:void InsertData(LPHASH p_hash_table, DATA data) &#123; //求出哈希地址 int pos = SearchHashAddress(p_hash_table, data.hash_address); if (p_hash_table-&gt;table[pos] == NULL) &#123; p_hash_table-&gt;table[pos] = (LPDATA)malloc(sizeof(DATA)); memcpy(p_hash_table-&gt;table[pos], &amp;data, sizeof(DATA)); p_hash_table-&gt;hash_size++; &#125; else &#123; //有元素 if (p_hash_table-&gt;table[pos]-&gt;hash_address == data.hash_address) &#123; //相同关键字采用覆盖方式 strcpy(p_hash_table-&gt;table[pos]-&gt;element, data.element); &#125; else &#123; printf(&quot;空间已满,无法插入\\n&quot;); return; &#125; &#125; &#125; 遍历Hash表与测试数据:void PrintHashTable(LPHASH p_hash_table) &#123; for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; if (p_hash_table-&gt;table[i] == NULL) &#123; printf(&quot;NULL\\n&quot;); &#125; else &#123; printf(&quot;%d:%s\\n&quot;, p_hash_table-&gt;table[i]-&gt;hash_address, p_hash_table-&gt;table[i]-&gt;element); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPHASH p_hash_table = CreateHash(10); DATA array[5] = &#123;1,&quot;刘亦菲&quot;,12,&quot;王菲&quot;, 11,&quot;王冰冰&quot;,15,&quot;Baby&quot;, 1,&quot;睿睿&quot;&#125;; for (int i = 0; i &lt; 5; ++i) &#123; InsertData(p_hash_table, array[i]); &#125; PrintHashTable(p_hash_table); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-简单封装string类(C++描述)","slug":"数据结构-封装string类(C++描述)","date":"2022-07-04T08:17:52.000Z","updated":"2022-09-04T08:31:44.856Z","comments":true,"path":"2022/07/04/数据结构-封装string类(C++描述)/","link":"","permalink":"http://goskp.github.io/2022/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B0%81%E8%A3%85string%E7%B1%BB(C++%E6%8F%8F%E8%BF%B0)/","excerpt":"","text":"my_string.h:#pragma once #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MyString &#123; public: MyString(); MyString(const char* str); MyString(const MyString&amp; object); ~MyString(); void operator=(const MyString&amp; object); MyString&amp; operator+(const MyString&amp; object); friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MyString&amp; object); friend istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; object); int size() const; int empty() const; char operator[](int index); //迭代器部分 char* begin(); char* end(); class iterator &#123; public: void operator=(char* pmove); bool operator!=(char* pmove); iterator&amp; operator++(); char operator*(); protected: char* pmove; &#125;; //比较部分 bool operator==(const MyString&amp; object); private: char* str; //存储字符串的指针 int curSize; //当前长度 // int capacity; //容量 &#125;; my_string.cpp:#include &quot;my_string.h&quot; MyString::MyString() &#123; this-&gt;curSize = 0; this-&gt;str = nullptr; &#125; MyString::MyString(const char* str) &#123; this-&gt;curSize = strlen(str); this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, str); &#125; MyString::MyString(const MyString&amp; object) &#123; this-&gt;curSize = object.curSize; this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, object.str); &#125; MyString::~MyString() &#123; if (str != nullptr) &#123; delete[] str; str = nullptr; &#125; &#125; void MyString::operator=(const MyString&amp; object) &#123; this-&gt;curSize = object.curSize; this-&gt;str = new char[this-&gt;curSize + 1]; strcpy_s(this-&gt;str, this-&gt;curSize + 1, object.str); &#125; MyString&amp; MyString::operator+(const MyString&amp; object) &#123; // MyString* p = new MyString(strcat(this-&gt;str,object.str)); char* temp = new char[this-&gt;curSize + object.curSize + 1]; memset(temp, 0, this-&gt;curSize + object.curSize + 1); //内存初始化 strcat(temp, this-&gt;str); strcat(temp, object.str); MyString* p = new MyString(temp); delete[] temp; return *p; &#125; int MyString::size() const &#123; return curSize; &#125; int MyString::empty() const &#123; return curSize == 0; &#125; char MyString::operator[](int index) &#123; return this-&gt;str[index]; &#125; char* MyString::begin() &#123; return this-&gt;str; &#125; char* MyString::end() &#123; return this-&gt;str + this-&gt;curSize + 1; &#125; bool MyString::operator==(const MyString&amp; object) &#123; return strcmp(this-&gt;str, object.str) == 0; &#125; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MyString&amp; object) &#123; out &lt;&lt; object.str; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MyString&amp; object) &#123; char temp[1024] = &quot;&quot;; in &gt;&gt; temp; object = MyString(temp); return in; &#125; void MyString::iterator::operator=(char* pmove) &#123; this-&gt;pmove = pmove; &#125; bool MyString::iterator::operator!=(char* pmove) &#123; return this-&gt;pmove != pmove; &#125; MyString::iterator&amp; MyString::iterator::operator++() &#123; this-&gt;pmove++; return *this; &#125; char MyString::iterator::operator*() &#123; return this-&gt;pmove[0]; //等效 return *pmove; &#125; main:#include &lt;string&gt; #include &quot;my_string.h&quot; int main(int argc, char** argv) &#123; // No.1 MyString str1; MyString str2(&quot;ILoveyou&quot;); MyString str3 = str2; //拷贝构造---&gt;深拷贝 // No.2 MyString str4 = &quot;IMiss&quot;; MyString str5; str5 = str4; MyString result; result = str5 + str4; cout &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; str5 &lt;&lt; endl; MyString str6; cin &gt;&gt; str6; cout &lt;&lt; str6 &lt;&lt; endl; // No.3 支持下标 MyString array = &quot;IMissyou&quot;; for (int i = 0; i &lt; array.size(); i++) &#123; cout &lt;&lt; array[i]; &#125; cout &lt;&lt; endl; MyString info = &quot;sdfasdfs&quot;; MyString::iterator it; for (it = info.begin(); it != info.end(); ++it) &#123; cout &lt;&lt; *it; &#125; cout &lt;&lt; endl; cout &lt;&lt; (info == array) &lt;&lt; endl; cout &lt;&lt; (info == info) &lt;&lt; endl; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-串(string,BF,KMP)","slug":"数据结构-串(string,BF,KMP)","date":"2022-07-03T06:36:09.000Z","updated":"2022-09-04T08:10:03.001Z","comments":true,"path":"2022/07/03/数据结构-串(string,BF,KMP)/","link":"","permalink":"http://goskp.github.io/2022/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2(string,BF,KMP)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 串的基本操作(string)串结构:#define MAX_SIZE 1024 typedef struct &#123; char memory[MAX_SIZE]; //串的内存 int cur_size; //当前串的大小 &#125; STR, *LPSTR; 创建串: 初始化串 内存拷贝 更新串的长度 //创建一个串 LPSTR CreateStr(const char* str) &#123; //开内存 LPSTR p_str = (LPSTR)malloc(sizeof(STR)); //防止&#39;\\0&#39;的问题,这里我选择全初始化为&#39;\\0&#39; for (int i = 0; i &lt; MAX_SIZE; ++i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; //形参拷贝到串的内存 int count = 0; //串的长度 while (str[count] != &#39;\\0&#39;) &#123; p_str-&gt;memory[count] = str[count]; count++; &#125; //更新串的长度 p_str-&gt;cur_size = count; return p_str; &#125; 串的插入: 分两种方式 在串后面插新串(push_back) 在串中间插 注意:最后一个元素的下表是p_str-&gt;cursize - 1 (数组下标从0开始) pos是数组下标,这里写的是在pos的下一个位置进行插入 先腾位置(根据插入串的个数来决定) 插入点后面的元素要向后挪动len(插入进来的串长度)个位置 最后插入新串 //串的插入(在当前串插入多个元素) //pos是数组下标,这里写的是在pos的下一个位置进行插入 void InsertStrByPos(LPSTR p_str, const char* str, int str_len, int pos) &#123; //插在下标前面做减操作 // pos -= 1; if (pos &lt; 0 || pos &gt;= MAX_SIZE) &#123; printf(&quot;下标有误,无法插入\\n&quot;); return; &#125; //大于数组容量 if (p_str-&gt;cur_size + str_len &gt;= MAX_SIZE) &#123; printf(&quot;超出串的容量,无法插入\\n&quot;); return; &#125; //插在原来串的后面 if (pos &gt; p_str-&gt;cur_size) &#123; for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[p_str-&gt;cur_size++] = str[i]; &#125; &#125; else &#123; //腾位置 //从最后一个元素开始挪动(p_str-&gt;cursize - 1) for (int i = p_str-&gt;cur_size - 1; i &gt;= pos; i--) &#123; p_str-&gt;memory[str_len + i] = p_str-&gt;memory[i]; &#125; //插入新串 for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[pos + i] = str[i]; &#125; p_str-&gt;cur_size += str_len; &#125; &#125; 串的删除: 这里写的是区间删除,匹配删除在BF算法中在阐述 如何删除: 直接将后面的元素往前移动 置空后面的元素即可 void DeleteStrByIndex(LPSTR p_str, int start_idx, int end_idx) &#123; if (start_idx &lt;= 0 || start_idx &gt; end_idx || end_idx &gt; MAX_SIZE) &#123; printf(&quot;区间有误,无法删除\\n&quot;); return; &#125; int count = end_idx - start_idx + 1; //真实的区间元素个数 //后面的元素往前移动 for (int i = end_idx, j = start_idx - 1; i &lt; p_str-&gt;cur_size; ++i, ++j) &#123; p_str-&gt;memory[j] = p_str-&gt;memory[i]; &#125; //置空后面的元素 for (int i = p_str-&gt;cur_size; i &gt;= p_str-&gt;cur_size - count; --i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; p_str-&gt;cur_size -= count; &#125; 串的遍历: 也可以用%s //串的打印 void PrintStr(LPSTR p_str) &#123; for (int i = 0; i &lt; p_str-&gt;cur_size; ++i) &#123; printf(&quot;%c&quot;, p_str-&gt;memory[i]); &#125; putchar(&#39;\\n&#39;); &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str = CreateStr(&quot;ILoveyou&quot;); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;插在原来串的后面:\\n&quot;); InsertStrByPos(p_str, &quot;back&quot;, 4, p_str-&gt;cur_size); PrintStr(p_str); printf(&quot;插入XXX:\\n&quot;); InsertStrByPos(p_str, &quot;XXX&quot;, 3, 2); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;删除1-&gt;3的元素:\\n&quot;); DeleteStrByIndex(p_str, 1, 3); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); return 0; &#125; BF算法: 从父串中找字串,并返回字串的第一个元素位置 父串下标: i , 字串下标: j 从字串的第一个元素开始遍历,并与父串进行匹配 如果不匹配 将字串下标 j 归为0, 字串再从第一个元素与父串进行匹配,并将临时记录序号+1 如果字串的最后一个元素为’\\0’,证明找完了, 返回index + 1 验证的最好方法,代数即可 int BruteForce(LPSTR p_str_one, LPSTR p_str_two) &#123; int index = 0; //临时记录序号,用来返回找到的位置 int i = 0; int j = 0; while (p_str_one-&gt;memory[i] != &#39;\\0&#39; &amp;&amp; p_str_two-&gt;memory[j] != &#39;\\0&#39;) &#123; if (p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; //不匹配, 重新从第一个 ++index; i = index; j = 0; //换第二个位置又从父串第一个位置开始比 &#125; &#125; if (p_str_two-&gt;memory[j] == &#39;\\0&#39;) &#123; return ++index; &#125; return -1; &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str1 = CreateStr(&quot;abcabcacb&quot;); LPSTR p_str2 = CreateStr(&quot;abcac&quot;); printf(&quot;从第%d个元素开始匹配&quot;, BruteForce(p_str1, p_str2)); return 0; &#125; KMP算法: 基本概念: 字符串的”前缀”和”后缀” “前缀”指除了最后一个字符外,一个字符串的全部头部组合; “后缀”指除了第一个字符以外,一个字符串的全部尾组合. 以ABCDABD为例 前缀: A AB ABC ABCD ABCDA ABCDAB 后缀: BCDABD CDABD DABD ABD BD D 部分匹配表 每一个字串里去找前缀和后缀中相同的元素的长度 “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]， 共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]， 共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]， 共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]， 共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]， 共有元素的长度为0。 生成部分匹配表 //获取匹配值 void GetNext(LPSTR p_str, int next[]) &#123; int len = p_str-&gt;cur_size; //用的是数组下标 int i = 0; int j = -1; // 0在这里表示共同元素为0, 有具体的含义,所以初始化为-1了 next[0] = -1; while (i &lt; len) &#123; if (j == -1 || p_str-&gt;memory[i] == p_str-&gt;memory[j]) &#123; ++i; ++j; next[i] = j; //部分匹配元素的长度 &#125; else &#123; j = next[j]; //重置j为-1 &#125; &#125; &#125; int KMP(LPSTR p_str_one, LPSTR p_str_two, int next[]) &#123; //第一个得到表 GetNext(p_str_two, next); int i = 0; int j = 0; while (i &lt; p_str_one-&gt;cur_size &amp;&amp; j &lt; p_str_two-&gt;cur_size) &#123; if (j == -1 || p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (j == p_str_two-&gt;cur_size) &#123; return i - j; &#125; return -1; &#125; //测试数据 int main(int argc, char** argv) &#123; LPSTR p_str = CreateStr(&quot;ABCDABD&quot;); int next[8]; GetNext(p_str, next); for (int i = 0; i &lt; 8; ++i) &#123; printf(&quot;%d\\t&quot;, next[i]); &#125; putchar(&#39;\\n&#39;); LPSTR p_str_one = CreateStr(&quot;BBC ABCDAB ABCDABCDABDE&quot;); LPSTR p_str_two = CreateStr(&quot;ABCDABD&quot;); printf(&quot;第%d个元素开始匹配\\n&quot;, KMP(p_str_one, p_str_two, next)); putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-队列(queue)","slug":"数据结构-队列(queue)","date":"2022-07-02T07:38:29.000Z","updated":"2022-09-04T08:09:56.752Z","comments":true,"path":"2022/07/02/数据结构-队列(queue)/","link":"","permalink":"http://goskp.github.io/2022/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97(queue)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 队列(FIFO)先进先出const int g_MAX = 10; //队列大小 入队: 队尾往后走 队头不动 出队: 队头往后走 队尾不动 注意:如果做了一次入元素和出元素,会出现伪溢出问题,最大元素个数就不是g_MAX了如何避免伪溢出:做成循环队列通过取余的方式让队尾回到队头描述队列结构:typedef struct &#123; int* p_queue_memory; int q_front; //队头 int q_tail; //队尾 int q_size; //队列大小 &#125; QUEUE, *LPQUEUE; 用数组描述队列://入队 //只需要将数据存到数组中 void Push(LPQUEUE p_queue, int data) &#123; //判断队是否满,空 if (p_queue-&gt;q_tail &gt;= g_MAX || p_queue-&gt;p_queue_memory == NULL) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail++] = data; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_front &lt; p_queue-&gt;q_tail) &#123; p_queue-&gt;q_front++; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front]; &#125; //判断是否为空 int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; 数组描述循环队列:void Push(LPQUEUE p_queue, int data) &#123; if (p_queue-&gt;q_size == g_MAX) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail % g_MAX] = data; p_queue-&gt;q_tail++; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; p_queue-&gt;q_front = (p_queue-&gt;q_front + 1) % g_MAX; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front % g_MAX]; &#125; 链式描述队列:typedef struct &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct &#123; LPNODE p_front_node; //队尾 LPNODE p_tail_node; //队头 int q_size; &#125; QUEUE, *LPQUEUE; 创建结点: LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; 创建队列: LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(QUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; p_queue-&gt;p_front_node = NULL; p_queue-&gt;p_tail_node = NULL; p_queue-&gt;q_size = 0; return p_queue; &#125; 相关操作: //入队 //就是无表头链表的表尾法插入 void Push(LPQUEUE p_queue, int data) &#123; LPNODE p_new_node = CreateNode(data); if (0 == p_queue-&gt;q_size) &#123; p_queue-&gt;p_front_node = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; else &#123; p_queue-&gt;p_tail_node-&gt;p_next = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; p_queue-&gt;q_size++; &#125; //出队,表头法删除 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; LPNODE p_next_node = p_queue-&gt;p_front_node-&gt;p_next; free(p_queue-&gt;p_front_node); p_queue-&gt;p_front_node = p_next_node; p_queue-&gt;q_size--; &#125; &#125; int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_front_node-&gt;data; &#125; int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; void DeleteQueue(LPQUEUE p_queue) &#123; while (!Empty(p_queue)) &#123; Pop(p_queue); &#125; free(p_queue); p_queue = NULL; &#125; 优先队列://优先队列 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef int ElementType; #define g_MAX_SIZE 10 typedef struct &#123; int priority; //工作量 ElementType element; //队列中的元素 &#125; DataType; typedef struct &#123; int size; DataType memory[g_MAX_SIZE]; &#125; PQUEUE, *LPQUEUE; LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(PQUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; // p_queue = (DataType*)malloc(sizeof(DataType)); memset(p_queue-&gt;memory, 0, g_MAX_SIZE * sizeof(DataType)); p_queue-&gt;size = 0; return p_queue; &#125; int Empty(LPQUEUE p_queue) &#123; if (p_queue-&gt;size == 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; void Push(LPQUEUE p_queue, DataType data) &#123; if (p_queue-&gt;size &gt;= g_MAX_SIZE) &#123; return; &#125; else &#123; p_queue-&gt;memory[p_queue-&gt;size++] = data; &#125; &#125; void Pop(LPQUEUE p_queue, DataType* data) &#123; DataType min; int min_idx = 0; if (p_queue-&gt;size &lt;= 0) &#123; return; &#125; else &#123; min = p_queue-&gt;memory[0]; for (int i = 1; i &lt; p_queue-&gt;size; ++i) &#123; //当前作业量西小于原来的 if (p_queue-&gt;memory[i].priority &lt; min.priority) &#123; min = p_queue-&gt;memory[i]; min_idx = i; &#125; &#125; *data = p_queue-&gt;memory[min_idx]; //调整数组 for (int i = min_idx + 1; i &lt; p_queue-&gt;size; ++i) &#123; p_queue-&gt;memory[i - 1] = p_queue-&gt;memory[i]; min_idx = i; &#125; p_queue-&gt;size--; &#125; &#125; int main(int argc, char** argv) &#123; LPQUEUE p_queue = CreateQueue(); DataType tmp_data; FILE* fp = fopen(&quot;task.txt&quot;, &quot;r&quot;); while (!feof(fp)) &#123; fscanf(fp, &quot;%d\\t%d\\n&quot;, &amp;tmp_data.element, &amp;tmp_data.priority); Push(p_queue, tmp_data); &#125; int i = 1; //序号 printf(&quot;序号\\t任务\\t优先级啊\\n&quot;); while (!Empty(p_queue)) &#123; Pop(p_queue, &amp;tmp_data); printf(&quot;%d\\t%d\\t%d\\n&quot;, i, tmp_data.element, tmp_data.priority); i++; &#125; putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-栈(stack)","slug":"数据结构-栈(stack)","date":"2022-07-01T12:29:22.000Z","updated":"2022-09-04T08:29:14.832Z","comments":true,"path":"2022/07/01/数据结构-栈(stack)/","link":"","permalink":"http://goskp.github.io/2022/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88(stack)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 栈(FILO)先进后出 入栈 出栈 获取栈顶元素 数组栈: 封装栈单一结构 因为是用数组做的,这里定义一个变量表示数组大小 typedef int TYPE; const TYPE g_MAX = 100; typedef struct Stack &#123; TYPE* memory; //栈的容量 int top; //栈顶标记 &#125; STACK, *LPSTACK; 创建一个栈 用一个结构体指针表示栈 memory是指针变量,所以要二次申请内存 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (TYPE*)malloc(sizeof(TYPE) * g_MAX); p_stack-&gt;top = -1; //栈顶标记初始化为-1 return p_stack; &#125; 入栈操作 void PushStack(LPSTACK p_stack, TYPE data) &#123; if (NULL == p_stack || p_stack-&gt;top &gt;= g_MAX) &#123; //栈已满 return; &#125; p_stack-&gt;memory[++p_stack-&gt;top] = data; &#125; 出栈操作 void PopStack(LPSTACK p_stack) &#123; if (NULL == p_stack || p_stack-&gt;top == -1) &#123; return; &#125; //栈顶标记往0靠拢 p_stack-&gt;top--; &#125; 获取栈顶元素 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 栈是否为空 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 双端栈: 两个栈使用同一段内存 封装栈结构单一个体 typedef struct Stack &#123; int* memory; int stack_top[2]; //双端栈 &#125; STACK, *LPSTACK; //双端栈的方向 enum Direction &#123; left = 0, right = 1 &#125;; 创建栈 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (int*)malloc(sizeof(int) * g_MAX); p_stack-&gt;stack_top[0] = -1; ///左边 p_stack-&gt;stack_top[1] = g_MAX; //右边 return p_stack; &#125; 入栈 要清楚是左边还是右边 void Push(LPSTACK p_stack, int data, int direction) &#123; //左边的标记+1等于右边的标记就满了 if (p_stack-&gt;stack_top[0] + 1 == p_stack-&gt;stack_top[1]) &#123; printf(&quot;栈空间已满\\n&quot;); return; &#125; switch (direction) &#123; case left: p_stack-&gt;memory[++p_stack-&gt;stack_top[0]] = data; break; case right: p_stack-&gt;memory[--p_stack-&gt;stack_top[1]] = data; break; &#125; &#125; 出栈 void Pop(LPSTACK p_stack, int* data, int direction) &#123; switch (direction) &#123; case left: if (p_stack-&gt;stack_top[0] == -1) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[0]--]; break; case right: if (p_stack-&gt;stack_top[1] == g_MAX) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[1]++]; break; &#125; &#125; 链式栈 入栈:表头法插入 出栈:表头法删除 封装栈结构单一个体 typedef struct Node &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; 描述栈结构 typedef struct &#123; LPNODE p_stack_top; int size; &#125; STACK, *LPSTACK; 创建结点,创建栈 LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;p_stack_top = NULL; p_stack-&gt;size = 0; return p_stack; &#125; 入栈,出栈,获取栈顶元素 void Push(LPSTACK p_stack, int data) &#123; LPNODE p_new_node = CreateNode(data); //无头链表的表头法插入 p_new_node-&gt;p_next = p_stack-&gt;p_stack_top; p_stack-&gt;p_stack_top = p_new_node; p_stack-&gt;size++; &#125; //获取栈顶元素 int GetTop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; return p_stack-&gt;p_stack_top-&gt;data; &#125; return INT_MAX; &#125; //出栈 void Pop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; LPNODE p_next_node = p_stack-&gt;p_stack_top-&gt;p_next; //保存下一个结点 free(p_stack-&gt;p_stack_top); p_stack-&gt;p_stack_top = p_next_node; p_stack-&gt;size--; &#125; &#125; 括号匹配算法简单实现 //遇到左面的出栈,遇到右面的出栈 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int Match(char* str) &#123; char stak_memory[1024]; int top = -1; //栈顶标记 int i = 0; while (str[i] != &#39;\\0&#39;) &#123; if (str[i] == &#39;)&#39;) &#123; if (top &gt; -1) &#123; top--; &#125; else &#123; return -1; &#125; &#125; else if (str[i] == &#39;(&#39;) &#123; stak_memory[++top] = str[i]; &#125; i++; &#125; if (top == -1) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; int main(int argc, char** argv) &#123; while (1) &#123; char str[1024] = &quot;&quot;; gets(str); int res = Match(str); if (res == 0) &#123; printf(&quot;匹配\\n&quot;); &#125; else if (res == 1) &#123; printf(&quot;多了左边括号\\n&quot;); &#125; else &#123; printf(&quot;多了右边括号\\n&quot;); &#125; &#125; return 0; &#125; 进制转换 //栈应用:进制转化 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;stack&gt; int main(int argc, char** argv) &#123; int stack[100]; int top = -1; int num = 123; //入栈 while (num != 0) &#123; stack[++top] = num % 2; num /= 2; &#125; //出栈获取栈顶元素 while (top != -1) &#123; printf(&quot;%d&quot;, stack[top--]); &#125; putchar(&#39;\\n&#39;); std::stack&lt;int&gt; my_stack; num = 123; while (num != 0) &#123; my_stack.push(num % 2); num /= 2; &#125; while (!my_stack.empty()) &#123; std::cout &lt;&lt; my_stack.top(); my_stack.pop(); &#125; return 0; &#125; 寻路算法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //人物坐标属性 struct Position &#123; int row; int col; &#125;; //准备栈 struct Position path_stack[100]; // 100步 int stack_top = -1; //标记 //迷宫属性 int** maze = NULL; int size = 0; //创建二维数组 int** CreateArray(int row, int col) &#123; int** array = (int**)malloc(sizeof(int*) * row); for (int i = 0; i &lt; row; ++i) &#123; array[i] = (int*)malloc(sizeof(int) * col); &#125; return array; &#125; void CreateMaze() &#123; printf(&quot;输入迷宫大小:&quot;); scanf(&quot;%d&quot;, &amp;size); maze = CreateArray(size + 2, size + 2); printf(&quot;输入地图:\\n&quot;); for (int i = 1; i &lt;= size; ++i) &#123; for (int j = 1; j &lt;= size; ++j) &#123; scanf(&quot;%d&quot;, &amp;maze[i][j]); &#125; &#125; //边框 // size + 1是最大下标 //假设用 1 表示墙 for (int i = 0; i &lt;= size + 1; ++i) &#123; maze[0][i] = maze[size + 1][i] = 1; //第一行,最后一行 maze[i][0] = maze[i][size + 1] = 1; //第一列,最后一列 &#125; &#125; //寻路的过程 int FindPath() &#123; //准备位移变换 //用0-3表示四个方向 struct Position offset[4]; //往右走 offset[0].row = 0; offset[0].col = 1; //往下走 offset[1].row = 1; offset[1].col = 0; //左 offset[2].row = 0; offset[2].col = -1; //上 offset[3].row = -1; offset[3].col = 0; //选定入口 struct Position here = &#123;1, 1&#125;; //起始位置 maze[1][1] = 1; //下一个方向 int start_dir = 0; //起始方向设定为右边,顺时针转 int end_dir = 3; //终止方向 //出口&#123; size, size &#125; while (here.row != size || here.col != size) &#123; //记录变化 int row_num; int col_num; //试探 while (start_dir &lt;= end_dir) &#123; //行变化: 原位置 + 偏移值 row_num = here.row + offset[start_dir].row; col_num = here.col + offset[start_dir].col; //当试探出一条路,直接走,走过的要入栈 if (0 == maze[row_num][col_num]) &#123; break; //能走就退出循环 &#125; start_dir++; //不能走试探下一个方向 &#125; //能走: if (start_dir &lt;= end_dir) &#123; //走下一个,上一个位置入栈 path_stack[++stack_top] = here; here.row = row_num; here.col = col_num; //走过的地方堵上 maze[row_num][col_num] = 1; //重新试探 start_dir = 0; &#125; else &#123; //出栈 if (-1 == stack_top) &#123; return 0; &#125; //出栈 struct Position next = path_stack[stack_top--]; //方向的处理:要去的方向要改为原来试探过方向的下一个 //提高效率的操作 if (next.row == here.row) &#123; //把方向变成 1 或者 3 start_dir = 2 + next.col - here.col; &#125; else &#123; // 0 2 start_dir = 3 + next.row - here.row; &#125; here = next; &#125; &#125; return 1; &#125; //打印路径 void PrintPath() &#123; printf(&quot;路径:\\n&quot;); struct Position cur_pos; //栈不为空 while (stack_top != -1) &#123; cur_pos = path_stack[stack_top--]; //栈结构,路径是反向的 printf(&quot;(%d,%d)--&gt;&quot;, cur_pos.row, cur_pos.col); &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; CreateMaze(); if (FindPath()) &#123; PrintPath(); &#125; else &#123; printf(&quot;没有找到路径\\n&quot;); &#125; return 0; &#125; /* 测试数据: 输入迷宫大小:6 输入地图: 0 1 0 1 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 1 1 1 1 1 0 0 */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-顺序表(list)","slug":"数据结构-顺序表(list)","date":"2022-06-30T04:46:33.000Z","updated":"2022-09-04T08:09:36.415Z","comments":true,"path":"2022/06/30/数据结构-顺序表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 顺序表(有序插入结点)与链表大差不大,只是存一下代码,不做详细解释了, 链表如果理解的透彻,顺序表就如探囊取物数组描述: 元素容量: #define MAX 2 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; //序号 struct MM mm_data; &#125;; //顺序表的结构体 typedef struct SqList &#123; int sqlist_size; //顺序表中元素个数 struct Data* p_memory; &#125; SQLIST, *LPSQLIST; 创建顺序表: LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sqlist_size = 0; p_sqlist-&gt;p_memory = (struct Data*)malloc(sizeof(struct Data) * MAX); return p_sqlist; &#125; 开辟更多内存 void ReallocMemory(LPSQLIST p_sqlist, int cur_size, int new_size) &#123; printf(&quot;开辟更多内存\\n&quot;); int max_size = cur_size &gt; new_size ? cur_size : new_size; p_sqlist-&gt;p_memory = (struct Data*)realloc(p_sqlist-&gt;p_memory, sizeof(struct Data) * max_size); &#125; 结点插入顺序表 void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; //元素个数已满,内存重新申请为当前大小的两倍 if (MAX == p_sqlist-&gt;sqlist_size) &#123; ReallocMemory(p_sqlist, MAX, 2 * MAX); &#125; //直接插在表尾 p_sqlist-&gt;p_memory[p_sqlist-&gt;sqlist_size] = new_data; //调整位置 //后面的和前面的相比 for (int i = p_sqlist-&gt;sqlist_size; i &gt;= 0; --i) &#123; if (p_sqlist-&gt;p_memory[i - 1].index &gt; p_sqlist-&gt;p_memory[i].index) &#123; struct Data tmp = p_sqlist-&gt;p_memory[i - 1]; p_sqlist-&gt;p_memory[i - 1] = p_sqlist-&gt;p_memory[i]; p_sqlist-&gt;p_memory[i] = tmp; &#125; else &#123; break; &#125; &#125; //元素个数+1 p_sqlist-&gt;sqlist_size++; &#125; 删除顺序表 因为顺序表本身就有顺序,所以只需挪位置即可,移动元素 void DeleteData(LPSQLIST p_sqlist, int del_index) &#123; //找到删除元素的下标 int del_pos = -1; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; if (p_sqlist-&gt;p_memory[i].index == del_index) &#123; del_pos = i; break; &#125; &#125; //调整数组 if (del_pos == -1) &#123; printf(&quot;未找到指定元素&quot;); return; &#125; else &#123; //数组后面的元素往前移动 for (int i = del_pos; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; p_sqlist-&gt;p_memory[i] = p_sqlist-&gt;p_memory[i + 1]; &#125; //元素个数-1 p_sqlist-&gt;sqlist_size--; &#125; &#125; 遍历顺序表 void PrintSqList(LPSQLIST p_sqlist) &#123; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; printf(&quot;序号:%d\\t名字:%s\\t年龄:%d\\n&quot;, p_sqlist-&gt;p_memory[i].index, p_sqlist-&gt;p_memory[i].mm_data.name, p_sqlist-&gt;p_memory[i].mm_data.age); &#125; putchar(&#39;\\n&#39;); &#125; 链表描述: 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; struct MM mm_data; &#125;; typedef struct Node &#123; struct Data data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct SqList &#123; int sql_size; LPNODE p_head_node; &#125; SQLIST, *LPSQLIST; LPNODE CreateList() &#123; LPNODE p_head_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_head_node) &#123; return NULL; &#125; p_head_node-&gt;p_next = NULL; return p_head_node; &#125; LPNODE CreateNode(struct Data new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //创建顺序表 LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sql_size = 0; p_sqlist-&gt;p_head_node = CreateList(); return p_sqlist; &#125; void PrintSqList(LPSQLIST p_sqlist) &#123; LPNODE p_move = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d\\t姓名:%s\\t年龄:%d\\n&quot;, p_move-&gt;data.index, p_move-&gt;data.mm_data.name, p_move-&gt;data.mm_data.age); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //找到指定位置 LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index &lt; new_data.index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pre_node-&gt;p_next; &#125; // if (NULL == p_pos_node) &#123; // p_pre_node-&gt;p_next = p_new_node; // &#125; else &#123; // p_pre_node-&gt;p_next = p_new_node; // p_new_node-&gt;p_next = p_pos_node; // &#125; p_pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = p_pos_node; p_sqlist-&gt;sql_size++; &#125; void DeleteNode(LPSQLIST p_sqlist, int index) &#123; LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index != index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pos_node-&gt;p_next; &#125; if (NULL == p_pos_node) &#123; printf(&quot;未找到数据&quot;); return; &#125; else &#123; p_pre_node-&gt;p_next = p_pos_node-&gt;p_next; free(p_pos_node); p_pos_node = NULL; p_sqlist-&gt;sql_size--; &#125; &#125; 测试数据: LPSQLIST p_sqlist = CreateSqList(); struct Data array[4] = &#123;3, &quot;小红&quot;, 18, 1, &quot;小明&quot;, 14, 0, &quot;雨墨&quot;, 18, 2, &quot;小asd&quot;, 4&#125;; for (int i = 0; i &lt; 4; ++i) &#123; InsertData(p_sqlist, array[i]); &#125; PrintSqList(p_sqlist); printf(&quot;删除序号为3的结点:\\n&quot;); DeleteNode(p_sqlist, 3); PrintSqList(p_sqlist);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-合并,反转,有序链表(list)","slug":"数据结构-合并,反转,有序链表(list)","date":"2022-06-29T02:40:49.000Z","updated":"2022-09-04T08:09:22.146Z","comments":true,"path":"2022/06/29/数据结构-合并,反转,有序链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%90%88%E5%B9%B6,%E5%8F%8D%E8%BD%AC,%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 注意:阅读本篇博客前请先学会”基础单链表”找两个链表中的相同元素组成第三个链表如何合并: 遍历两个链表,找到相同元素 调用一种插入方式即可 插入方式 void InsertNode(struct Node* p_list, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); p_new_node-&gt;p_next = p_list-&gt;p_next; p_list-&gt;p_next = p_new_node; &#125; 取交集,将两个链表中的相同元素合并为第三个链表 void Intersection(struct Node* p_list_one, struct Node* p_list_two, struct Node* p_list_three) &#123; for (struct Node* p_first = p_list_one-&gt;p_next; NULL != p_first; p_first = p_first-&gt;p_next) &#123; for (struct Node* p_second = p_list_two-&gt;p_next; NULL != p_second; p_second = p_second-&gt;p_next) &#123; if (p_first-&gt;data == p_second-&gt;data) &#123; InsertNode(p_list_three, p_second-&gt;data); &#125; &#125; &#125; &#125; 反转链表 第一种方法: 创建一个临时链表 遍历当前链表,将结点逆序插入到临时链表中 释放原有链表内存 指向新链表 代码如下: //释放链表 void FreeList(struct Node** p_list) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_next_node = NULL; while (NULL != *p_list) &#123; p_next_node = (*p_list)-&gt;p_next; free(*p_list); *p_list = p_next_node; &#125; &#125; //反转链表第一种方法 void ReverseFirstWay(struct Node** p_list) &#123; struct Node* p_tmp_list = CreateList(); struct Node* p_move = (*p_list)-&gt;p_next; while (NULL != p_move) &#123; InsertNode(p_tmp_list, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; //释放原有的内存 FreeList(p_list); *p_list = p_tmp_list; //指向新的链表 &#125; 第二种方法(节省空间) 思路: 将每一个结点的p_next指针反转 第一个结点指向最后一个结点 实现: 第一个结点的前驱结点用空表示(p_pre_node &#x3D;&#x3D; NULL) 第一个结点的p_next指针指向前驱结点,而前驱结点是NULL,导致下一个结点就找不到了 所以在更改当前结点的指向之前应当先保存下一个结点(p_next_node &#x3D; p_cur_node-&gt;p_next;) 后面的结点也要做以上相同的事情 前驱结点变成当前结点 当前结点变成下一个结点 表头指向最后一个结点 实现代码如下: void ReverseSecondWay(struct Node** p_list) &#123; struct Node* p_pre_node = NULL; //前驱结点 struct Node* p_cur_node = (*p_list)-&gt;p_next; //当前结点 struct Node* p_next_node = (*p_list)-&gt;p_next; //当前结点的下一个结点 while (NULL != p_cur_node) &#123; p_next_node = p_cur_node-&gt;p_next; //保存下一个结点 p_cur_node-&gt;p_next = p_pre_node; //当前结点的p_next指针指向前驱结点 p_pre_node = p_cur_node; //前驱结点变成当前结点 p_cur_node = p_next_node; //当前结点变成下一个结点 &#125; (*p_list)-&gt;p_next = p_pre_node; //表头指向最后一个结点 &#125; 有序链表 再插入结点时让链表有序,这个比较简单,看一眼就可以了 /* @author: KaiPeng_Sun @Time: 2022年7月11日18:22:13 @brief: 有序链表 @message: 代码的上一行为所写注释 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-双向链表(list)","slug":"数据结构-双向链表(list)","date":"2022-06-28T02:34:06.000Z","updated":"2022-09-04T08:09:17.241Z","comments":true,"path":"2022/06/28/数据结构-双向链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 双向链表本篇博客中变量采用如下命名方式://结点类型,单一个体 typedef struct Node &#123; int data; struct Node* p_left; //指向左面的结点 struct Node* p_right; //指向右面的结点 &#125; NODE, *LPNODE; //链表类型 typedef struct List &#123; LPNODE p_head_node; //头结点 LPNODE p_tail_node; //尾结点 int size; //当前链表中结点个数 &#125; LIST, *LPLIST; 熟悉的套路:创建结点,创建链表//创建结点 LPNODE CreateNode(int new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_left = NULL; p_new_node-&gt;p_right = NULL; return p_new_node; &#125; //创建链表 LPLIST CreateList() &#123; LPLIST p_new_list = (LPLIST)malloc(sizeof(LIST)); if (NULL == p_new_list) &#123; return NULL; &#125; p_new_list-&gt;size = 0; p_new_list-&gt;p_head_node = NULL; p_new_list-&gt;p_tail_node = NULL; return p_new_list; &#125; 表头法插入,在有头结点前插入新节点 先判断链表中结点个数是否为空,为空则直接将头&#x2F;尾结点赋为新节点 链表不为空: 新节点的新节点的右指针指向头结点 头结点的左指针指向新结点 头结点变为新结点 结点个数+1 实现代码如下: void InsertNewNodeByHead(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; //链表为空 p_list-&gt;p_tail_node = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_right = p_list-&gt;p_head_node; p_list-&gt;p_head_node-&gt;p_left = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; p_list-&gt;p_head_node = p_new_node; //头结点变成新结点 p_list-&gt;size++; &#125; 表尾法插入,在尾结点后插入新结点 和表头法插入大同小异 void InsertNewNodeByTail(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; p_list-&gt;p_head_node = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_left = p_list-&gt;p_tail_node; p_list-&gt;p_tail_node-&gt;p_right = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; p_list-&gt;p_tail_node = p_new_node; p_list-&gt;size++; &#125; 指定位置插入 和单链表的指定位置插入类似 也是采用双结点遍历整个链表,因为两个结点能确定另一个结点 插入的方式: 前驱结点的右指针指向新结点 新结点的左指针指向前驱结点 新结点的右指针指向当前结点 当前结点的左指针指向新结点 结点个数+1 void InsertByPosData(LPLIST p_list, int new_data, int pos_data) &#123; LPNODE pos_front = NULL; LPNODE pos_node = p_list-&gt;p_head_node; //遍历寻找指定结点 while (NULL != pos_node &amp;&amp; pos_node-&gt;data != pos_data) &#123; pos_front = pos_node; pos_node = pos_front-&gt;p_right; &#125; if (NULL == pos_node) &#123; printf(&quot;未找到指定结点&quot;); return; &#125; else &#123; //表头法插入 if (NULL == pos_front) &#123; InsertNewNodeByHead(new_data, p_list); &#125; else &#123; //指定结点插入 LPNODE p_new_node = CreateNode(new_data); pos_front-&gt;p_right = p_new_node; p_new_node-&gt;p_left = pos_front; p_new_node-&gt;p_right = pos_node; pos_node-&gt;p_left = p_new_node; p_list-&gt;size++; &#125; &#125; &#125; 遍历双向链表(看一眼就行了,和单链表遍历一个道理) 顺序遍历 void OrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_tail_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125; 双向循环链表 这里我就写了一个表尾法插入,有时间在写别的,其实都大同小异 注意:不需要找表尾,表尾就是默认头结点的p_left指针所指向的位置 也就是说,我们用头结点来描述尾结点 如何插入: 头结点的左指针的结点的右指针指向新结点 新结点的左指针指向头结点的左指针指向的结点 新结点的右指针指向头结点 头结点的左指针指向新结点 void InsertNewNodeByTail(LPNODE p_head_node, int new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //换了一种方式表示表尾,用表头的左指针表示表尾 // p_head_node-&gt;p_left-&gt;p_right = p_new_node //也就是说表尾-&gt;p_right = p_new_node; p_head_node-&gt;p_left-&gt;p_right = p_new_node; p_new_node-&gt;p_left = p_head_node-&gt;p_left; // p_new_node-&gt;p_left = p_head_node-&gt;p_left // p_new_node-&gt;p_left等价于表尾 p_new_node-&gt;p_right = p_head_node; p_head_node-&gt;p_left = p_new_node; &#125; 遍历双向循环链表 因为是环形的,所以不能用老规矩(NULL结束遍历) 只需要遍历一圈,再走到头结点结束遍历即可 顺序遍历 void OrderPrintList(LPNODE p_head_node) &#123; //因为是环形的,所以不能用老规矩(NULL结束遍历) //只需要遍历一圈,再走到头结点结束遍历即可 LPNODE p_move = p_head_node-&gt;p_right; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPNODE p_head_node) &#123; LPNODE p_move = p_head_node-&gt;p_left; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-基础单链表(list)","slug":"数据结构-基础单链表(list)","date":"2022-06-27T12:54:15.000Z","updated":"2022-09-03T00:14:19.271Z","comments":true,"path":"2022/06/27/数据结构-基础单链表(list)/","link":"","permalink":"http://goskp.github.io/2022/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E5%8D%95%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 博客中所有关于链表的代码命名方式如下//结点类型 struct Node &#123; int data; struct Node* p_next; //指向下一个结点的结构体指针 &#125;; int new_data; //插入的新数据 struct Node* p_pre_node; //前驱结点 struct Node* p_cur_node; //当前结点 struct Node* p_new_node; //新节点 struct Node* p_move; //移动结构体指针,用于遍历链表 struct Node* p_list; //链表 struct Node** p_list; //链表 初识链表: //创建三个结点 struct Node node1 = &#123;1, NULL&#125;; struct Node node2 = &#123;2, NULL&#125;; struct Node node3 = &#123;3, NULL&#125;; //将结点连接在一起,形成链表 node1.p_next = &amp;node2; node2.p_next = &amp;node3; //遍历链表 struct Node* p_move = &amp;node1; printf(&quot;第一个节点数据:%d\\n&quot;, p_move-&gt;data); printf(&quot;第二个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;data); printf(&quot;第三个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;p_next-&gt;data); //上面不太方便，用循环来做 while (p_move != NULL) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; 链式结构基础操作 创建表头 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125; 创建新节点 有头和无头的区别就在于头结点的data有没有存放数据罢了 //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(int new_data) &#123; struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == new_node) &#123; return NULL; &#125; //初始化新结点 new_node-&gt;data = new_data; new_node-&gt;p_next = NULL; return new_node; &#125; 遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; 在头结点的前驱位置(头结点前面)插入新结点 新结点的p_next指针指向头结点 新结果点赋值给头结点 void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; 在头结点与下一个结点之间插入新结点 新节点的p_next指针指向头结点的p_next指针(换句话说就是新结点的p_next指针指向头结点的下一个结点) 头结点的p_next指针指向新结点 注意:这种插入方式会导致插入结点的顺序与遍历结点的顺序相反 void InsertNewNodeByHead(struct Node* p_head_node, int new_data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(new_data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; 在尾结点后插入新结点 遍历找到尾结点 尾结点的p_next指针指向新结点 void InsertNewNodeByTail(struct Node* p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); struct Node* p_tail_node = p_head_node; //找到尾结点 while (NULL != p_tail_node-&gt;p_next) &#123; p_tail_node = p_tail_node-&gt;p_next; &#125; //表尾法插入 p_tail_node-&gt;p_next = p_new_node; &#125; 指定位置插入(以数据作为参照),数据指data 遍历找到data(这里以第一次出现data终止遍历) 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByDataValue(struct Node* p_head_node, int data_value, int new_data) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; // 注意:条件不能交换(短路现象) // p_p_cur_node == NULL,NULL-&gt;data // 判断是否为所寻找的数据的前提是p_p_cur_node!=NULL while (p_cur_node != NULL &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_p_pre_node = p_p_pre_node-&gt;p_next; // p_p_cur_node = p_p_cur_node-&gt;p_next; // 下面的写法更能够体现相邻的特色 p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; //分析结果 if (NULL == p_cur_node) &#123; printf(&quot;没有找到指定结点,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 指定位置插入(以第几个结点作为参照) 注意: 若传入函数的下标为4,则是在3的位置插入 遍历找到指定位置 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByNodeIndex(struct Node* p_head_node, int node_index, int new_data) &#123; if (node_index &lt; 0) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); return; &#125; //因为是不存在第0个元素的 int count = 1; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != NULL &amp;&amp; count &lt; node_index) &#123; p_pre_node = p_cur_node; p_cur_node = p_cur_node-&gt;p_next; ++count; &#125; if (NULL == p_cur_node) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 删除头结点(实质是删除头结点的下一个结点) 头结点的p_next指针指向下一个结点的p_next指针 释放结点内存 结点置为空 void DeleteByHead(struct Node* p_head_node) &#123; struct Node* p_next_node = p_head_node-&gt;p_next; //防御性编程 if (NULL == p_head_node || NULL == p_next_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; else &#123; p_head_node-&gt;p_next = p_next_node-&gt;p_next; free(p_next_node); p_next_node = NULL; &#125; &#125; 删除尾结点 遍历找到尾结点 前驱结点的p_next指向空 释放尾结点内存 结点置为空 void DeleteByTail(struct Node* p_head_node) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_tail_node = p_head_node-&gt;p_next; if (NULL == p_head_node || p_tail_node == NULL) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_tail_node-&gt;p_next) &#123; p_pre_node = p_tail_node; p_tail_node = p_pre_node-&gt;p_next; &#125; //将尾结点置为空 p_pre_node-&gt;p_next = NULL; free(p_tail_node); p_tail_node = NULL; &#125; 通过data删除指定位置结点 遍历找到data 前驱结点的p_next指针指向当前结点的p_next指针 释放当前结点 结点置为空 void DeleteByNodeIndex(struct Node* p_head_node, int data_value) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; 寻找结点 遍历链表 返回struct Node* 类型结点 struct Node* SearchNode(struct Node* p_head_node, int data_value) &#123; struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; 删除所有相同的结点 void DeleteAllSameNode(struct Node* p_head_node, int data_value) &#123; while (NULL != SearchNode(p_head_node, data_value)) &#123; DeleteByNodeIndex(p_head_node, data_value); &#125; &#125; 销毁链表 传入二级指针 *p_head_node就代表一个结点 结点置为空 void DestoryList(struct Node** p_head_node) &#123; while (NULL != (*p_head_node)-&gt;p_next) &#123; DeleteByHead(*p_head_node); &#125; free(*p_head_node); *p_head_node = NULL; &#125; 没经过优化的版本(C风格)#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define IS_LIST 0 struct Node &#123; int data; struct Node* p_next; &#125;; #if IS_LIST struct List &#123; struct Node* p_root; &#125;; #endif #if IS_LIST void InitList(struct List* p_list); #endif struct Node* CreateNode(int new_data); #if IS_LIST void AppendNode(struct List* p_list, int new_data); #else void AppendNode(struct Node** p_head_node, int new_data); #endif #if IS_LIST void PrintList(struct List* p_list); #else void PrintList(struct Node* p_head); #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data); #endif #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data); #else void InsertPosNode(struct Node** head, int pos, int new_data); #endif void DeletePosNode(struct Node** p_head, int pos); void DeleteHeadNode(struct Node** p_head); int main(int argc, char** argv) &#123; #if IS_LIST struct List list; InitList(&amp;list); for (int i = 0; i &lt; 10; ++i) &#123; AppendNode(&amp;list, i); &#125; PrintList(&amp;list); #else struct Node* p_head = NULL; for (int i = 0; i &lt; 10; ++i) &#123; InsertNewNodeByHead(&amp;p_head, i); PrintList(p_head); &#125; InsertPosNode(&amp;p_head, 2, 666); PrintList(p_head); #endif return 0; &#125; #if IS_LIST void InitList(struct List* p_list) &#123; p_list-&gt;p_root = NULL; &#125; #endif struct Node* CreateNode(int new_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; #if IS_LIST void AppendNode(struct List* p_list, int new_data) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (p_list-&gt;p_root) &#123; struct Node* p_tmp = p_list-&gt;p_root; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; p_list-&gt;p_root = p_new_node; &#125; &#125; #else void AppendNode(struct Node** p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (*p_head_node) &#123; struct Node* p_tmp = *p_head_node; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; *p_head_node = p_new_node; &#125; &#125; #endif #if IS_LIST void PrintList(struct List* p_list) &#123; struct Node* p_tmp = p_list-&gt;p_root; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #else void PrintList(struct Node* p_head) &#123; struct Node* p_tmp = p_head; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; #endif //从head链表中找到pos结点并返回,找不到返回NULL struct Node* FindPos(struct Node* p_head_node, int pos) &#123; if (NULL == p_head_node) &#123; return NULL; &#125; struct Node* p_tmp = p_head_node; for (int i = 0; i &lt; pos; ++i) &#123; if (NULL == p_tmp) &#123; return NULL; &#125; p_tmp = p_tmp-&gt;p_next; &#125; return p_tmp; &#125; #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data) &#123;&#125; #else void InsertPosNode(struct Node** head, int pos, int new_data) &#123; if (NULL == *head) &#123; return; &#125; if (NULL == *head || 0 == pos) &#123; AppendNode(head, new_data); &#125; //这里我写的是以数组下标为基准插入,所以pos - 1 struct Node* p_tmp = FindPos(*head, pos - 1); struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_tmp-&gt;p_next; p_tmp-&gt;p_next = p_new_node; &#125; #endif //删除链表中第一个节点 void DeleteHeadNode(struct Node** p_head) &#123; if (NULL == p_head) &#123; return; &#125; //临时存储要删的节点 struct Node* p_del = *p_head; //*head 的下一个节点要成为新的头节点 *p_head = (*p_head)-&gt;p_next; //释放内存 free(p_del); &#125; //删除链表中第pos个节点 void DeletePosNode(struct Node** p_head, int pos) &#123; if (NULL == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(p_head); return; &#125; //临时存储pos节点地址 struct Node* p_del = FindPos(*p_head, pos); if (NULL == p_del) &#123; return; &#125; //先找到pos-1节点 struct Node* p_del_prev = FindPos(*p_head, pos - 1); if (NULL == p_del_prev) &#123; return; &#125; // pos-1节点的next指针指向pos的下一个节点 p_del_prev-&gt;p_next = p_del-&gt;p_next; //释放pos节点内存 free(p_del); &#125; 没经过优化的版本(C++风格)#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_next = nullptr; &#125; &#125;; Node* p_head; public: MyList() &#123; p_head = NULL; &#125; void AppendNode(const T&amp; new_data); //尾插 void AddNode(const T&amp; new_data); //头插 void InsertNode(int pos, int new_data); //中间插 void Traver(); //遍历 void DeletePosNode(int pos); //删除特定结点 void DeleteHeadNode(); //删除头结点 private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); Node* p_tmp = p_head; if (p_tmp) &#123; while (p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new; &#125; else &#123; p_head = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::AddNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); p_new-&gt;p_next = p_head; p_head = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::InsertNode(int pos, int new_data) &#123; if (pos &lt; 0) &#123; return; &#125; if (nullptr == p_head || 0 == pos) &#123; AddNode(new_data); &#125; Node* p_new = new Node(new_data); Node* p_prev = _FindPos(pos); p_new-&gt;p_next = p_prev-&gt;p_next; p_prev-&gt;p_next = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list: &quot;; while (p_tmp) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; &#39;\\n&#39;; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeletePosNode(int pos) &#123; if (nullptr == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(); return; &#125; Node* p_del_prev = _FindPos(pos - 1); if (nullptr == p_del_prev) &#123; return; &#125; Node* p_del = _FindPos(pos); if (nullptr == p_del) &#123; return; &#125; p_del_prev-&gt;p_next = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeleteHeadNode() &#123; if (nullptr == p_head) &#123; return; &#125; Node* p_del = p_head; p_head = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; typename MyList&lt;T&gt;::Node* MyList&lt;T&gt;::_FindPos(int pos) &#123; Node* p_pos = p_head; for (int i = 0; i &lt; pos; ++i) &#123; if (nullptr == p_pos) &#123; return nullptr; &#125; else &#123; p_pos = p_pos-&gt;p_next; &#125; &#125; return p_pos; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; list.InsertNode(5, 666); list.Traver(); list.DeleteHeadNode(); list.Traver(); list.DeletePosNode(5); list.Traver(); return 0; &#125; 双向循环链表(C++风格)具体请查看”双向链表”这篇博客#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; //指向下一个结点 Node* p_prev; //指向前一个结点 Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_prev = p_next = nullptr; &#125; &#125;; Node* p_head; Node* p_tail; public: MyList() &#123; p_tail = p_head = NULL; &#125; void AppendNode(const T&amp; new_data); void Traver(); private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; // 1 创建新结点 Node* p_new = new Node(new_data); if (p_tail) &#123; //不是空链表 //新结点连接到尾结点后 p_tail-&gt;p_next = p_new; p_new-&gt;p_prev = p_tail; //更新p_tail p_tail = p_new; //维持循环双链表结构 p_tail-&gt;p_next = p_head; p_head-&gt;p_prev = p_tail; &#125; else &#123; //空链表 p_head = p_tail = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list:&quot;; if (p_head == NULL) &#123; cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl; return; &#125; if (p_head == p_tail) &#123; cout &lt;&lt; p_head-&gt;data &lt;&lt; endl; return; &#125; while (p_tmp != p_tail) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; p_tail-&gt;data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; return 0; &#125; 基础链式结构的应用#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //美女类型 struct MM &#123; char name[20]; int age; int num; &#125;; //结点类型 struct Node &#123; // int data; struct MM data; struct Node* p_next; &#125;; //创建表头 struct Node* CreateHeadNode(); //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data); //遍历链表 void PrintList(struct Node* p_head_node); //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data); //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name); //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name); //菜单 void Menu(); //录入信息 void InsertMMData(struct Node* p_head_node); //查找信息 void SearchMMData(struct Node* p_head_node); //修改信息 void ModifyMMData(struct Node* p_head_node); //删除信息 void DeleteMMData(struct Node* p_head_node); //冒泡排序 void BubbleSort(struct Node* p_head_node); //选项 void KeyDown(struct Node* p_list); int main(int argc, char* argv[]) &#123; struct Node* p_list = CreateHeadNode(); while (1) &#123; Menu(); KeyDown(p_list); system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; return 0; &#125; //创建表头 struct Node* CreateHeadNode() &#123; struct Node* p_head_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_head_node) &#123; return NULL; &#125; //这里我写的是有头链表,表头不存储数据,所以不需要将data进行初始化 p_head_node-&gt;p_next = NULL; return p_head_node; &#125; //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化新结点 p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); while (NULL != p_move) &#123; printf(&quot;%s\\t%d\\t%d\\n&quot;, p_move-&gt;data.name, p_move-&gt;data.age, p_move-&gt;data.num); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; // while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_pre_node = p_cur_node; // p_cur_node = p_pre_node-&gt;p_next; // &#125; //相同返回0, while (NULL != p_cur_node &amp;&amp; strcmp(p_cur_node-&gt;data.name, p_mm_name)) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_move = p_head_node-&gt;p_next; // while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; // p_move = p_move-&gt;p_next; // &#125; while (NULL != p_move &amp;&amp; strcmp(p_move-&gt;data.name, p_mm_name)) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; void Menu() &#123; printf(&quot;-----------【MM管理系统】-------------\\n&quot;); printf(&quot;\\t\\t0.退出功能\\n&quot;); printf(&quot;\\t\\t1.录入信息\\n&quot;); printf(&quot;\\t\\t2.浏览信息\\n&quot;); printf(&quot;\\t\\t3.查找信息\\n&quot;); printf(&quot;\\t\\t4.修改信息\\n&quot;); printf(&quot;\\t\\t5.删除信息\\n&quot;); printf(&quot;\\t\\t6.排序显示\\n&quot;); printf(&quot;-------------------------------------\\n&quot;); printf(&quot;请输入(0-6):&quot;); &#125; //录入美女信息 void InsertMMData(struct Node* p_head_node) &#123; struct MM mm; printf(&quot;输入美女信息:&quot;); scanf(&quot;%s%d%d&quot;, mm.name, &amp;mm.age, &amp;mm.num); InsertNewNodeByHead(p_head_node, mm); &#125; void SearchMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入查找美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); printf(&quot;%s\\t%d\\t%d\\n&quot;, p_result-&gt;data.name, p_result-&gt;data.age, p_result-&gt;data.num); &#125; &#125; void ModifyMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入修改美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;重新输入美女的信息:&quot;); scanf(&quot;%s%d%d&quot;, p_result-&gt;data.name, &amp;p_result-&gt;data.age, &amp;p_result-&gt;data.num); printf(&quot;修改成功\\n&quot;); &#125; &#125; void DeleteMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入删除美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); DeleteByName(p_head_node, mm_name); &#125; void BubbleSort(struct Node* p_head_node) &#123; for (struct Node* p = p_head_node-&gt;p_next; p != NULL; p = p-&gt;p_next) &#123; for (struct Node* q = p_head_node-&gt;p_next; q != NULL; q = q-&gt;p_next) &#123; //按照年龄方式升序 if (q-&gt;p_next != NULL &amp;&amp; q-&gt;data.age &gt; q-&gt;p_next-&gt;data.age) &#123; struct MM tmp = q-&gt;data; q-&gt;data = q-&gt;p_next-&gt;data; q-&gt;p_next-&gt;data = tmp; &#125; &#125; &#125; PrintList(p_head_node); &#125; void KeyDown(struct Node* p_list) &#123; struct MM mm; int options = 0; scanf(&quot;%d&quot;, &amp;options); switch (options) &#123; case 0: printf(&quot;----退出----\\n&quot;); exit(0); break; case 1: printf(&quot;----录入----\\n&quot;); InsertMMData(p_list); break; case 2: printf(&quot;----浏览----\\n&quot;); PrintList(p_list); break; case 3: printf(&quot;----查找----\\n&quot;); SearchMMData(p_list); break; case 4: printf(&quot;----修改----\\n&quot;); ModifyMMData(p_list); break; case 5: printf(&quot;----删除----\\n&quot;); DeleteMMData(p_list); break; case 6: printf(&quot;-----排序----\\n&quot;); BubbleSort(p_list); break; default: printf(&quot;----error----\\n&quot;); break; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++可变参数模板","slug":"C++可变参数模板","date":"2022-06-26T10:15:05.000Z","updated":"2022-09-18T02:35:51.596Z","comments":true,"path":"2022/06/26/C++可变参数模板/","link":"","permalink":"http://goskp.github.io/2022/06/26/C++%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++折叠参数可变参数函数模板#include &lt;initializer_list&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt; using namespace std; /* 参数包： class ...Args 参数包展开： 1.递归方式展开参数包 2.采用列表的方式展开参数包 */ //递归终止条件 template &lt;class _Ty&gt; void print(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty, class... Args&gt; void print(_Ty head, Args... args) //&#123;1,&quot;string&quot;,1.3&#125; &#123; cout &lt;&lt; head &lt;&lt; &quot; &quot;; //头部 print(args...); //参数包中的参数 &#123;&quot;string&quot;,1.3&#125; // args... 抽一个参数出来充当head //当参数包中只有一个参数时候，不满足调用自身的条件 &#125; //采用列表的方式 template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; template &lt;class... Args&gt; void printArgs(Args... args) &#123; initializer_list&lt;int&gt;&#123;(printData(args), 0)...&#125;; cout &lt;&lt; endl; &#125; // printf函数 void my_printf(const char* str) &#123; while (*str) &#123; cout &lt;&lt; *str &lt;&lt; endl; &#125; &#125; template &lt;class _Ty, class... Args&gt; void my_printf(const char* str, _Ty value, Args... args) &#123; //%d %c while (*str) &#123; if (*str == &#39;%&#39; &amp;&amp; (*++str) != &#39;%&#39;) &#123; //格式控制字符时候，参数包解析 cout &lt;&lt; value; my_printf(*str ? ++str : str, args...); return; &#125; cout &lt;&lt; *str++; //原样字符，直接打印 &#125; &#125; int main(int argc, char** argv) &#123; print(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); print(&quot;string&quot;, 1.3); printArgs(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); printArgs(&quot;string&quot;, 1.3); my_printf(&quot;整数:%d,字符:%c,整数:%d,字符:%c&quot;, 123, &#39;A&#39;, 123, &#39;A&#39;); return 0; &#125; 可变参数模板类#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;tuple&gt; using namespace std; // No.1 采用继承+模板特化的方式展开参数包 template &lt;class... Args&gt; class Test; //递归终止，特化模板 template &lt;&gt; class Test&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Test&lt;_Ty, Args...&gt; : public Test&lt;Args...&gt; &#123; public: Test() &#123;&#125; //构造函数做参数包展开 Test(_Ty data, Args... args) : data(data), Test&lt;Args...&gt;(args...) &#123;&#125; //&#123;int,double,string&#125; Test&lt;int&gt; //&#123;double,string&#125; Test&lt;double&gt; //&#123;string&#125; Test&lt;string&gt; //访问数据 _Ty&amp; GetData() &#123; return data; &#125; Test&lt;Args...&gt;&amp; GetObject() &#123; return *this; &#125; protected: _Ty data; &#125;; void testFirst() &#123; Test&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetObject().GetData() &lt;&lt; endl; Test&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetObject().GetData() &lt;&lt; endl; &#125; // No.2 递归方式展开 template &lt;class... Args&gt; class Tup; //终止使用的特化模板 template &lt;&gt; class Tup&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Tup&lt;_Ty, Args...&gt; &#123; public: Tup() &#123;&#125; //参数包展开 Tup(_Ty data, Args... args) : data(data), args(args...) &#123;&#125; //数据访问 _Ty&amp; GetData() &#123; return data; &#125; Tup&lt;Args...&gt;&amp; GetArgs() &#123; return args; &#125; protected: _Ty data; Tup&lt;Args...&gt; args; &#125;; void testSecond() &#123; Tup&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetArgs().GetData() &lt;&lt; endl; Tup&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetArgs().GetData() &lt;&lt; endl; &#125; //统一接口 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Func)(int, int), int a, int b) &#123; //接口 cout &lt;&lt; Func(a, b) &lt;&lt; endl; &#125; int getValue(int a) &#123; return a; &#125; void print(int (*Func)(int), int a) &#123; //接口 cout &lt;&lt; Func(a) &lt;&lt; endl; &#125; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;sdfsd&quot; &lt;&lt; endl; &#125; operator int() &#123; return age; &#125; protected: int age; string name; &#125;; void testMM() &#123; MM mm(&quot;小芳&quot;, 19); int value = mm; //类的对象隐式转换 cout &lt;&lt; value &lt;&lt; endl; MM* pmm = new MM(&quot;ds&quot;, 19); auto func = &amp;MM::print; (pmm-&gt;*func)(); &#125; template &lt;class _Ty, class _TyF, class... Args&gt; class InterFace &#123; public: InterFace(_Ty* data, _TyF (_Ty::*func)(Args...)) : data(data), func(func) &#123;&#125; //重载 _TyF operator()(Args... args) &#123; return (data-&gt;*func)((args)...); &#125; protected: _Ty* data; //_Ty 类类型 _TyF (_Ty::*func)(Args...); //类中成员函数指针 &#125;; //统一创建接口 template &lt;class _Ty, class _TyF, class... Args&gt; InterFace&lt;_Ty, _TyF, Args...&gt; createObject(_Ty* data, _TyF (_Ty::*func)(Args...)) &#123; return InterFace&lt;_Ty, _TyF, Args...&gt;(data, func); &#125; struct Data &#123; void Func1(int i) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; void Func2(int i, int j) &#123; cout &lt;&lt; i + j &lt;&lt; endl; &#125; void Func3(int i, int j, int k) &#123; cout &lt;&lt; i * j * k &lt;&lt; endl; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; &#125;; void testInterFace() &#123; Data data; auto Func1 = createObject(&amp;data, &amp;Data::Func1); Func1(1); auto Func2 = createObject(&amp;data, &amp;Data::Func2); Func2(2, 3); auto Func3 = createObject(&amp;data, &amp;Data::Func3); Func3(2, 3, 4); auto Func4 = createObject(&amp;data, &amp;Data::Max); cout &lt;&lt; Func4(2, 3) &lt;&lt; endl; &#125; void print1(int a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; void print2(int a, int b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testFirst(); tuple&lt;int, string&gt; tup; testSecond(); testInterFace(); //多线程库 thread t1(print1, 1); t1.join(); thread t2(print2, 2, 3); t2.join(); return 0; &#125; C++随机数,比较鸡肋,直接用C语言的吧#include &lt;array&gt; #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;vector&gt; using namespace std; void testSeed() &#123; // NO.1 种子管理 seed_seq seed = &#123;1, 3, 4, 5, 6, 7, 8&#125;; cout &lt;&lt; &quot;size:&quot; &lt;&lt; seed.size() &lt;&lt; endl; array&lt;int, 7&gt; data; seed.param(data.begin()); //把种子拿出赋值 for (auto v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; // array&lt;int,7&gt; vec; //使用内部算法填充所提供序列的元素 // seed.generate(vec.begin(), vec.end()); ////for_each(vec.begin(), vec.end(), [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;); // for (auto v : vec) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; &#125; void RandValue() &#123; // 1.基操 //随机引擎--&gt;就是一个算法 //线性同余： x=(x*a+c)%m; //梅森旋转 default_random_engine e; //设置随机数种子 e.seed(chrono::high_resolution_clock::now().time_since_epoch().count()); //等同: e.seed((size_t)time(nullptr)); for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;随机数:&quot; &lt;&lt; e() % 10 &lt;&lt; endl; //控制范围和C语言一样，用区域方式 &#125; // 2.分布方式 uniform_int_distribution&lt;int&gt; duration(1, 6); cout &lt;&lt; &quot;uniform:&quot; &lt;&lt; duration(e) &lt;&lt; endl; //随机数范围在1-6之间 auto randFunc = bind(duration, e); cout &lt;&lt; &quot;1:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;2:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;3:&quot; &lt;&lt; randFunc() &lt;&lt; endl; // 3.其他引擎 // x=(x*a+c)%m; linear_congruential_engine&lt;unsigned int, 2, 4, 8&gt; ee; ee.seed((size_t)time(nullptr)); cout &lt;&lt; &quot;线性同余:&quot; &lt;&lt; ee() &lt;&lt; endl; //梅森旋转 mersenne_twister_engine&lt;size_t, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1&gt; eeee; //一般用直接用下面写法 mt19937_64 eeeee; cout &lt;&lt; &quot;梅森:&quot; &lt;&lt; eeeee() &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testSeed(); RandValue(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++正则表达式","slug":"C++正则表达式","date":"2022-06-24T09:10:54.000Z","updated":"2022-09-18T02:35:34.861Z","comments":true,"path":"2022/06/24/C++正则表达式/","link":"","permalink":"http://goskp.github.io/2022/06/24/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++正则库正则指的是一种规则，用来匹配，捕获，替换字符串(字符串处理方案) 特殊含义元字符^: 以字符作为字符串开的头, ^ 表示单个字符 $:以字符结尾 ，\\$表示单个字符 ():分组 &#121;&#x64;&#112;&#x61;&#106;&#106;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109; \\b: 字符串的边界 .: 除了\\n意外的任意一个字符 |:a|b a或者b [abc]: abc任意一个字符 [^abc]: abc之外的任意一个字符 [a-z]:任意一个小写字母 \\w: 任意字母数字下划线 [(0-9)(a-z)(A-Z)(_)] \\W: 字母数字下划线之外的字符 \\d: 任意一个数字 \\D:数字之外的任意一个字符 \\s: 空白符 量词元字符*:0次或者多次 [a-z]* {0,} +:1次或者多次 {1,} ?:0次或者1次 {0,1} {n}: 出现n次 {n,}: 至少出现n次 {n,m}: 至少有n到m个之间的字符 注意的问题: C&#x2F;C++中带\\的元字符一定改为\\\\ #include &lt;iostream&gt; #include &lt;regex&gt; #include &lt;string&gt; using namespace std; // No.1 匹配 void testMatch() &#123; // 1.1 先构造正则对象 // 1.2 调用 regex_match 返回true匹配，返回false不匹配 #if 0 while (1) &#123; string userName; cin &gt;&gt; userName; regex reg(&quot;^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$&quot;); bool result = regex_match(userName, reg); if (result == true) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; #endif //正则匹配一定完全匹配 string str = &quot;ILoveyou1314&quot;; regex reg(&quot;[a-z0-9]+&quot;); if (regex_match(str, reg)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg2(&quot;[a-z0-9]+&quot;, regex_constants::icase); //忽略大小写 if (regex_match(str, reg2)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg3(&quot;ILoveyou[0-9]+&quot;); if (regex_match(str, reg3)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; // No.2 截取 void testGetString() &#123; string str = &quot;ILoveyou1314IMiss520you999dsdsd999sds23234&quot;; // regex_search(string str,smatch result,regex reg); smatch result; //只要找到就结束 bool flag = regex_search(str, result, regex(&quot;\\\\d+&quot;)); if (flag) &#123; cout &lt;&lt; &quot;size:&quot; &lt;&lt; result.size() &lt;&lt; endl; for (int i = 0; i &lt; result.size(); i++) &#123; cout &lt;&lt; result.str() &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;前缀:&quot; &lt;&lt; result.prefix() &lt;&lt; endl; cout &lt;&lt; &quot;后缀:&quot; &lt;&lt; result.suffix() &lt;&lt; endl; &#125; //捕获所有满足的条件字符串 // sregex_iterator regex reg(&quot;\\\\d+&quot;); //得到满足条件 sregex_iterator pos(str.begin(), str.end(), reg); sregex_iterator end; //无参构造是结束流 while (pos != end) &#123; cout &lt;&lt; pos-&gt;str() &lt;&lt; &quot;\\t&quot;; pos++; &#125; cout &lt;&lt; endl; str = &quot;10,12,32,,,34,,34,34,6566,67,,67&quot;; // 0: 表示匹配 //-1:不匹配 regex reg2(&quot;,&quot;); sregex_token_iterator tpos(str.begin(), str.end(), reg2, -1); sregex_token_iterator tend; while (tpos != tend) &#123; cout &lt;&lt; tpos-&gt;str() &lt;&lt; &quot; &quot;; tpos++; &#125; cout &lt;&lt; endl; &#125; // No.3 替换 void testReplace() &#123; string str = &quot;ILoveyou******IMiss*******y*****o***u&quot;; regex reg(&quot;\\\\*+&quot;); // regex_replace(string str,regex regx,string content) //返回值是处理后的字符串 cout &lt;&lt; &quot;888:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;) &lt;&lt; endl; //控制替换 cout &lt;&lt; &quot;only one:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_first_only) &lt;&lt; endl; cout &lt;&lt; &quot;no copy:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_no_copy) &lt;&lt; endl; cout &lt;&lt; &quot;sed:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_sed) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // testMatch(); // testGetString(); testReplace(); return 0; &#125; C++日期时间库using nanoseconds = duration&lt;long long, nano&gt;; //纳秒 using microseconds = duration&lt;long long, micro&gt;; //微妙 using milliseconds = duration&lt;long long, milli&gt;; //毫秒 using seconds = duration&lt;long long&gt;; //秒 using minutes = duration&lt;int, ratio&lt;60&gt;&gt;; //分钟 using hours = duration&lt;int, ratio&lt;3600&gt;&gt;; //小时 #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; int main(int argc, char** argv) &#123; chrono::seconds one(1); // C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; return 0; &#125; 时钟 system_clock:系统时钟 steady_clock: 计时 high_resoulution_clock: 高精度时钟 时间点 time_point:时间点 from_time_t: time_t 的时间转换为time_point to_time_t: time_piont 转换为time_t #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; void GetTime() &#123; //获取当前系统时间 chrono::system_clock::time_point curTime = chrono::system_clock::now(); //用的时候: auto curTime=chrono::system_clock::now(); time_t tm_t = chrono::system_clock::to_time_t(curTime); cout &lt;&lt; &quot;日期:&quot; &lt;&lt; ctime(&amp;tm_t) &lt;&lt; endl; //格式化输出时间 tm* pCurTime = localtime(&amp;tm_t); cout &lt;&lt; put_time(pCurTime, &quot;%F %X&quot;) &lt;&lt; endl; cout &lt;&lt; &quot;时间戳:&quot; &lt;&lt; curTime.time_since_epoch().count() &lt;&lt; endl; &#125; void CountTime() &#123; chrono::steady_clock::time_point start = chrono::steady_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; chrono::steady_clock::time_point end = chrono::steady_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; void HightClock() &#123; auto start = chrono::high_resolution_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; auto end = chrono::high_resolution_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; #if 0 chrono::seconds one(1); //C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; #endif GetTime(); CountTime(); HightClock(); return 0; &#125; C+文件目录库C++17标准才有的东西，C++文件目录库分为三部分 file_status类: 文件状态 path类: 处理目录 directory_entry类： 访问遍历目录 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;string&gt; using namespace std; void TestPath() &#123; error_code temp; filesystem::create_directory(&quot;xxx&quot;, temp); //创建一个目录(文件夹) filesystem::create_directories(&quot;a/b&quot;); //创建多级目录 cout &lt;&lt; temp.message() &lt;&lt; endl; filesystem::create_directory(&quot;xxx/bbb&quot;); //创建一个目录(文件夹) // filesystem::path url(&quot;my_box&quot;); //构建一个path filesystem::path url = filesystem::current_path(); cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url &lt;&lt; endl; cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url.string() &lt;&lt; endl; cout &lt;&lt; &quot;根目录:&quot; &lt;&lt; url.root_directory() &lt;&lt; endl; cout &lt;&lt; &quot;相对路径:&quot; &lt;&lt; url.relative_path() &lt;&lt; endl; cout &lt;&lt; &quot;根名：&quot; &lt;&lt; url.root_name() &lt;&lt; endl; cout &lt;&lt; &quot;根路径:&quot; &lt;&lt; url.root_path() &lt;&lt; endl; &#125; void DemoStatus(filesystem::file_status object) &#123; switch (object.type()) &#123; case filesystem::file_type::regular: cout &lt;&lt; &quot;磁盘文件&quot; &lt;&lt; endl; break; case filesystem::file_type::directory: cout &lt;&lt; &quot;目录文件&quot; &lt;&lt; endl; break; case filesystem::file_type::not_found: cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; break; case filesystem::file_type::unknown: cout &lt;&lt; &quot;无法识别文件&quot; &lt;&lt; endl; break; &#125; &#125; void TestStatus() &#123; filesystem::create_directory(&quot;fileBox&quot;); DemoStatus(filesystem::status(&quot;fileBox&quot;)); fstream file(&quot;fileBox/file&quot;, ios::out | ios::trunc); DemoStatus(filesystem::status(&quot;fileBox/file&quot;)); &#125; // directory_entry // directory_iterator // 1.遍历当前目录下所有文件夹(一层) void tarverseDirectory() &#123; filesystem::path url(&quot;./test&quot;); if (!filesystem::exists(url)) &#123; cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; return; &#125; filesystem::directory_iterator list(url); for (auto v : list) &#123; cout &lt;&lt; v.path().filename() &lt;&lt; endl; &#125; &#125; // 2.遍历文件夹中的所有文件(一层) void travserDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); set&lt;string&gt; dirset; for (filesystem::directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; // 3.所有文件夹中的文件 void traverseAllDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); multiset&lt;string&gt; dirset; for (filesystem::recursive_directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; remove_all(url / &quot;b&quot;); //删除当前url下面b文件夹 &#125; // remove_all int main(int argc, char** argv) &#123; TestPath(); TestStatus(); tarverseDirectory(); travserDirectoryAllFile(); traverseAllDirectoryAllFile(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++智能指针","slug":"C++智能指针","date":"2022-06-21T11:06:51.000Z","updated":"2022-09-18T02:35:33.024Z","comments":true,"path":"2022/06/21/C++智能指针/","link":"","permalink":"http://goskp.github.io/2022/06/21/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++智能指针智能指针本质是一个类的对象，使用的时候不会创建这个类指针，只会使用这个类的对象 智能指针原理是通过对象的死亡会自动调用析构函数这个功能去实现 构造函数: 管理new的对象 析构函数: 析构new的对象 C++共享型智能指针 允许拷贝构造 允许多个智能指针对象管理同一段内存 // shared_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void printData(shared_ptr&lt;MM&gt; mm) &#123; mm-&gt;print(); &#125; auto returnPtr() &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;小芳&quot;, 18)); return mm; &#125; void FreeFile(FILE*&amp; fp) &#123; cout &lt;&lt; &quot;关闭文件成功&quot; &lt;&lt; endl; fclose(fp); &#125; void test_shared_ptr() &#123; // 1.管理基本数据 shared_ptr&lt;int&gt; intData(new int(100)); if (!intData) &#123; cout &lt;&lt; &quot;初始化之智能指针失败!&quot; &lt;&lt; endl; return; &#125; cout &lt;&lt; *intData &lt;&lt; endl; //获取管理对象地址 // int* x = intData.get(); // cout &lt;&lt; *x &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p2(intData); cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; // swap // reset // make_shared函数的参数由构造函数决定 // 2.管理自定义类型 shared_ptr&lt;string&gt; str = make_shared&lt;string&gt;(&quot;ILoveyou&quot;); cout &lt;&lt; *str &lt;&lt; endl; &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;张三&quot;, 19)); mm-&gt;print(); mm.reset(new MM(&quot;小芳&quot;, 18)); mm-&gt;print(); shared_ptr&lt;MM&gt; mm2 = make_shared&lt;MM&gt;(&quot;小芳&quot;, 20); mm2-&gt;print(); &#125; // 3.智能指针常用场景 shared_ptr&lt;MM&gt; temp(new MM(&quot;亲爱的&quot;, 28)); printData(temp); printData(returnPtr()); // 4.特殊释放形式的内存，需要自己手动写删除器 // C语言文件指针 &#123; shared_ptr&lt;FILE&gt; pf(fopen(&quot;1.txt&quot;, &quot;w+&quot;), FreeFile); &#125; &#123; shared_ptr&lt;Boy&gt; p(new Boy[10], [](Boy*&amp; p) &#123; delete[] p; &#125;); &#125; &#123; shared_ptr&lt;int&gt; pint(new int(999)); int* pp = pint.get(); *pp = 666; cout &lt;&lt; *pint &lt;&lt; endl; // delete pp; //不能直接释放，会导致二次析构问题 // cout &lt;&lt; *pint &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; test_shared_ptr(); return 0; &#125; C++弱引用型智能指针 weak_ptr 是弱引用指针，不会累计计数 weak_ptr不能直接管理对象，只能shared_ptr或者weak_ptr构造而来 目的是为了解决shared_ptr循环引用的时候内存未释放问题 不可以使用* 或者-&gt;访问对象，只能通过lock函数访问shared_ptr对象，再去访问数据 // weak_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class B; class A &#123; public: A() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;B&gt; b; weak_ptr&lt;B&gt; b; &#125;; class B &#123; public: B() &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;A&gt; a; weak_ptr&lt;A&gt; a; &#125;; void test_weak_ptr() &#123; &#123; shared_ptr&lt;A&gt; ao = make_shared&lt;A&gt;(); shared_ptr&lt;B&gt; bo = make_shared&lt;B&gt;(); cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; ao-&gt;b = bo; bo-&gt;a = ao; cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; &#125; &#123; shared_ptr&lt;int&gt; s(new int(999)); cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; weak_ptr&lt;int&gt; w(s); cout &lt;&lt; &quot;count:&quot; &lt;&lt; w.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; cout &lt;&lt; *w.lock() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); test_weak_ptr(); return 0; &#125; C++独享型智能指针 禁止拷贝和赋值(通过删除拷贝构造函数和赋值重载) 可以通过转交所有权的方式让一个指针去管理对象 move函数移交所有权限 内置reset函数结合release函数去移交所有权限 // unique_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void test_unique_ptr() &#123; unique_ptr&lt;int&gt; ptr(new int(999)); cout &lt;&lt; *ptr &lt;&lt; endl; // unique_ptr&lt;int&gt; ptr2(ptr); //转交所有权 unique_ptr&lt;int&gt; ptr2; ptr2 = move(ptr); // cout &lt;&lt; *ptr &lt;&lt; endl; //没有值了 cout &lt;&lt; *ptr2 &lt;&lt; endl; unique_ptr&lt;int&gt; ptr3; ptr3.reset(ptr2.release()); cout &lt;&lt; *ptr3 &lt;&lt; endl; auto p = ptr3.get(); // delete p; //导致二次析构问题 &#123; unique_ptr&lt;MM&gt; pMM(new MM(&quot;小美&quot;, 19)); pMM-&gt;print(); // unique_ptr&lt;管理对象类型,删除器函数指针类型&gt; using FUNC = void (*)(Boy*&amp;); unique_ptr&lt;Boy, FUNC&gt; pBoy(new Boy[3], [](Boy*&amp; pBoy) &#123; delete[] pBoy; &#125;); //不能用auto // unique_ptr&lt;Boy, auto&gt; pBoy2(new Boy[3], [](Boy*&amp; pBoy) &#123;delete[] // pBoy; &#125;); &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); // test_weak_ptr(); test_unique_ptr(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库算法篇(拷贝,算数,排列组合,堆)","slug":"C++标准模板库算法篇(拷贝,算数,排列组合,堆)","date":"2022-06-17T06:01:01.000Z","updated":"2022-09-18T02:36:07.826Z","comments":true,"path":"2022/06/17/C++标准模板库算法篇(拷贝,算数,排列组合,堆)/","link":"","permalink":"http://goskp.github.io/2022/06/17/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%8B%B7%E8%B4%9D,%E7%AE%97%E6%95%B0,%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88,%E5%A0%86)/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 拷贝和修改类算法 copy: 区间拷贝 copy_backward: 逆向拷贝 remove:删除 remove_copy: 删除另存 remove_if:条件删除 remove_copy_if:条件删除结果另存 replace: 修改 replace _copy: 修改结果另存 replace_if:条件替换 replace_copy_if:条件替换 ，结果另存 iter_swap:迭代器交换 swap:容器交换 swap_ranges: 区间交换 unique: 去重操作 unique_copy: 去重结果另存 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; //打印辅助函数 template &lt;class _Ty&gt; void print(string info, _Ty data) &#123; cout &lt;&lt; info &lt;&lt; &quot;: &quot;; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // copy: 区间拷贝 array&lt;int, 4&gt; arrayData = &#123;1, 3, 7, 9&#125;; vector&lt;int&gt; vecData(arrayData.size()); copy(arrayData.begin(), arrayData.end(), vecData.begin()); print(&quot;copy&quot;, vecData); // copy_backward : 逆向拷贝 vector&lt;int&gt; rvec(arrayData.size()); copy_backward(arrayData.begin(), arrayData.end(), rvec.end()); print(&quot;copy_backward&quot;, rvec); // remove : 删除 vector&lt;int&gt;::iterator rs = remove(vecData.begin(), vecData.end(), 3); print(&quot;remove&quot;, vecData); //数组的伪删除 vecData.pop_back(); //真正的删除 print(&quot;remove&quot;, vecData); // remove_copy : 删除另存 vector&lt;int&gt; result(vecData.size() - 1); remove_copy(vecData.begin(), vecData.end(), result.begin(), 7); print(&quot;remove_copy&quot;, result); // remove_if : 条件删除 vector&lt;int&gt; test = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; auto it = remove_if(test.begin(), test.end(), [](int&amp; data) &#123; return data % 2 == 0; &#125;); print(&quot;remove_if&quot;, test); // remove_copy_if : 条件删除结果另存 vector&lt;int&gt; test2 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; result.resize(5); remove_copy_if(test2.begin(), test2.end(), result.begin(), [](int&amp; data) &#123; return data % 2 == 0; &#125;); print(&quot;remove_copy_if&quot;, result); // replace : 修改 replace(result.begin(), result.end(), 1, 999); print(&quot;replace&quot;, result); // replace _copy : 修改结果另存 vector&lt;int&gt; newTest(result.size()); replace_copy(result.begin(), result.end(), newTest.begin(), 999, 888); print(&quot;replace_copy&quot;, newTest); // replace_if : 条件替换 replace_if( newTest.begin(), newTest.end(), [](int&amp; data) &#123; return data % 2 == 1; &#125;, 888); print(&quot;replace_if&quot;, newTest); // replace_copy_if : 条件替换 ，结果另存 vector&lt;int&gt; result2(newTest.size()); replace_copy_if( newTest.begin(), newTest.end(), result2.begin(), [](int&amp; data) &#123; return data == 888; &#125;, 666); print(&quot;replace_copy_if&quot;, result2); // iter_swap : 迭代器交换 list&lt;int&gt; listData = &#123;1, 2, 3, 4, 5&#125;; list&lt;int&gt;::iterator itList = listData.end(); advance(itList, -1); iter_swap(listData.begin(), itList); print(&quot;iter_swap&quot;, listData); // swap : 容器交换 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5, 6, 8, 9&#125;; vector&lt;int&gt; second = &#123;9, 99, 999&#125;; swap(first, second); print(&quot;first&quot;, first); print(&quot;second&quot;, second); // swap_ranges : 区间交换 swap_ranges(first.begin(), first.begin() + 2, second.begin()); print(&quot;first&quot;, first); print(&quot;second&quot;, second); // unique : 去重操作 list&lt;int&gt; data = &#123;1, 1, 2, 2, 3, 3, 3, 4, 4, 4&#125;; unique(data.begin(), data.end()); print(&quot;unique&quot;, data); // unique_copy : 去重结果另存 vector&lt;int&gt; data2 = &#123;1, 1, 2, 2, 3, 3, 3, 4, 4, 4&#125;; vector&lt;int&gt; result3(4); std::unique_copy(data2.begin(), data2.end(), result3.begin()); print(&quot;unique_copy&quot;, result3); return 0; &#125; 关系类算法 equal ：比较算法 includes：是不是包含关系 lexicographical_compare: 比较序列 max: 最大值 max_element min:最小值 min_element mismatch: 查找第一次不同的地方 #include &lt;algorithm&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // equal ：比较算法 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; second = &#123;1, 4, 2, 3, 4&#125;; cout &lt;&lt; boolalpha &lt;&lt; equal(first.begin(), first.end(), second.begin()) &lt;&lt; endl; // includes：是不是包含关系 有序基础之上 vector&lt;int&gt; third = &#123;1, 2, 3&#125;; cout &lt;&lt; includes(first.begin(), first.end(), third.begin(), third.end()) &lt;&lt; endl; // lexicographical_compare: 比较序列 //第一个序列小于第二个序列，返回true，反之返回fasle(字符比较) cout &lt;&lt; lexicographical_compare(first.begin(), first.end(), second.begin(), second.end()) &lt;&lt; endl; // max : 最大值 max_element cout &lt;&lt; std::max(1, 2) &lt;&lt; endl; cout &lt;&lt; *max_element(second.begin(), second.end()) &lt;&lt; endl; // min : 最小值 min_element cout &lt;&lt; std::min(1, 2) &lt;&lt; endl; cout &lt;&lt; *min_element(second.begin(), second.end()) &lt;&lt; endl; // mismatch : 查找第一次不同的地方 // pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt; // result=mismatch(first.begin(), first.end(), second.begin(), // second.end()); auto result = mismatch(first.begin(), first.end(), second.begin(), second.end()); cout &lt;&lt; &quot;first:&quot; &lt;&lt; *result.first &lt;&lt; endl; cout &lt;&lt; &quot;second:&quot; &lt;&lt; *result.second &lt;&lt; endl; return 0; &#125; 算术类算法 accumulate：求和算法 partial_sum: 逐步求和 iner_product:求积 adjacent_difference:求差 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;numeric&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // accumulate：求和算法 vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; int sum = 0; sum = accumulate(vec.begin(), vec.end(), 0); cout &lt;&lt; &quot;sum:&quot; &lt;&lt; sum &lt;&lt; endl; // partial_sum: 逐步求和 vector&lt;int&gt; result(vec.size()); partial_sum(vec.begin(), vec.end(), result.begin()); copy(result.begin(), result.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // iner_product : 求积 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; second = &#123;5, 4, 3, 2, 1&#125;; cout &lt;&lt; inner_product(first.begin(), first.end(), second.begin(), 0) &lt;&lt; endl; // adjacent_difference : 求差 vector&lt;int&gt; testData = &#123;8, 2, 3, 4, 5, 6, 7, 8, 9, 0&#125;; cout &lt;&lt; &quot;求差:&quot;; adjacent_difference(testData.begin(), testData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; return 0; &#125; 排列组合算法 next_premutation: 下一个序列 prev_premutation: 上一个序列 //假设:已有序列&#123;a,b,c&#125; 并且 a&lt;b&lt;c 例如&#123;1,2,3&#125; //下一个序列: &#123;a ,c, b&#125; &#123;1,3,2&#125;就是&#123;1,2,3&#125;下一个序列 //反之: &#123;a,c,b&#125; 上一个序列就是&#123;a,b,c&#125; &#123;1,3,2&#125; 上一个序列是&#123;1,2,3&#125; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; data = &#123;1, 2, 3, 4&#125;; int index = 0; cout &lt;&lt; &quot;升序:&quot; &lt;&lt; endl; do &#123; cout &lt;&lt; &quot;第 &quot; &lt;&lt; index + 1 &lt;&lt; &quot; 组合:&quot;; copy(data.begin(), data.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; index++; &#125; while (next_permutation(data.begin(), data.end())); vector&lt;int&gt; test = &#123;1, 2, 3, 4&#125;; reverse(test.begin(), test.end()); cout &lt;&lt; &quot;降序:&quot; &lt;&lt; endl; index = 0; do &#123; cout &lt;&lt; &quot;第 &quot; &lt;&lt; index + 1 &lt;&lt; &quot; 组合:&quot;; copy(test.begin(), test.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; index++; &#125; while (prev_permutation(test.begin(), test.end())); return 0; &#125; 生成异变算法 for_each: 遍历 fill:填充 fill_n: 前n个元素用value填充 generate: 填充 generate_n: 填充n个元素 transform : 一元操作 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // for_each: 遍历 vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7&#125;; for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; for_each(data.begin(), data.end(), [](int&amp; data) &#123; data *= 2; &#125;); for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // fill : 填充 vector&lt;int&gt; vec(3); fill(vec.begin(), vec.end(), 666); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // fill_n : 前n个元素用value填充 fill(vec.begin(), vec.begin() + 2, 888); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // generate : 填充 generate(vec.begin(), vec.end(), []() &#123; return 999; &#125;); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // generate_n : 填充n个元素 generate_n(vec.begin(), 2, []() &#123; return 222; &#125;); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; // transform : 一元操作 vector&lt;int&gt; first = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt; second(first.size()); transform(first.begin(), first.end(), second.begin(), [](int data) &#123; return -data; &#125;); for (auto&amp; v : second) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 堆算法 make_heap: 创建堆 push_heap: 入堆 pop_heap: 出堆 (单纯把元素放到容器后面，手动调用相应的尾部删除函数) sort_heap:堆排序 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; //默认形式大顶堆 vector&lt;int&gt; data = &#123;4, 2, 1, 0, 8&#125;; make_heap(data.begin(), data.end()); make_heap(data.begin(), data.end(), less&lt;int&gt;()); //和默认方式一样是大顶堆 for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //从小到大 sort_heap(data.begin(), data.end(), less&lt;int&gt;()); //需要和创建的准则一致 for_each(data.begin(), data.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; //小顶堆 vector&lt;int&gt; test = &#123;4, 2, 1, 0, 8&#125;; make_heap(test.begin(), test.end(), greater&lt;int&gt;()); for_each(test.begin(), test.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; sort_heap(test.begin(), test.end(), greater&lt;int&gt;()); //需要和创建的准则一致 for_each(test.begin(), test.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; vector&lt;int&gt; vec; make_heap(vec.begin(), vec.end()); vec.push_back(1); push_heap(vec.begin(), vec.end()); //调整数据位置 vec.push_back(5); push_heap(vec.begin(), vec.end()); vec.push_back(4); push_heap(vec.begin(), vec.end()); vec.push_back(0); push_heap(vec.begin(), vec.end()); vec.push_back(8); push_heap(vec.begin(), vec.end()); for_each(vec.begin(), vec.end(), [](int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; while (!vec.empty()) &#123; pop_heap(vec.begin(), vec.end()); //调整数据 cout &lt;&lt; vec.back() &lt;&lt; &quot; &quot;; vec.pop_back(); make_heap(vec.begin(), vec.end()); &#125; cout &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库算法篇(查找,排序,集合)","slug":"C++标准模板库算法篇(查找,排序,集合)","date":"2022-06-13T07:56:33.000Z","updated":"2022-09-18T02:36:09.553Z","comments":true,"path":"2022/06/13/C++标准模板库算法篇(查找,排序,集合)/","link":"","permalink":"http://goskp.github.io/2022/06/13/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%97%E6%B3%95%E7%AF%87(%E6%9F%A5%E6%89%BE,%E6%8E%92%E5%BA%8F,%E9%9B%86%E5%90%88)/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 查找算法基本查找 find: 区间查找 find_if: 条件查找 find_first_of: 查找区间第一次出现值 adjacent_find:查找第一次重复的值 search: 子序列查找 search_n: 子序列查找出现的次数 统计查找 count：区间统计 count_if: 条件统计 equal: 比较 有序查找 binary_search: 二分查找 upper_bound: 查找最后一个大于查找值 lower_bound: 大于等于查找值 eqaul_range：区间比较 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name = &quot;&quot;, int score = 0) : name(name), score(score) &#123;&#125; int getScore() const &#123; return score; &#125; private: string name; int score; &#125;; class System &#123; public: void insertData(const MM&amp; mm) &#123; mmData.push_back(mm); &#125; int getOK() &#123; return count_if(mmData.begin(), mmData.end(), [](const MM&amp; mm) &#123; return mm.getScore() &gt;= 60; &#125;); &#125; int getNo() &#123; return count_if(mmData.begin(), mmData.end(), [](const MM&amp; mm) &#123; return mm.getScore() &lt; 60; &#125;); &#125; private: vector&lt;MM&gt; mmData; &#125;; void testUserData() &#123; System* p = new System; p-&gt;insertData(MM(&quot;name1&quot;, 59)); p-&gt;insertData(MM(&quot;name2&quot;, 92)); p-&gt;insertData(MM(&quot;name3&quot;, 88)); p-&gt;insertData(MM(&quot;name4&quot;, 54)); p-&gt;insertData(MM(&quot;name5&quot;, 25)); cout &lt;&lt; &quot;及格人数:&quot; &lt;&lt; p-&gt;getOK() &lt;&lt; endl; cout &lt;&lt; &quot;不及格人数:&quot; &lt;&lt; p-&gt;getNo() &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; int array[10] = &#123;1, 3, 5, 7, 9, 2, 4, 6, 8, 10&#125;; vector&lt;int&gt; testData; testData.assign(array, array + 10); // 1.区间查找 auto it = find(testData.begin(), testData.end(), 3); if (it != testData.end()) cout &lt;&lt; *it &lt;&lt; endl; // 2.条件查找 it = find_if(testData.begin(), testData.end(), [](int data) &#123; return data &gt; 8; &#125;); cout &lt;&lt; *it &lt;&lt; endl; // 3.查找第一次出现的 int temp[] = &#123;15, 10, 6&#125;; cout &lt;&lt; *find_first_of(testData.begin(), testData.end(), temp, temp + 3) &lt;&lt; endl; // 4.查找第一次重复的元素 vector&lt;int&gt; value = &#123;1, 2, 3, 3, 2, 4, 4, 9, 9, 5, 5, 9, 9, 9&#125;; cout &lt;&lt; *adjacent_find(value.begin(), value.end()) &lt;&lt; endl; // 5.区间查找 vector&lt;int&gt; num = &#123;1, 2, 3&#125;; cout &lt;&lt; *search(value.begin(), value.end(), num.begin(), num.end()) &lt;&lt; endl; string str = &#123;&quot;ILoveyouIMissyou&quot;&#125;; string str2 = &#123;&quot;you&quot;&#125;; cout &lt;&lt; *search(str.begin(), str.end(), str2.begin(), str2.end()) &lt;&lt; endl; // 6.查找出现次数 cout &lt;&lt; *search_n(value.begin(), value.end(), 3, 9) &lt;&lt; endl; // 7.统计出现次数 cout &lt;&lt; count(value.begin(), value.end(), 2) &lt;&lt; endl; // 8.条件统计出现次数 cout &lt;&lt; count_if(value.begin(), value.end(), [](int i) &#123; return i &gt;= 6; &#125;) &lt;&lt; endl; // 9.相等比较 cout &lt;&lt; boolalpha &lt;&lt; equal(value.begin(), value.end(), num.begin(), num.end()) &lt;&lt; endl; // 10.二分查找 vector&lt;int&gt; order = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; cout &lt;&lt; boolalpha &lt;&lt; binary_search(order.begin(), order.end(), 5) &lt;&lt; endl; // 11.大于查找 cout &lt;&lt; *upper_bound(order.begin(), order.end(), 7) &lt;&lt; endl; // 12.大于等于 cout &lt;&lt; *lower_bound(order.begin(), order.end(), 7) &lt;&lt; endl; // 13. 大于等于的综合体: first:等于的值，second存大于值 cout &lt;&lt; *equal_range(order.begin(), order.end(), 7).second &lt;&lt; endl; cout &lt;&lt; *equal_range(order.begin(), order.end(), 7).first &lt;&lt; endl; testUserData(); return 0; &#125; 排序和通用算法 sort：排序 stable_sort: 保持相对顺序的排序 merge:归并排序，不会改变原容器数据 inplace_merge: 归并排序，直接作用在原容器上 nth_element:关键字排序 partition: 分类处理 (按特定条件把数据分为两堆) stable_partion: 保持数据相对顺序，分类处理 partial_sort:局部排序 partial_sort_copy: 局部排序结果放到新容器中 random_shuffle: 乱序算法 reverse: 逆序 reverse_copy: 逆序结果另存 rotate: 移动元素到末位 rotate_copy: 移位后的结果另存 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // 1.基本排序 vector&lt;int&gt; vec = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; sort(vec.begin(), vec.end()); sort(vec.begin(), vec.end(), less&lt;int&gt;&#123;&#125;); copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; sort(vec.begin(), vec.end(), greater&lt;int&gt;&#123;&#125;); copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // list有内置的sort算法，不能直接用sort算法 list&lt;int&gt; mylist = &#123;1, 2, 3, 4, 9, 8&#125;; mylist.sort(); copy(mylist.begin(), mylist.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 2.保持相对顺序的排序 vector&lt;double&gt; dNum = &#123;1.11, 2.22, 3.33, 4.44, 1.11, 1.10, 4.6, 4.5&#125;; stable_sort(dNum.begin(), dNum.end(), [](double a, double b) &#123; return int(a) &lt; int(b); &#125;); copy(dNum.begin(), dNum.end(), ostream_iterator&lt;double&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 3.归并排序 vector&lt;int&gt; order = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; vector&lt;int&gt; result(order.size()); merge(order.begin(), order.begin() + 5, order.begin() + 5, order.end(), result.begin()); copy(result.begin(), result.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 4.改变原容器的归并 inplace_merge(order.begin(), order.begin() + 5, order.end()); copy(order.begin(), order.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 5.关键字排序 vector&lt;int&gt; element = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; nth_element(element.begin(), element.begin() + 2, element.end()); copy(element.begin(), element.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 6.分类处理 vector&lt;int&gt; pData = &#123;1, 3, 5, 7, 9, 0, 2, 4, 6, 8&#125;; partition(pData.begin(), pData.end(), [](int data) &#123; return data &lt; 6; &#125;); copy(pData.begin(), pData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 7.保持相对顺序分类处理 vector&lt;double&gt; dNum2 = &#123;1.11, 2.22, 3.33, 4.44, 1.11, 1.10, 4.6, 4.5&#125;; stable_partition(dNum2.begin(), dNum2.end(), [](double a) &#123; return int(a) &lt; 2; &#125;); copy(dNum2.begin(), dNum2.end(), ostream_iterator&lt;double&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 8.局部排序 按元素大小顺序，选取有序的放在前面 vector&lt;int&gt; testData = &#123;19, 23, 65, 77, 45, 34&#125;; partial_sort(testData.begin(), testData.begin() + 3, testData.end()); copy(testData.begin(), testData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 9.局部排序结果另存 vector&lt;int&gt; pResult(3); partial_sort_copy(testData.begin(), testData.begin() + 3, pResult.begin(), pResult.end()); copy(pResult.begin(), pResult.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 10.乱序算法 srand((unsigned int)time(nullptr)); string str = &quot;ABCDEFG&quot;; random_shuffle(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl; // 11.反转 str = &quot;ILoveyou&quot;; reverse(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl; // 12.反转另存 string strResult; strResult.resize(str.size()); reverse_copy(str.begin(), str.end(), strResult.begin()); cout &lt;&lt; strResult &lt;&lt; endl; // 13.移动元素到末位 string testStr = &quot;ILoveyou&quot;; rotate(testStr.begin(), testStr.begin() + 4, testStr.end()); cout &lt;&lt; testStr &lt;&lt; endl; // 14.移位另存 string rotateStr; rotateStr.resize(testStr.size()); rotate_copy(testStr.begin(), testStr.begin() + 4, testStr.end(), rotateStr.begin()); cout &lt;&lt; rotateStr &lt;&lt; endl; return 0; &#125; 集合类算法 set_union: 并集 set_intersetction: 交集 set_difference: 差集 set_symmetric_difference: 对称差集 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; one = &#123;1, 2, 3, 7, 8&#125;; vector&lt;int&gt; two = &#123;4, 5, 6, 7, 8&#125;; // 1.并集 set_union(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 2.交集 set_intersection(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 3.求差集 set_difference(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; // 4.对称差集 (并集减去交集) set_symmetric_difference(one.begin(), one.end(), two.begin(), two.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之迭代器","slug":"C++标准模板库之迭代器","date":"2022-06-09T08:47:20.000Z","updated":"2022-09-21T12:49:23.186Z","comments":true,"path":"2022/06/09/C++标准模板库之迭代器/","link":"","permalink":"http://goskp.github.io/2022/06/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 迭代器迭代器就是类中类，通过类中类的对象去访问数据(模仿指针行为) STL之迭代器定义的方式分类 正向迭代器 容器名::iterator it begin() end() 反向迭代器 容器名::reverse_iterator it rbegin() rend() 常正向迭代器 容器名::const _iterator it cbegin() cend() 常反向迭代器 容器名::const _reverse_iterator it crbegin() crend() 功能方式分类 正向迭代器 双向迭代器 随机访问迭代器 STL容器迭代器类型 容器名 迭代器类型 array 随机访问 vector 随机访问 deque 随机访问 list 双向 set&#x2F;multiset 双向 map&#x2F;multimap 双向 stack&#x2F;queue&#x2F;priority_queue 不支持迭代器 迭代器辅助函数 advance(iterator it,n): it+n; distance(iterator begin,iterator end): end一定在begin后面 iter_swap(iteartor first,iterator second); 流型迭代器 输出流型迭代器 ostream_iterator&lt;_Ty&gt; object(ostream&amp; object); ostream_iterator&lt;_Ty&gt; object(ostream&amp; object,char* str); object&#x3D;value; &#x2F;&#x2F;等效 cout&lt;&lt;value; 输入流型迭代器 istream_iterator&lt;_Ty&gt; object; &#x2F;&#x2F;EOF_OF_STREAM 输入的数据和要求的不同，产生错误流 istream_iterator&lt;_Ty&gt; object(istream&amp; object); *object &#x2F;&#x2F;等效做cin&gt;&gt;操作 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;Algorithm&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;int&gt;::iterator it = data.begin(); vector&lt;int&gt;::reverse_iterator rit = data.rbegin(); vector&lt;int&gt;::const_iterator cit = data.cbegin(); vector&lt;int&gt;::const_reverse_iterator crit = data.crbegin(); // begin可以表示第一个元素，end不表示最后元素 // cout &lt;&lt; *data.end() &lt;&lt; endl; //越界访问 cout &lt;&lt; *data.begin() &lt;&lt; endl; cout &lt;&lt; *data.rbegin() &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; distance(data.begin(), data.end()) &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; data.size() &lt;&lt; endl; cout &lt;&lt; &quot;distance:&quot; &lt;&lt; find(data.begin(), data.end(), 5) - data.begin() &lt;&lt; endl; iter_swap(data.begin(), data.end() - 1); for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; ostream_iterator&lt;int&gt; outIterator(cout); outIterator = 1234; // copy(src,end,dst); vector&lt;int&gt; dst(data.size()); copy(data.begin(), data.end(), dst.begin()); cout &lt;&lt; endl &lt;&lt; &quot;copy函数结合流型迭代器去做数据打印&quot; &lt;&lt; endl; copy(dst.begin(), dst.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl &lt;&lt; &quot;输入流型迭代器做数据输入:&quot; &lt;&lt; endl; vector&lt;int&gt; inputData; istream_iterator&lt;int&gt; EOS; istream_iterator&lt;int&gt; inputIter(cin); while (inputIter != EOS) &#123; inputData.push_back(*inputIter); ++inputIter; &#125; cout &lt;&lt; &quot;输入数据:&quot; &lt;&lt; endl; for (auto&amp; v : inputData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; STL之仿函数仿函数： 仿函数是让类名模仿函数调用的行为(函数调用:函数名(参数)) 仿函数： 类名(参数) 使用 仿函数实质是重载()运算符 仿函数一般是作为排序准则，或者比较准则 #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; class Sum &#123; public: int operator()(const int&amp; a, const int&amp; b) const &#123; return a + b; &#125; &#125;; template &lt;class _Ty, class _Pr&gt; void printSum(_Ty a, _Ty b, _Pr Pr) &#123; cout &lt;&lt; Pr(a, b) &lt;&lt; endl; &#125; void testFunctional() &#123; //仿函数的调用方式 Sum object; cout &lt;&lt; object(1, 2) &lt;&lt; endl; //重载隐式调用形态 cout &lt;&lt; object.operator()(1, 2) &lt;&lt; endl; //重载的显示调用形态 cout &lt;&lt; Sum()(1, 2) &lt;&lt; endl; //匿名对象调用 printSum(1, 2, Sum()); &#125; int main(int argc, char** argv) &#123; testFunctional(); return 0; &#125; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;set&gt; using namespace std; class Sum &#123; public: int operator()(const int&amp; a, const int&amp; b) const &#123; return a + b; &#125; &#125;; template &lt;class _Ty, class _Pr&gt; void printSum(_Ty a, _Ty b, _Pr Pr) &#123; cout &lt;&lt; Pr(a, b) &lt;&lt; endl; &#125; void testFunctional() &#123; //仿函数的调用方式 Sum object; cout &lt;&lt; object(1, 2) &lt;&lt; endl; //重载隐式调用形态 cout &lt;&lt; object.operator()(1, 2) &lt;&lt; endl; //重载的显示调用形态 cout &lt;&lt; Sum()(1, 2) &lt;&lt; endl; //匿名对象调用 printSum(1, 2, Sum()); &#125; void testCppFunctional() &#123; cout &lt;&lt; plus&lt;int&gt;()(1, 2) &lt;&lt; endl; cout &lt;&lt; minus&lt;int&gt;()(1, 2) &lt;&lt; endl; set&lt;int, greater&lt;int&gt;&gt; sData = &#123;1, 2, 3, 4, 5, 6&#125;; /* //set map priority_queue sort算法 greater: &gt; less: &lt; less_equal: &lt;= not_equal_to: != equal_to :== */ //逻辑与 cout &lt;&lt; logical_and&lt;int&gt;()(1, 2) &lt;&lt; endl; //位与 cout &lt;&lt; bit_and&lt;int&gt;()(1, 2) &lt;&lt; endl; cout &lt;&lt; (1 | 2) &lt;&lt; endl; copy(sData.begin(), sData.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); // set&lt;int, greater_equal&lt;int&gt;&gt; sData2 = &#123; 1,2,3,4,4,5,5,6 &#125;; // copy(sData2.begin(), sData2.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); &#125; int main(int argc, char** argv) &#123; testFunctional(); testCppFunctional(); return 0; &#125; Lambda表达式//完整组成 [捕获方式](参数列表) mutable exception -&gt;函数返回值类型&#123;函数体;&#125; //1.使用的时候直接用auto类型推断类型接受Lambda表达式的返回值 //2.使用的时候，除了捕获方式和函数之外的所有东西都可以省略 [捕获方式]&#123;函数体;&#125; //捕获方式: 指的Lambda函数体使用之外的变量的方式 []: 不捕获任何东西 [=]:用值的方式 [&amp;]:引用的方式 [this]:成员函数 [&amp;value]: value用引用的方式 [=,&amp;value]: valu用引用方式，其他变量用值的方式 Lambda基本操作 用Lambda表达式调用函数 Lambda缺省写法 Lambda捕获方式的区别 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; class Test &#123; public: void print() &#123; cout &lt;&lt; &quot;result:&quot; &lt;&lt; [this]() -&gt; int &#123; return this-&gt;age++; &#125;() &lt;&lt; endl; cout &lt;&lt; &quot;result:&quot; &lt;&lt; this-&gt;age++ &lt;&lt; endl; &#125; int&amp; GetAge() &#123; return age; &#125;; private: string name = &quot;默认&quot;; int age = 19; &#125;; void modifyTest(Test&amp; test) &#123; test.GetAge()++; &#125; void print(int&amp; data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; int main(int argc, char** argv) &#123; int a = 1; int b = 2; cout &lt;&lt; Max(a, b) &lt;&lt; endl; auto func = [](int a, int b) mutable noexcept -&gt; int &#123; return a &gt; b ? a : b; &#125;; cout &lt;&lt; func(a, b) &lt;&lt; endl; //一步到位 cout &lt;&lt; [](int a, int b) mutable noexcept -&gt; int &#123; return a &gt; b ? a : b; &#125;(a, b) &lt;&lt; endl; //缺省版本 cout &lt;&lt; [](int a, int b) &#123; return a &gt; b ? a : b; &#125;(a, b) &lt;&lt; endl; auto func2 = [=] &#123; return a &gt; b ? a : b; &#125;; //这个函数指针调用，结果永远都是一样的，不因为值的改变而改变 cout &lt;&lt; func2() &lt;&lt; endl; //捕获方式的区别 b = 4; cout &lt;&lt; func2() &lt;&lt; endl; auto func3 = [&amp;] &#123; return a &gt; b ? a : b; &#125;; cout &lt;&lt; func3() &lt;&lt; endl; // 4 b = 5; cout &lt;&lt; func3() &lt;&lt; endl; // 5 // Lambda用在以函数指针充当函数参数的地方 // for_each()算法 vector&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for_each(data.begin(), data.end(), print); cout &lt;&lt; endl; for_each(data.begin(), data.end(), [](int data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; cout &lt;&lt; *find_if(data.begin(), data.end(), [](int data) &#123; return data == 5; &#125;) &lt;&lt; endl; for_each(data.begin(), data.end(), [](int&amp; data) &#123; data *= data; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125;); cout &lt;&lt; endl; return 0; &#125; 函数包装器函数包装器可以把函数指针封装一个对象，让对象去充当函数名的功能 包装普通函数 包装类的静态函数 包装仿函数 包装转换成指针对象 //基本创建语法 // function&lt;函数返回值类型(参数类型)&gt; 对象名(函数指针) #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; using FUNC = void (*)(int, int); class Test &#123; public: static void print(int a, int b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; void operator()(const string&amp; str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; operator FUNC() &#123; return print; &#125; &#125;; int main(int argc, char** argv) &#123; // 1.包装普通函数 function&lt;int(int, int)&gt; FuncMax(Max); cout &lt;&lt; FuncMax(1, 2) &lt;&lt; endl; // 2.包装静态成员函数 function&lt;void(int, int)&gt; sFunc = &amp;Test::print; sFunc(1, 2); // 3.包装仿函数 Test test; function&lt;void(const string&amp;)&gt; Func = test; Func(&quot;仿函数&quot;); test(&quot;仿函数&quot;); // 4.包装隐式转换的对象 Test object; function&lt;void(int, int)&gt; funO = object; funO(2, 3); return 0; &#125; 函数适配器函数适配就是让函数指针调用时候函数后绑定特定参数，从而让函数指针存在多种调用形态 bind函数基本用法 绑定普通函数 绑定类中成员函数指针 仿函数的绑定 结合包装器去使用 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; class Test &#123; public: void printTest(int a, int b, int c) &#123; cout &lt;&lt; a + b + c &lt;&lt; endl; &#125; &#125;; void print(int a, double b, string c) &#123; cout &lt;&lt; &quot;函数是适配器和包装器结合&quot; &lt;&lt; endl; &#125; void testBind() &#123; //正常包装 function&lt;void(int, double, string)&gt; func1 = print; func1(1, 1.1, &quot;普通函数&quot;); //正常适配 function&lt;void(int, double)&gt; func2 = bind(print, std::placeholders::_1, std::placeholders::_2, &quot;正常适配&quot;); func2(1, 1.1); //调整参数顺序 function&lt;void(double, int)&gt; func3 = bind(print, std::placeholders::_2, std::placeholders::_1, &quot;调整参数顺序&quot;); func3(1.11, 1); // print(double,string,int) function&lt;void(string, int, double)&gt; func4 = bind(print, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1); func4(&quot;调整所有参数&quot;, 4, 4.11); &#125; int main(int argc, char** argv) &#123; // 1.绑定普通函数 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; // std::placeholders::_1占位符 auto pMax1 = bind(Max, std::placeholders::_1, 100); // b=100; cout &lt;&lt; pMax1(1) &lt;&lt; endl; auto pMax2 = bind(Max, 10, 20); cout &lt;&lt; pMax2() &lt;&lt; endl; cout &lt;&lt; pMax2(12, 34) &lt;&lt; endl; //参数一旦被绑定，调用传参就没意义 // 2.绑定类中的成员函数指针 //多线程中 Test test; auto testFunc = &amp;Test::printTest; (test.*testFunc)(1, 2, 3); auto func = bind(&amp;Test::printTest, &amp;test, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); func(1, 2, 3); // 3.一些算法中 // count_if vector&lt;int&gt; data = &#123;10, 20, 80, 40, 70, 54&#125;; int count = count_if(data.begin(), data.end(), [](int value) &#123; return value &lt; 60; &#125;); cout &lt;&lt; &quot;不及格人数:&quot; &lt;&lt; count &lt;&lt; endl; // less&lt;int&gt; cout &lt;&lt; &quot;不及格人数: &quot; &lt;&lt; count_if(data.begin(), data.end(), bind(less&lt;int&gt;(), std::placeholders::_1, 60)) &lt;&lt; endl; // 4.结合函数包装器使用 testBind(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之initalizer_list与set与map","slug":"C++标准模板库之initalizer_list与set与map","date":"2022-06-04T08:41:40.000Z","updated":"2022-09-25T23:12:43.136Z","comments":true,"path":"2022/06/04/C++标准模板库之initalizer_list与set与map/","link":"","permalink":"http://goskp.github.io/2022/06/04/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Binitalizer_list%E4%B8%8Eset%E4%B8%8Emap/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之initializer_listinitializer_list是列表数据，用{}括起来的数据 #include &lt;initializer_list&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; MM(string name) : name(name), age(0) &#123;&#125; protected: string name; int age; &#125;; template &lt;class _Ty&gt; class my_vector &#123; public: my_vector(int size) : curSize(0) &#123; mem = new _Ty[size]; &#125; my_vector(const initializer_list&lt;_Ty&gt;&amp; data) : my_vector(data.size()) &#123; for (auto&amp; v : data) &#123; mem[curSize++] = v; &#125; &#125; void print() &#123; for (int i = 0; i &lt; curSize; i++) &#123; cout &lt;&lt; mem[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; protected: _Ty* mem; int curSize; &#125;; int sum(initializer_list&lt;int&gt; data) &#123; int count = 0; for (auto&amp; v : data) &#123; count += v; &#125; return count; &#125; int main(int argc, char** argv) &#123; initializer_list&lt;int&gt; data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; MM mm = &#123;&quot;美女&quot;&#125;; vector&lt;int&gt; vec1 = &#123;1, 2, 3, 4&#125;; vector&lt;int&gt; vec2 = &#123;1, 2, 3&#125;; my_vector&lt;int&gt; my_vec1 = &#123;1, 2, 3, 4&#125;; my_vector&lt;int&gt; my_vec2 = &#123;1, 2&#125;; my_vec1.print(); my_vec2.print(); cout &lt;&lt; sum(&#123;1, 2&#125;) &lt;&lt; endl; cout &lt;&lt; sum(&#123;1, 2, 3, 4&#125;) &lt;&lt; endl; cout &lt;&lt; sum(&#123;1, 2, 3, 4, 5, 6&#125;) &lt;&lt; endl; return 0; &#125; STL之setset叫做集合的意思，set特性有以下两点: 有序性:默认情况是从小到大排序 唯一性:相同的值 只保留一个 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; private: string name; int age; &#125;; //仿函数 struct CompareByName &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetName() &lt; object2.GetName(); &#125; &#125;; struct CompareByAge &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; int main(int argc, char* argv[]) &#123; set&lt;int&gt; sData = &#123;00, 00, 00, 99, 99, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; for (auto&amp; v : sData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (set&lt;int&gt;::iterator it = sData.begin(); it != sData.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; sData.size() &lt;&lt; endl; sData.insert(511); cout &lt;&lt; &quot;size&quot; &lt;&lt; sData.size() &lt;&lt; endl; for (auto&amp; v : sData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; sData.erase(find(sData.begin(), sData.end(), 5)); cout &lt;&lt; &quot;size:&quot; &lt;&lt; sData.size() &lt;&lt; endl; multiset&lt;int&gt; mulData = &#123;0, 1, 2, 3, 4, 5, 6, 7, 231, 2, 0000, 0&#125;; for (auto&amp; v : mulData) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //默认从小到大 set&lt;int, less&lt;int&gt;&gt; lSet; set&lt;int, greater&lt;int&gt;&gt; gSet = &#123;1, 2, 3, 4, 5, 6, 7&#125;; for (auto&amp; v : gSet) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; set&lt;MM, CompareByName&gt; mmData; mmData.insert(MM(&quot;name1&quot;, 18)); mmData.insert(MM(&quot;name2&quot;, 21)); mmData.insert(MM(&quot;name3&quot;, 111)); for (auto&amp; v : mmData) &#123; cout &lt;&lt; v.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.GetAge() &lt;&lt; endl; &#125; cout &lt;&lt; endl; set&lt;MM, CompareByAge&gt; mmData2; mmData2.insert(MM(&quot;name1&quot;, 18)); mmData2.insert(MM(&quot;name2&quot;, 21)); mmData2.insert(MM(&quot;name3&quot;, 111)); for (auto&amp; v : mmData2) &#123; cout &lt;&lt; v.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.GetAge() &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; STL之mapmap叫做映射，y&#x3D;x，所谓的映射 就是一种对应关系，数组是下标对应数据的一种关系 map存储的数据是数对类型:pair类型 有序性: 默认按照first从小到大排序 唯一性:first 唯一 #include &lt;Algorithm&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; using namespace std; // template &lt;class _Ty1,class _Ty2&gt; // bool constexpr operator==(const pair&lt;_Ty1, _Ty2&gt;&amp; object, const _Ty1&amp; value) //&#123; // return object.first == value; // &#125; bool Compare(const pair&lt;int, string&gt;&amp; object) &#123; return object.first == 3; &#125; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot; &quot; &lt;&lt; object.age; return out; &#125; protected: string name; int age; &#125;; struct CompareAge &#123; bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; class Score &#123; public: Score() &#123;&#125; Score(int math, int english, int py) : math(math), english(english), py(py) &#123;&#125; int GetMath() const &#123; return math; &#125; int GetEnglish() const &#123; return english; &#125; int GetPy() const &#123; return py; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Score&amp; object) &#123; out &lt;&lt; object.math &lt;&lt; &quot; &quot; &lt;&lt; object.english &lt;&lt; &quot; &quot; &lt;&lt; object.py; return out; &#125; private: int math; int english; int py; &#125;; void testUserData() &#123; map&lt;MM, Score, CompareAge&gt; mmData; //底层用树实现 mmData[MM(&quot;小芳&quot;, 18)] = Score(98, 99, 100); mmData[MM(&quot;小妹&quot;, 20)] = Score(99, 99, 100); mmData[MM(&quot;小喵&quot;, 17)] = Score(100, 100, 100); for (auto&amp; v : mmData) &#123; // cout &lt;&lt; v.first.GetName() &lt;&lt; &quot; &quot; &lt;&lt; v.first.GetAge() &lt;&lt; &quot; &quot; // &lt;&lt; v.second.GetMath() &lt;&lt; &quot; &quot; &lt;&lt; v.second.GetEnglish() &lt;&lt; &quot; &quot; &lt;&lt; // v.second.GetPy() &lt;&lt; endl; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //了解一下，复杂嵌套 map&lt;map&lt;MM, Score&gt;, map&lt;MM, Score&gt;&gt; mData; &#125; void testNewMap() &#123; unordered_map&lt;int, string&gt; hashMap; //底层是hash结构 //无序，可以避免重复 hashMap[1] = string(&quot;IMissyou&quot;); hashMap[-1] = string(&quot;ILoveyou&quot;); hashMap[-1] = string(&quot;ILoveyou&quot;); for (auto&amp; v : hashMap) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; &#125; int main(int argc, char* argv[]) &#123; //单映射 map&lt;int, string&gt; mData; pair&lt;int, string&gt; temp = &#123;1, &quot;Love&quot;&#125;; cout &lt;&lt; temp.first &lt;&lt; &quot; &quot; &lt;&lt; temp.second &lt;&lt; endl; mData[0] = string(&quot;IMissyou&quot;); mData[-100] = string(&quot;I&quot;); mData.insert(temp); mData.insert(pair&lt;int, string&gt;(3, &quot;无名对象&quot;)); mData.insert(make_pair&lt;int, string&gt;(5, &quot;第三方函数&quot;)); mData.insert(pair&lt;int, string&gt;(3, &quot;重复处理&quot;)); //插入失败 for (auto&amp; v : mData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot;:&quot; &lt;&lt; v.second &lt;&lt; endl; &#125; mData.erase(find_if(mData.begin(), mData.end(), Compare)); cout &lt;&lt; &quot;迭代器遍历....&quot; &lt;&lt; endl; for (map&lt;int, string&gt;::iterator it = mData.begin(); it != mData.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; //多重映射 //有序性 //不支持下表法插入 cout &lt;&lt; &quot;多重映射.......&quot; &lt;&lt; endl; multimap&lt;string, string&gt; strData; // strData[string(&quot;ds&quot;)] = string(&quot;ddsfd&quot;); strData.insert(pair&lt;string, string&gt;(&quot;A&quot;, &quot;我很帅&quot;)); strData.insert(make_pair&lt;string, string&gt;(&quot;B&quot;, &quot;你很帅&quot;)); strData.insert(pair&lt;string, string&gt;(&quot;A&quot;, &quot;我很帅&quot;)); strData.insert(make_pair&lt;string, string&gt;(&quot;B&quot;, &quot;你很帅&quot;)); for (auto&amp; v : strData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //从大到小 cout &lt;&lt; &quot;传入比较准则:&quot; &lt;&lt; endl; map&lt;int, string, greater&lt;int&gt;&gt; testData; testData[1] = &quot;sdfds&quot;; testData[-1] = &quot;dfssdfsdf&quot;; testData[23] = &quot;sdfsdfsd&quot;; for (auto&amp; v : testData) &#123; cout &lt;&lt; v.first &lt;&lt; &quot; &quot; &lt;&lt; v.second &lt;&lt; endl; &#125; //操作自定义类型数据 testUserData(); testNewMap(); return 0; &#125; STL之tuple#include &lt;Algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; using namespace std; void testCreate() &#123; tuple&lt;string, int, double, double, double&gt; mmData = &#123;&quot;小芳&quot;, 18, 100.0, 100.0, 100.0&#125;; tuple&lt;string, int&gt; mm = &#123;&quot;小芳&quot;, 29&#125;; tuple&lt;string, int&gt; mm2 = make_tuple(&quot;小丽&quot;, 30); tuple&lt;string, string&gt; mm3 = forward_as_tuple(&quot;小妹&quot;, &quot;很美&quot;); tuple&lt;string&gt; str[4]; &#125; void visitedData() &#123; tuple&lt;string, int, int&gt; tup = &#123;&quot;MM&quot;, 18, 1001&#125;; // get方法获取 cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;1&gt;(tup) &lt;&lt; &quot; &quot; &lt;&lt; get&lt;2&gt;(tup) &lt;&lt; endl; string name; int age; int num; tie(name, age, num) = tup; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; //忽略数据访问方式 tie(name, ignore, ignore) = tup; cout &lt;&lt; name &lt;&lt; endl; &#125; // tuple其他操作 void testCatTuple() &#123; tuple&lt;string, string&gt; student = &#123;&quot;小美&quot;, &quot;艺术学院&quot;&#125;; tuple&lt;int, int&gt; info = &#123;18, 1001&#125;; auto mmInfo = tuple_cat(student, info); string name; string college; int age; int num; tie(name, college, age, num) = mmInfo; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; college &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testCreate(); visitedData(); testCatTuple(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之list与stack与queue","slug":"C++标准模板库之list与stack与queue","date":"2022-05-30T04:35:09.000Z","updated":"2022-09-18T02:35:58.129Z","comments":true,"path":"2022/05/30/C++标准模板库之list与stack与queue/","link":"","permalink":"http://goskp.github.io/2022/05/30/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Blist%E4%B8%8Estack%E4%B8%8Equeue/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之list#include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; private: string name; int age; int num; &#125;; int main(int argc, char** argv) &#123; //创建过程 list&lt;int&gt; iList; list&lt;string&gt; sList; list&lt;MM&gt; mmData; //插入删除遍历查找排序 for (int i = 0; i &lt; 3; i++) &#123; iList.push_back(i); //尾插法 iList.push_front(i); //头插法 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iList.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; iList.empty() &lt;&lt; endl; iList.sort(); //不影响容器中元素的打印方式 for (auto&amp; v : iList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; iList.reverse(); list&lt;int&gt;::iterator it; for (it = iList.begin(); it != iList.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //一边删除一边打印 while (!iList.empty()) &#123; cout &lt;&lt; iList.front() &lt;&lt; &quot; &quot;; //获取头元素 iList.pop_front(); //删除头部元素 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iList.size() &lt;&lt; endl; //指定位置插入 sList.push_back(&quot;ILove&quot;); sList.push_back(&quot;you&quot;); sList.insert(find(sList.begin(), sList.end(), &quot;you&quot;), &quot;IMissyou&quot;); for (auto&amp; v : sList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; sList.erase(find(sList.begin(), sList.end(), &quot;IMissyou&quot;)); for (auto&amp; v : sList) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 操作自定义类型#include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; &quot;\\t&quot; &lt;&lt; object.num; return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object) &#123; in &gt;&gt; object.name &gt;&gt; object.age &gt;&gt; object.num; return in; &#125; bool operator==(string name) const &#123; return this-&gt;name == name; &#125; // bool operator==(int age) const //&#123; // return this-&gt;age == age; // &#125; string GetName() const &#123; return name; &#125; // bool operator&lt;(const MM&amp; object) const //&#123; // return this-&gt;age &lt; object.age; // &#125; int GetAge() const &#123; return age; &#125; private: string name; int age; int num; &#125;; bool compareByAge(const MM&amp; object1, const MM&amp; object2) &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; bool compareByName(const MM&amp; object1, const MM&amp; object2) &#123; return object1.GetName() &lt; object2.GetName(); &#125; class MMSystem &#123; public: void Menu() &#123; cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t0.退出系统&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t1.录入数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t2.浏览数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t3.查找数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t4.修改数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t5.删除数据&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t6.排序显示&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入你的选择(0-6):&quot;; &#125; void KeyDown() &#123; int userKey = 0; cin &gt;&gt; userKey; switch (userKey) &#123; case 0: exit(0); break; case 1: InsertData(); break; case 2: PrintData(); break; case 3: SearchData(); break; case 4: ModifyData(); break; case 5: DeleteData(); break; case 6: // mmData.sort(compareByAge); mmData.sort(compareByName); PrintData(); break; default: break; &#125; &#125; void InsertData() &#123; MM mm; cout &lt;&lt; &quot;请输入美女基本信息:&quot;; cin &gt;&gt; mm; mmData.push_back(mm); &#125; void PrintData() &#123; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;编号&quot; &lt;&lt; endl; for (auto&amp; v : mmData) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; void SearchData() &#123; string name; cout &lt;&lt; &quot;请输入查找的姓名:&quot;; cin &gt;&gt; name; list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); if (result == mmData.end()) &#123; cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; *result &lt;&lt; endl; &#125; &#125; void ModifyData() &#123; string name; cout &lt;&lt; &quot;请输入修改的姓名:&quot;; cin &gt;&gt; name; list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); if (result == mmData.end()) &#123; cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;请输入新的信息:&quot; &lt;&lt; endl; cin &gt;&gt; *result; &#125; &#125; void DeleteData() &#123; string name; cout &lt;&lt; &quot;请输入删除的姓名:&quot;; cin &gt;&gt; name; // list&lt;MM&gt;::iterator result = find(mmData.begin(), mmData.end(), name); // if (result == mmData.end()) //&#123; // cout &lt;&lt; &quot;未找到指定位置&quot; &lt;&lt; endl; // &#125; // else //&#123; // mmData.erase(result); // &#125; list&lt;MM&gt;::iterator it; for (it = mmData.begin(); it != mmData.end();) &#123; if (it-&gt;GetName() == name) &#123; it = mmData.erase( it); //一定要这样的处理，删除后，当前it无效，不能做++运算 &#125; else &#123; it++; &#125; &#125; &#125; private: list&lt;MM&gt; mmData; &#125;; int main(int argc, char** argv) &#123; MMSystem* p = new MMSystem; while (1) &#123; p-&gt;Menu(); p-&gt;KeyDown(); system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; return 0; &#125; STL之stack栈的存储顺序是固定顺序: FILO 栈是不存在迭代器的 #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main(int argc, char** argv) &#123; //后来居上的感觉 stack&lt;int&gt; istack; for (int i = 0; i &lt; 3; i++) &#123; istack.push(i); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; istack.size() &lt;&lt; endl; while (!istack.empty()) &#123; cout &lt;&lt; istack.top() &lt;&lt; &quot; &quot;; //获取栈顶元素 istack.pop(); //出栈 &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; istack.size() &lt;&lt; endl; //悔棋，推箱子退步，寻路 //栈解决简单问题 //求进制 stack&lt;int&gt; binary; int num = 999; cout &lt;&lt; num &lt;&lt; &quot;的二进制是:&quot;; while (num) &#123; binary.push(num % 2); num /= 2; &#125; while (!binary.empty()) &#123; cout &lt;&lt; binary.top(); binary.pop(); &#125; cout &lt;&lt; endl; stack&lt;char&gt; hexData; num = 999; cout &lt;&lt; num &lt;&lt; &quot;的十六进制是:&quot;; while (num) &#123; if (num % 16 &lt; 10) &#123; hexData.push(num % 16 + &#39;0&#39;); &#125; else &#123; hexData.push(num % 16 - 10 + &#39;A&#39;); &#125; num /= 16; &#125; while (!hexData.empty()) &#123; cout &lt;&lt; hexData.top(); hexData.pop(); &#125; cout &lt;&lt; endl; return 0; &#125; STL之queue队列的存取顺序也是特定，普通队列先进先出，优先队列按照优先权出队 queue#include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int main(int argc, char** argv) &#123; queue&lt;int&gt; iQue; for (int i = 0; i &lt; 3; i++) &#123; iQue.push(i); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iQue.size() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; iQue.back() &lt;&lt; endl; while (!iQue.empty()) &#123; cout &lt;&lt; iQue.front() &lt;&lt; &quot; &quot;; iQue.pop(); &#125; cout &lt;&lt; &quot;size:&quot; &lt;&lt; iQue.size() &lt;&lt; endl; return 0; &#125; deque#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; deque&lt;string&gt; queData; queData.push_back(&quot;尾部&quot;); queData.push_front(&quot;头部&quot;); while (!queData.empty()) &#123; cout &lt;&lt; queData.front(); queData.pop_front(); &#125; cout &lt;&lt; endl; deque&lt;string&gt; str; str.push_back(&quot;ILoveyou&quot;); str.push_front(&quot;IMissyou&quot;); while (!str.empty()) &#123; cout &lt;&lt; str.back(); str.pop_back(); &#125; cout &lt;&lt; endl; return 0; &#125; priority_queue#include &lt;ctime&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; string GetName() const &#123; return name; &#125; int GetAge() const &#123; return age; &#125; bool operator&lt;(const MM&amp; object) const &#123; return this-&gt;age &lt; object.age; &#125; private: string name; int age; &#125;; //仿函数 class CompareByName &#123; public: bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetName() &lt; object2.GetName(); &#125; &#125;; class CompareByAge &#123; public: bool operator()(const MM&amp; object1, const MM&amp; object2) const &#123; return object1.GetAge() &lt; object2.GetAge(); &#125; &#125;; int main(int argc, char** argv) &#123; //优先队列 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; lessQueue; priority_queue&lt;int, vector&lt;int&gt;&gt; lessQue; //和上面是等效的 srand((unsigned int)time(nullptr)); for (int i = 0; i &lt; 10; i++) &#123; lessQue.push(rand() % 100); &#125; while (!lessQue.empty()) &#123; cout &lt;&lt; lessQue.top() &lt;&lt; &quot; &quot;; lessQue.pop(); &#125; cout &lt;&lt; endl; //从小到大 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; greaterQue; for (int i = 0; i &lt; 10; i++) &#123; greaterQue.push(rand() % 100); &#125; while (!greaterQue.empty()) &#123; cout &lt;&lt; greaterQue.top() &lt;&lt; &quot; &quot;; greaterQue.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, less&lt;MM&gt;&gt; mmData; mmData.push(MM(&quot;baby&quot;, 19)); mmData.push(MM(&quot;anni&quot;, 28)); mmData.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData.empty()) &#123; cout &lt;&lt; mmData.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData.top().GetAge() &lt;&lt; endl; mmData.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, CompareByName&gt; mmData1; mmData1.push(MM(&quot;baby&quot;, 19)); mmData1.push(MM(&quot;anni&quot;, 28)); mmData1.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData1.empty()) &#123; cout &lt;&lt; mmData1.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData1.top().GetAge() &lt;&lt; endl; mmData1.pop(); &#125; priority_queue&lt;MM, vector&lt;MM&gt;, CompareByAge&gt; mmData2; mmData2.push(MM(&quot;baby&quot;, 19)); mmData2.push(MM(&quot;anni&quot;, 28)); mmData2.push(MM(&quot;sanshui&quot;, 21)); cout &lt;&lt; endl; while (!mmData2.empty()) &#123; cout &lt;&lt; mmData2.top().GetName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mmData2.top().GetAge() &lt;&lt; endl; mmData2.pop(); &#125; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++标准模板库之array与vector","slug":"C++标准模板库之array与vector","date":"2022-05-27T06:16:07.000Z","updated":"2022-09-18T02:36:04.289Z","comments":true,"path":"2022/05/27/C++标准模板库之array与vector/","link":"","permalink":"http://goskp.github.io/2022/05/27/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E4%B9%8Barray%E4%B8%8Evector/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 STL之arary array就是定长数组，任何类型定长数组 /* array 创建对象的两种方式, 常对象,和指针 size(),back(),front()方法 下标: at(i) 正向,逆向,迭代器遍历方法 */ #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char* argv[]) &#123; int inum[3] = &#123;1, 2, 3&#125;; //定长数组 array&lt;int, 3&gt; number = &#123;1, 2, 3&#125;; array&lt;string, 3&gt;* p_str = new array&lt;string, 3&gt;; (*p_str)[0] = &quot;string1&quot;; (*p_str)[1] = &quot;string2&quot;; (*p_str)[2] = &quot;sdfasf&quot;; cout &lt;&lt; &quot;size:&quot; &lt;&lt; number.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; number.empty() &lt;&lt; endl; for (int i = 0; i &lt; number.size(); i++) &#123; cout &lt;&lt; number[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; number.back() &lt;&lt; endl; cout &lt;&lt; number.front() &lt;&lt; endl; for (int i = 0; i &lt; number.size(); i++) &#123; cout &lt;&lt; number.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; p_str-&gt;size(); i++) &#123; cout &lt;&lt; p_str-&gt;at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //正向 array&lt;int, 3&gt;::iterator it = number.begin(); for (; it != number.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //反向 array&lt;int, 3&gt;::reverse_iterator rit = number.rbegin(); for (; rit != number.rend(); rit++) &#123; cout &lt;&lt; *rit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;第一个元素:&quot; &lt;&lt; *number.begin() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素:&quot; &lt;&lt; *number.rbegin() &lt;&lt; endl; // cout &lt;&lt; &quot;end:&quot; &lt;&lt; *number.end() &lt;&lt; endl; 任何end都不能取值运算 delete p_str; return 0; &#125; STL之vector vector是动态数组 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char** argv) &#123; // No.1 不带长度的构建方式 //不能直接用下标方式去操作 vector&lt;int&gt; num; // num[0] = 1; 中断 vector&lt;int&gt; number = &#123;1, 2, 3&#125;; // number[3] = 333; 中断 超过原来长度 // No.2 带长度的构造方式,在长度范围内可以直接下标法访问 vector&lt;string&gt; str(3); // 3代表数组长度 str[0] = &quot;sdfsd&quot;; str[1] = &quot;sdfsdfsd&quot;; str[2] = &quot;sdfsdfsdsd&quot;; // str[3] = &quot;sdfsdfsdfsd&quot;; //中断 // No.3 带自动增长功能是在成员函数中完成 // push_back(T data); str.push_back(&quot;sdfsdfsd&quot;); num.push_back(12); vector&lt;int&gt; test(3); test.push_back(999); for (auto&amp; v : test) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt;::iterator it; for (it = test.begin(); it != test.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt;::reverse_iterator rit; for (rit = test.rbegin(); rit != test.rend(); rit++) &#123; cout &lt;&lt; *rit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //成员函数 cout &lt;&lt; &quot;第一个元素:&quot; &lt;&lt; test.front() &lt;&lt; &quot;\\t&quot; &lt;&lt; *test.begin() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个二元素:&quot; &lt;&lt; test.back() &lt;&lt; &quot;\\t&quot; &lt;&lt; *test.rbegin() &lt;&lt; &quot;\\t&quot; &lt;&lt; *(test.end() - 1) &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素:&quot; &lt;&lt; test.at(test.size() - 1) &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; test.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; test.empty() &lt;&lt; endl; return 0; &#125; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; //如果想要构建一个无参array MM(string name, int age) : name(name), age(age) &#123;&#125; void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; void initArray(array&lt;MM, 3&gt;&amp; mmData) &#123; mmData[0] = MM(&quot;name1&quot;, 18); mmData[1] = MM(&quot;name2&quot;, 29); mmData[2] = MM(&quot;name3&quot;, 38); &#125; void printMM(array&lt;MM, 3&gt; mmData) &#123; for (auto&amp; v : mmData) &#123; v.printData(); &#125; &#125; void testArray() &#123; array&lt;MM, 3&gt; mmData; initArray(mmData); printMM(mmData); for (int i = 0; i &lt; mmData.size(); i++) &#123; mmData[i].printData(); &#125; &#125; void printVector(vector&lt;MM&gt; mmData) &#123; for (auto&amp; v : mmData) &#123; // cout &lt;&lt; v &lt;&lt; &quot; &quot;; v.printData(); &#125; &#125; void testVector() &#123; vector&lt;MM&gt; mmData; mmData.push_back(MM(&quot;name1&quot;, 23)); mmData.push_back(MM(&quot;name2&quot;, 25)); mmData.push_back(MM(&quot;name3&quot;, 45)); printVector(mmData); &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;array:&quot; &lt;&lt; endl; testArray(); cout &lt;&lt; &quot;vector:&quot; &lt;&lt; endl; testVector(); return 0; &#125; 互相嵌套#include &lt;time.h&gt; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void testArray() &#123; array&lt;array&lt;int, 4&gt;, 3&gt; data; //三乘四二维数组 for (int i = 0; i &lt; data.size(); i++) &#123; for (int j = 0; j &lt; data[i].size(); j++) &#123; data[i][j] = j + i * data.size(); //随便赋值的 cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; array&lt;array&lt;array&lt;int, 4&gt;, 4&gt;, 4&gt;; //三维数组 &#125; void testVector() &#123; vector&lt;vector&lt;int&gt;&gt; data; //不等长的二维数组 for (int i = 0; i &lt; 3; i++) &#123; int length = rand() % 5 + 1; vector&lt;int&gt; temp; for (int j = 0; j &lt; length; j++) &#123; temp.push_back(j); &#125; data.push_back(temp); &#125; for (int i = 0; i &lt; data.size(); i++) &#123; for (int j = 0; j &lt; data[i].size(); j++) &#123; cout &lt;&lt; data[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; void testArrayVector() &#123; array&lt;vector&lt;int&gt;, 3&gt; test1; test1[0] = vector&lt;int&gt;&#123;1, 2, 3&#125;; test1[1] = vector&lt;int&gt;&#123;1, 2, 3, 4, 5&#125;; test1[2] = vector&lt;int&gt;&#123;1&#125;; for (int i = 0; i &lt; test1.size(); i++) &#123; for (int j = 0; j &lt; test1[i].size(); j++) &#123; cout &lt;&lt; test1[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; vector&lt;array&lt;int, 3&gt;&gt; test2; test2.push_back(array&lt;int, 3&gt;&#123;1, 2, 3&#125;); test2.push_back(array&lt;int, 3&gt;&#123;3, 3, 3&#125;); test2.push_back(array&lt;int, 3&gt;&#123;4, 4, 4&#125;); for (int i = 0; i &lt; test2.size(); i++) &#123; for (int j = 0; j &lt; test2[i].size(); j++) &#123; cout &lt;&lt; test2[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; srand((unsigned int)time(nullptr)); cout &lt;&lt; &quot;array嵌套:&quot; &lt;&lt; endl; testArray(); cout &lt;&lt; &quot;vector嵌套:&quot; &lt;&lt; endl; testVector(); cout &lt;&lt; &quot;array与vector嵌套:&quot; &lt;&lt; endl; testArrayVector(); return 0; &#125; 嵌套模板#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; struct MMInfo &#123; string name; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MMInfo&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MMInfo&amp; object) &#123; in &gt;&gt; object.name &gt;&gt; object.age; return in; &#125; struct Score &#123; int math; int english; int py; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const Score&amp; object) &#123; out &lt;&lt; object.math &lt;&lt; &quot;\\t&quot; &lt;&lt; object.english &lt;&lt; &quot;\\t&quot; &lt;&lt; object.py; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, Score&amp; object) &#123; in &gt;&gt; object.math &gt;&gt; object.english &gt;&gt; object.py; return in; &#125; struct Sum &#123; MMInfo info; Score score; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const Sum&amp; object) &#123; out &lt;&lt; object.info &lt;&lt; &quot;\\t&quot; &lt;&lt; object.score; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, Sum&amp; object) &#123; in &gt;&gt; object.info &gt;&gt; object.score; return in; &#125; template &lt;class _Ty&gt; class MM &#123; public: void insertData(_Ty data) &#123; this-&gt;data.push_back(data); &#125; void printData() &#123; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; private: vector&lt;_Ty&gt; data; &#125;; int main(int argc, char** argv) &#123; //管理基本信息 MM&lt;MMInfo&gt; mm; MMInfo temp; cout &lt;&lt; &quot;请输入美女信息:&quot;; cin &gt;&gt; temp; mm.insertData(temp); mm.printData(); //管理分数 MM&lt;Score&gt; mmScore; Score score; cout &lt;&lt; &quot;输入美女分数:&quot;; cin &gt;&gt; score; mmScore.insertData(score); mmScore.printData(); //管理分数和基本信息 MM&lt;Sum&gt; sum; Sum tempSum; cin &gt;&gt; tempSum; sum.insertData(tempSum); sum.printData(); return 0; &#125; 自制array#include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class _Ty, size_t _size&gt; class my_array &#123; public: _Ty&amp; operator[](int index) &#123; return elem[index]; &#125; _Ty at(int index) &#123; return elem[index]; &#125; int size() const &#123; return _size; &#125; bool empty() const &#123; return _size == 0; &#125; _Ty back() &#123; return elem[_size - 1]; &#125; _Ty front() &#123; return elem[0]; &#125; _Ty* begin() &#123; return elem; &#125; _Ty* end() &#123; return elem + _size; &#125; class iterator &#123; public: void operator=(_Ty* pmove) &#123; this-&gt;pmove = pmove; &#125; _Ty operator*() &#123; return pmove[0]; &#125; bool operator!=(_Ty* pmove) &#123; return this-&gt;pmove != pmove; &#125; void operator++() &#123; this-&gt;pmove++; &#125; private: _Ty* pmove; &#125;; private: _Ty elem[_size]; &#125;; int main(int argc, char** argv) &#123; my_array&lt;int, 3&gt; data; data[0] = 1; data[1] = 2; data[2] = 3; for (auto&amp; v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; my_array&lt;int, 3&gt;::iterator it; for (it = data.begin(); it != data.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; data.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; data.empty() &lt;&lt; endl; array&lt;int, 4&gt; stl_array; cout &lt;&lt; &quot;size:&quot; &lt;&lt; stl_array.size() &lt;&lt; endl; cout &lt;&lt; &quot;empty:&quot; &lt;&lt; stl_array.empty() &lt;&lt; endl; return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++模板","slug":"C++模板","date":"2022-05-26T00:32:18.000Z","updated":"2022-09-18T02:35:46.461Z","comments":true,"path":"2022/05/26/C++模板/","link":"","permalink":"http://goskp.github.io/2022/05/26/C++%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++模板什么是模板模板编程也可以叫做泛型编程，忽略数据类型的一种编程方式 //求最值问题 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; double Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; string Max(string a, string b) &#123; return a &gt; b ? a : b; &#125; //引入模板编程 template &lt;typename type&gt; //告诉编译器，下面会用到一个未知类型叫做type type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; 模板代码 #include &lt;iostream&gt; using namespace std; template &lt;typename type&gt; type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; // typename 可以用class 替换 template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; //隐式调用 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; cout &lt;&lt; Max(1.1, 2.2) &lt;&lt; endl; // string 和char* 有区别 cout &lt;&lt; Max(string(&quot;1ILoveyou&quot;), string(&quot;2IMissyou&quot;)) &lt;&lt; endl; //显示调用 &lt;&gt;传类型的参数 cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; // type=int a=1 b=2 cout &lt;&lt; Max&lt;string&gt;(string(&quot;1&quot;), string(&quot;2&quot;)) &lt;&lt; endl; cout &lt;&lt; Max&lt;double&gt;(1.2, 1.3) &lt;&lt; endl; return 0; &#125; 函数模板函数模板重载问题 函数模板和普通函数 函数模板和函数模板 #include &lt;iostream&gt; using namespace std; // No.1 模板与普通函数 int Max(int a, int b) &#123; cout &lt;&lt; &quot;普通函数...&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; template &lt;class T&gt; T Max(T a, T b) &#123; cout &lt;&lt; &quot;模板&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; // No.2 模板与模板 template &lt;class type1, class type2, class type3&gt; void print(type1 one, type2 two, type3 three) &#123; cout &lt;&lt; &quot;三只&quot; &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; // type1=int type2=double void print(type1 one, type1 two, type2 tow) &#123; // int int double cout &lt;&lt; &quot;两只&quot; &lt;&lt; endl; &#125; template &lt;class type&gt; void print(type one, type two, type three) &#123; cout &lt;&lt; &quot;一只&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; //显式调用，百分百调用模板 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; //优先调用类型确定的函数 cout &lt;&lt; &quot;显示调用&quot; &lt;&lt; endl; print&lt;int, double, string&gt;(1, 1.1, string(&quot;23&quot;)); print&lt;int, double&gt;(1, 1, 1.22); print&lt;int&gt;(1, 2, 3); cout &lt;&lt; &quot;隐式调用&quot; &lt;&lt; endl; print(1, 1, 2); //需要传参越少先调用 print(1, 1, string(&quot;sdsd&quot;)); print(1, 1.11, string(&quot;sdsd&quot;)); //只有一种选择 return 0; &#125; 类成员函数是函数模板//这种不叫做模板类型 class MM &#123; public: template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; MM mm; mm.print(1); mm.print&lt;string&gt;(&quot;string&quot;); return 0; &#125; 函数模板缺省函数模板缺省和函数参数的缺省是一样的规则 //函数模板缺省 template &lt;class type1,class type2=string&gt; void printData(type1 one, type2 two) &#123; cout &lt;&lt; one &lt;&lt; endl; cout &lt;&lt; two &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; printData&lt;int, double&gt;(1, 1.22); printData&lt;int&gt;(1, string(&quot;dsfsdf&quot;)); return 0; &#125; 函数模板传常量//函数模板传常量 template &lt;class T,size_t size&gt; void printArray(T* array) &#123; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; int num[3] = &#123; 1,2,3 &#125;; printArray&lt;int, 3&gt;(num); //下面代码报错 //int length = 3; //printArray&lt;int, length&gt;(num); string str[4] = &#123; &quot;sdds&quot;,&quot;sd&quot;,&quot;sdsd&quot; ,&quot;sdds&quot;&#125;; printArray&lt;string, 4&gt;(str); return 0; &#125; 类模板 类模板不是一个完整类型，所以任何用到类名的地方都需要用类名&lt;未知类型&gt;的方式使用 怎么去使用类模板，类模板必须采用显式调用方式 类模板在多文件中不能分开写 可以写在.hpp文件中(声明和实现都在一起) #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; template &lt;class type1, class type2&gt; struct my_pair &#123; type1 first; //键 type2 second; //值 my_pair(type1 first, type2 second) : first(first), second(second) &#123;&#125; my_pair() = default; &#125;; template &lt;class type1, class type2&gt; my_pair&lt;type1, type2&gt; my_make_pair(type1 one, type2 two) &#123; return my_pair&lt;type1, type2&gt;(one, two); &#125; template &lt;class type1, class type2&gt; class Test &#123; public: Test(type1 one, type2 two) : one(one), two(two) &#123;&#125; void printTest(); protected: type1 one; type2 two; &#125;; template &lt;class type1, class type2&gt; void Test&lt;type1, type2&gt;::printTest() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; class Data : public Test&lt;type1, type2&gt; &#123; public: Data(type1 one, type2 two) : Test&lt;type1, type2&gt;(one, two) &#123;&#125; protected: &#125;; int main(int argc, char** argv) &#123; my_pair&lt;int, int&gt; pairData = &#123;1, 2&#125;; cout &lt;&lt; pairData.first &lt;&lt; &quot; &quot; &lt;&lt; pairData.second &lt;&lt; endl; my_pair&lt;int, string&gt;* p = new my_pair&lt;int, string&gt;; p-&gt;first = 12; p-&gt;second = &quot;sdsd&quot;; cout &lt;&lt; p-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;second &lt;&lt; endl; Data&lt;int, int&gt; data(1, 2); data.printTest(); //标准库中的pair类型 pair&lt;int, string&gt; pD(1, &quot;ILoveyou&quot;); cout &lt;&lt; pD.first &lt;&lt; &quot; &quot; &lt;&lt; pD.second &lt;&lt; endl; pair&lt;int, string&gt; testData = make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); my_pair&lt;int, string&gt; my_testData = my_make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); return 0; &#125; 类模板特化问题 局部特化 完全特化 特化的目的是为了适应不同数据的不同处理 #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; (one + two + three) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; //局部特化 //两个数据,打印两数之差 template &lt;class _Ty1, class _Ty2&gt; class Data&lt;_Ty1, _Ty1, _Ty2&gt; &#123; public: Data(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; (one - two) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; &#125;; //只有一个数据,打印数据 template &lt;class _Ty1&gt; class Data&lt;_Ty1, _Ty1, _Ty1&gt; &#123; public: Data(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; private: _Ty1 one; &#125;; //完全特化 template &lt;&gt; class Data&lt;string, string, string&gt; &#123; public: Data(string one, string two, string three) : one(one), two(two), three(three) &#123;&#125; void printData(); private: string one; string two; string three; &#125;; void Data&lt;string, string, string&gt;::printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data1(1); data1.printData(); Data&lt;int, int, double&gt; data2(2, 1); data2.printData(); Data&lt;int, double, float&gt; data3(1, 1.1, 1.2f); data3.printData(); Data&lt;string, string, string&gt; data4(&quot;dsd&quot;, &quot;sdfd&quot;, &quot;sdfdsf&quot;); data4.printData(); return 0; &#125; 模板操作自定义类型 模板操作自定义关键点在于重载 #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() = default; MM(string name, int age) : name(name), age(age) &#123;&#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot; &quot; &lt;&lt; object.age; return out; &#125; private: string name; int age; &#125;; template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: //_Ty1=MM, _Ty2=int, _Ty3=int Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; int main(int argc, char** argv) &#123; printData(1); printData(&quot;string&quot;); MM mm = &#123;&quot;小芳&quot;, 18&#125;; printData(mm); Data&lt;MM, int, int&gt; data(MM(&quot;小芳&quot;, 18), 98, 99); data.printData(); Data&lt;MM, MM, MM&gt; mmData(MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18)); mmData.printData(); return 0; &#125; 模板嵌套模板 (类型是由类名&lt;类型&gt;表示一个类型） #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Data&lt;_Ty1, _Ty2, _Ty3&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot; &lt;&lt; object.three; return out; &#125; protected: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; template &lt;class _Ty1, class _Ty2&gt; class Info &#123; public: Info(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; // template &lt;class _Ty1, class _Ty2&gt; 类中实现不需要修饰了，会出现重定义问题 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Info&lt;_Ty1, _Ty2&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot;; return out; &#125; protected: _Ty1 one; _Ty2 two; &#125;; template &lt;class _Ty1&gt; class Student &#123; public: Student(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; protected: _Ty1 one; &#125;; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data(1, 1, 1); // Data&lt;int, int, int&gt; Info&lt;int, int&gt; info(1, 2); // Info&lt;int, int&gt; Info&lt;Data&lt;int, int, int&gt;, Data&lt;string, string, string&gt;&gt; test1( Data&lt;int, int, int&gt;(1, 1, 1), Data&lt;string, string, string&gt;(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); //起别名 using type1 = Data&lt;int, int, int&gt;; using type2 = Data&lt;string, string, string&gt;; //别名版本 Info&lt;type1, type2&gt; test2(type1(1, 1, 1), type2(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); Data&lt;Info&lt;int, string&gt;, Info&lt;string, string&gt;, Info&lt;int, double&gt;&gt; test3( Info&lt;int, string&gt;(1, &quot;sd&quot;), Info&lt;string, string&gt;(&quot;sdds&quot;, &quot;dsds&quot;), Info&lt;int, double&gt;(1, 1.11)); test1.printData(); test2.printData(); test3.printData(); Student&lt;Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;&gt; stu( Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;( Info&lt;int, int&gt;(1, 1), Info&lt;int, string&gt;(1, &quot;sdsd&quot;), Info&lt;string, string&gt;(&quot;sds&quot;, &quot;sdsd&quot;))); stu.printData(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++异常处理","slug":"C++异常处理","date":"2022-05-25T08:26:04.000Z","updated":"2022-09-18T02:35:39.979Z","comments":true,"path":"2022/05/25/C++异常处理/","link":"","permalink":"http://goskp.github.io/2022/05/25/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++异常处理异常处理基操抛出异常: throw 抛出的东西一定一个值 **检查异常:**try **捕获处理异常:**catch 注意： try和catch必须一起出现，并且各自的{}不能省略 #include &lt;iostream&gt; using namespace std; int Div(int a, int b) &#123; //正常写程序 有问题立刻处理 // if (b == 0) //&#123; // cout &lt;&lt; &quot;除数不能为0&quot; &lt;&lt; endl; // return 0; //&#125; if (b == 0) &#123; throw 0; &#125; return a / b; &#125; int main(int argc, char** argv) &#123; // Div(1, 0); //调用abort函数终止程序 try &#123; cout &lt;&lt; &quot;测试.....1&quot; &lt;&lt; endl; Div(1, 0); cout &lt;&lt; &quot;测试.....2&quot; &lt;&lt; endl; &#125; catch (double) &#123; //捕获int类型异常 cout &lt;&lt; &quot;double:除数不能为零&quot; &lt;&lt; endl; &#125; catch (int) &#123; cout &lt;&lt; &quot;int:除数不能为零&quot; &lt;&lt; endl; &#125; // error C2312: “int”: 由“int”在行 28 上捕获 // catch (int) //&#123; // cout &lt;&lt; &quot;int:除数不能为零&quot; &lt;&lt; endl; //&#125; return 0; &#125; 没有异常int Max(int a, int b) throw() &#123; return a &gt; b ? a : b; &#125; //新标准 int Sum(int a, int b) noexcept &#123; return a + b; &#125; 异常处理的传参操作#include &lt;iostream&gt; using namespace std; void printArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 1; &#125; cout &lt;&lt; &quot;正常长度，假装打印....&quot; &lt;&lt; endl; &#125; void searchArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 2; &#125; cout &lt;&lt; &quot;正常长度，假装查找....&quot; &lt;&lt; endl; &#125; void deleteArray(int array[], int arrayNum) &#123; if (arrayNum &lt; 1) &#123; throw 3; &#125; cout &lt;&lt; &quot;正常长度，假装删除....&quot; &lt;&lt; endl; &#125; int Div(int a, int b) &#123; if (b == 0) &#123; throw string(&quot;除数不能为零&quot;); &#125; return a / b; &#125; //抛出自己类对象:自定义异常类 class stackEmpty &#123; public: stackEmpty(string strInfo) : strinfo(strInfo) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;error:&quot; &lt;&lt; strinfo &lt;&lt; endl; &#125; private: string strinfo; &#125;; //假装入栈 void push(int a) &#123; if (a == 0) &#123; throw stackEmpty(&quot;栈为空&quot;); &#125; cout &lt;&lt; a &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; try &#123; int array[3] = &#123;1, 2, 3&#125;; printArray(array, 3); searchArray(array, -1); deleteArray(array, 2); &#125; catch (int value) &#123; // int value=抛出的值 switch (value) &#123; case 1: cout &lt;&lt; &quot;打印异常&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;查找异常&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;删除异常&quot; &lt;&lt; endl; break; &#125; &#125; try &#123; cout &lt;&lt; Div(2, 1) &lt;&lt; endl; cout &lt;&lt; Div(2, 0) &lt;&lt; endl; &#125; catch (string&amp; object) &#123; cout &lt;&lt; object &lt;&lt; endl; &#125; //... 表示可以捕获任何异常 try &#123; cout &lt;&lt; Div(2, 0) &lt;&lt; endl; &#125; catch (...) &#123; //删减符 cout &lt;&lt; &quot;引发异常&quot; &lt;&lt; endl; &#125; try &#123; push(1233); push(0); &#125; catch (stackEmpty&amp; object) &#123; object.print(); &#125; return 0; &#125; 标准库中的异常exception类组成: what方法 用来返回异常信息的字符串 #include &lt;exception&gt; #include &lt;iostream&gt; using namespace std; class Error : public exception &#123; public: // virtual char const* what() const //&#123; // return &quot;Error&quot;; // &#125; Error() : exception(&quot;Error&quot;) &#123;&#125; private: &#125;; void printTest() &#123; throw Error(); &#125; int main(int argc, char** argv) &#123; try &#123; printTest(); &#125; catch (Error&amp; object) &#123; cout &lt;&lt; object.what() &lt;&lt; endl; &#125; return 0; &#125; 引发ball_alloc异常#include &lt;exception&gt; #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; int array[3] = &#123;1, 2, 3&#125;; try &#123; while (1) &#123; int* p = new int[1024 * 1024]; &#125; &#125; catch (bad_alloc&amp; object) &#123; cout &lt;&lt; object.what() &lt;&lt; endl; &#125; return 0; &#125; 感觉有点鸡肋,不写了…我不太理解这个异常处理","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++IO流","slug":"C++IO流","date":"2022-05-24T08:11:36.000Z","updated":"2022-09-18T02:35:30.877Z","comments":true,"path":"2022/05/24/C++IO流/","link":"","permalink":"http://goskp.github.io/2022/05/24/C++IO%E6%B5%81/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++IO流流的概念流就是若干字节组成字节序列，流操作从一个到另一个移动的过程 流中的内容:二进制数据 ASCII码 流类体系C++中用类实现所有流类操作 标准的输入输出流 C++格式控制 字符流 文件流 #include &lt;iostream&gt; //istream ostream #include &lt;fstream&gt; //ifstream ofstream #include &lt;strstream&gt; //istringstream using namespace std; int main(int argc, char** argv) &#123; fstream out; ifstream iin; return 0; &#125; 标准输入输出流 对象 类型 作用 cin 标准输入 从键盘读取，可以重定向 cout 标准输出 输出到控制台，可以重定向 cerr 标准错误输出 输出到控制台，不可以重定向 clog 标准错误输出 输出到控制台，可重定向 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; return 0; &#125; 字符和字符串输入 cout成员函数 put() : 输出一个字符 write(): 输出字符串 cin成员函数 get()：输入一个字符 getline: 输入一个字符串 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; //字符输入 cout &lt;&lt; &quot;字符输入:&quot; &lt;&lt; endl; int userKey = cin.get(); cout.put(userKey); char str[10] = &#123; &quot;&quot; &#125;; cout &lt;&lt; &quot;字符串输入:&quot; &lt;&lt; endl; while (getchar() != &#39;\\n&#39;); cin.getline(str, 10); //10个长度包含\\0 cout &lt;&lt; str &lt;&lt; endl; cout.write(str, 10); return 0; &#125; C++格式控制 包含头文件: iomanip 通过对象的形式，一种通过成员的函数形式 对象形式 实际含义 setbase(n) 设置多少进制输出整数(参数是8和16) setw(n) 设置输出数据宽度(默认对齐是右对齐，不足补空格) setiosflags(ios::left) 设置对齐方式: ios::left ,ios::right setprecition(n) 单纯使用是控制有效位数，如果控制小数位数结合fixed setfill(n) 填充字符 #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int main(int argc, char** argv) &#123; //进制输出 cout &lt;&lt; setbase(16) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; setbase(8) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt;showbase&lt;&lt; hex &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; dec &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; noshowbase&lt;&lt;oct &lt;&lt; 32 &lt;&lt; endl; //cout &lt;&lt; setbase(2) &lt;&lt; 32 &lt;&lt; endl; //无效 //默认右对齐 cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setiosflags(ios::left); cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setprecision(4) &lt;&lt; 300.12345 &lt;&lt; endl; //直接用控制的是有效位数 cout &lt;&lt; fixed&lt;&lt;setprecision(4) &lt;&lt; 300.12349 &lt;&lt; endl; //小数位数 cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; 300.12345 &lt;&lt; endl; //所有的格式控制存在成员函数的调用形式 cout.width(8); cout &lt;&lt; &quot;姓名&quot;; cout.width(8); cout &lt;&lt; 1 &lt;&lt; endl; cout.precision(4); //取消上述格式 cout &lt;&lt;resetiosflags &lt;&lt;300.333 &lt;&lt; endl; bool num = 1; cout &lt;&lt; boolalpha &lt;&lt; num &lt;&lt; endl; //true和false形式输出bool类型 return 0; &#125; 字符流 包含头文件： sstream istringstream ostringstream stringstream 一般处理字符流的时候用的是stringstream类型的对象 获取字符流中的stirng string str(); &#x2F;&#x2F;获取string void str(const string&amp; str) &#x2F;&#x2F;重置流对象中字符串 字符流做什么 数据类型的转换 数据的分割 #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; stringstream stream(&quot;ILoveyou&quot;); cout &lt;&lt; stream.str() &lt;&lt; endl; char str[20] = &quot;&quot;; stream &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; stream.str(&quot;&quot;); //清除 //数据类型转换 //整数转字符串,字符串转数字 string num = to_string(123); cout &lt;&lt; num &lt;&lt; endl; int inumber = 12123; char result[20] = &#123; &quot;&quot; &#125;; stringstream buf(result); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; stringstream strNum(&quot;12345435&quot;); int dataNum = 0; strNum &gt;&gt; dataNum; cout &lt;&lt; dataNum &lt;&lt; endl; //数据切割(流中默认空格作为单一数据的间隔) stringstream ip(&quot;ip: 192.168.1.1&quot;); char strip[20] = &#123; &quot;&quot; &#125;; ip &gt;&gt; strip; //ip: 拿出来 int ipNum[4]; char userKey; ip &gt;&gt; ipNum[0]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[1]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[2]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[3]; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; ipNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; //注意点： 流在做转换的，必须调用clear清除处理 buf.clear(); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; 文件操作流 包含头文件: fstream ofstream: 打开文件只能写操作 ifstream: 打开文件只读操作 一般大家创建一个fstream对象，可读可写 打开文件 构造的方式,带参数构造函数：const char* URL,ios::openmode mode 成员函数方式: void open(const char* URL,ios::openmode mode) 判断文件打开是否成功 !is_open()函数判断是否打开成功 ,!is_open()是1的打开失败 !文件对象 .!对象是1打开失败 读写方式 作用 ios::in 读的方式打开文件 ios::out 写的方式打开文件 ios::app 追加写文件 ios::ate 打开已有文件，指针在文件末位 ios::trunc 文件不存在具有创建方式 ios::binary 二进制打开，默认打开方式ASCII码 ios::nocreate 不创建 ios::noreplace 不替换 组合方式: 用位或, 可读可写: ios::in|ios::out 关闭文件 close关闭文件 文件读写 直接采用&gt;&gt; &lt;&lt;符号进行读写 采用成员函数读写：read函数和write成员函数 文件指针移动 ifstream文件指针 ifstream&amp; seekg(long int pos); ifstream&amp; seekg(long int pos,ios_base::seekdir begin); ofstream文件指针 ofstream&amp; seekp(long int pos); ofstream&amp; seekp(long int pos,ios_base::seekdir begin); begin: ios::beg 开始位置 ios::cur 当前位置 ios::end 结束位置 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //采用&gt;&gt; &lt;&lt; void saveFile(string fileName) &#123; fstream file(fileName, ios::in | ios::out | ios::app); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; file &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; file.close(); &#125; void readFile(string fileName) &#123; fstream file(fileName, ios::in); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; while (true) &#123; MM temp; file &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; if (file.eof()) &#123; break; &#125; temp.print(); &#125; file.close(); &#125; protected: string name; int age; int num; &#125;; void asciiRWFile(string readFile, string writeFile) &#123; //流的方式 //字符或者字符串的 fstream read(readFile, ios::in); fstream write(writeFile, ios::out); while (!read.eof()) &#123; char userkey = read.get(); // getline() write.put(userkey); // write()函数 &#125; read.close(); write.close(); &#125; //二进制读写 void binaryRWFile(string readFile, string writeFile) &#123; fstream r(readFile, ios::in | ios::binary); fstream w(writeFile, ios::out | ios::binary); while (!r.eof()) &#123; char str[1024] = &#123;&quot;&quot;&#125;; //缓冲区 r.read(str, 1024); w.write(str, strlen(str)); //长度写多少就写入文件多少 &#125; r.close(); w.close(); &#125; //文件指针移动 int getSize(string fileName) &#123; fstream read(fileName, ios::in | ios::binary); read.seekg(0, ios::end); int size = read.tellg(); read.close(); return size; &#125; int main(int argc, char** argv) &#123; //打开文件测试 // fstream file(&quot;xxoo.txt&quot;,ios::in|ios::out|ios::trunc); //等效下面两行 fstream file; file.open(&quot;xxoo.txt&quot;, ios::in | ios::out | ios::trunc); if (!file || !file.is_open()) &#123; cerr &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; file.close(); MM mm(&quot;xxx&quot;, 18, 1001); mm.saveFile(&quot;mm.txt&quot;); mm.readFile(&quot;mm.txt&quot;); asciiRWFile(&quot;mm.txt&quot;, &quot;xxoo.txt&quot;); binaryRWFile(&quot;xxoo.txt&quot;, &quot;rw.txt&quot;); cout &lt;&lt; &quot;size:&quot; &lt;&lt; getSize(&quot;size.txt&quot;) &lt;&lt; endl; return 0; &#125; //用write写入对象数组数据放到文件 //用read把数据读取出来，可以存储到对象数组中，打印出来 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* name, int age, int num) : age(age), num(num) &#123; strcpy(this-&gt;name, name); &#125; void writeFile(const char* fileName) &#123; fstream fread(fileName, ios::out | ios::app | ios::binary); fread.write((char*)this, sizeof(MM)); fread.close(); &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object); protected: char name[20]; int age; int num; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; &quot;\\t&quot; &lt;&lt; object.num &lt;&lt; endl; return out; &#125; void readFile(const char* fileName, MM* temp, int size) &#123; fstream fread(fileName, ios::in | ios::binary); // char str[1024] = &#123; &quot;&quot; &#125;; while (1) &#123; if (fread.eof()) break; fread.read((char*)temp, size); &#125; fread.close(); &#125; int main(int argc, char** argv) &#123; &#123; // MM array[3] = &#123; &#123;&quot;张三&quot;,18,1001&#125;,&#123;&quot;小美&quot;,28,1002&#125;,&#123;&quot;小丽&quot;,38,1003&#125; &#125;; // MM temp[3]; // readFile(&quot;mm.txt&quot;, temp, 3 * sizeof(MM)); // for (int i = 0; i &lt; 3; i++) //&#123; // cout &lt;&lt; temp[i]; //&#125; &#125; cout &lt;&lt; &quot;dsafdsfasda&quot; &lt;&lt; endl; fstream read(&quot;xx.txt&quot;, ios::in | ios::trunc | ios::_Nocreate); // ios::app: 追加方式，不能替换原文件 if (!read) &#123; cout &lt;&lt; &quot;文件打开失败!&quot; &lt;&lt; endl; return 0; &#125; read.close(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++虚函数与多态","slug":"C++虚函数与多态","date":"2022-05-23T08:04:05.000Z","updated":"2022-10-01T02:35:54.149Z","comments":true,"path":"2022/05/23/C++虚函数与多态/","link":"","permalink":"http://goskp.github.io/2022/05/23/C++%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++虚函数与多态虚函数virtual修饰的成员函数就是虚函数 虚函数对类的内存影响:需要增加一个指针类型的内存大小 无论多少虚函数，只会增加一个指针类型的内存大小 虚函数表的概念: 指向虚函数的指针 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;第一个虚函数&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;第二个虚函数&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; sizeof(MM) &lt;&lt; endl; // 2.对类内存影响 MM mm; mm.print(); mm.printData(); int** pObject = (int**)(&amp;mm); typedef void (*PF)(); PF pf = (PF)pObject[0][0]; pf(); //调用第一个虚函数 pf = (PF)pObject[0][1]; pf(); //调用第二个虚函数 return 0; &#125; 纯虚函数具有一个或者多个纯虚函数的类型称之为抽象类，抽象类特性: 抽象类不能创建对象 抽象类可以创建对象指针 纯虚函数也是一个虚函数，需要virtual修饰，纯虚函数是没有函数体，函数&#x3D;0； #include &lt;iostream&gt; using namespace std; //抽象类 class MM &#123; public: //纯虚函数 virtual void print() = 0; protected: string name; &#125;; int main(int argc, char** argv) &#123; // MM object; 抽象类不能构建对象 MM* pMM = nullptr; return 0; &#125; 虚析构函数virtual修饰的析构函数 就是虚析构函数 当父类指针被子类对象初始化的时候需要用虚析构函数 所有析构函数底层解析其实函数名相同 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; MM* pMM = new Son; //构造子类对象，必须构造父类对象在构造自身 pMM-&gt;print(); // MM看类型 delete pMM; pMM = nullptr; return 0; &#125; 虚函数和多态多态概念: 指在继承中指针的同一行为的不同结果 实现多态的两个前提条件: 必须是public继承 必须父类存在virtual类型的成员函数,并且子类中存在该函数的同名函数 一定存在指针的引用 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;MM virtual printData&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; void printData() &#123; cout &lt;&lt; &quot;Son printData&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; //正常对象的访问，不存在多态 //都是就近原则 cout &lt;&lt; &quot;正常对象访问&quot; &lt;&lt; endl; MM mmobject; mmobject.print(); mmobject.printData(); Son sonobject; sonobject.print(); sonobject.printData(); //正常的指针访问 cout &lt;&lt; &quot;正常指针访问&quot; &lt;&lt; endl; MM* pMM = new MM; pMM-&gt;print(); pMM-&gt;printData(); Son* pSon = new Son; pSon-&gt;print(); pSon-&gt;printData(); //非正常的初始化 //父类指针被子类初始化 cout &lt;&lt; &quot;不正常的指针赋值&quot; &lt;&lt; endl; MM* pObject = new Son; pObject-&gt;print(); //没有virutal 看指针类型 调用MM::print pObject-&gt;printData(); //有virtual 看对象 调用Son::printData pObject = new MM; pObject-&gt;printData(); //调用MM中 cout &lt;&lt; &quot;引用类型&quot; &lt;&lt; endl; MM&amp; girl = sonobject; girl.print(); girl.printData(); return 0; &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; virtual void printData() final &#123; //禁止子类重写方法 cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; &#125;; // final: 父类中用来禁止子类重写同名方法 // override: 强制重写，起说明作用，表示当前子类当前方法是重写父类 class B : public A &#123; public: //重写:子类实现父类虚函数的同名函数 void print() override &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; // void printData()&#123;&#125; //final禁止重写 &#125;; class C : public B &#123; public: void print() &#123; cout &lt;&lt; &quot;C&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; B* pb = new C; pb-&gt;print(); //调用C::print pb = new B; pb-&gt;print(); //调用B::print return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++继承","slug":"C++继承","date":"2022-05-22T03:47:42.000Z","updated":"2022-09-18T02:35:53.138Z","comments":true,"path":"2022/05/22/C++继承/","link":"","permalink":"http://goskp.github.io/2022/05/22/C++%E7%BB%A7%E6%89%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++继承继承的实质就是父类有的属性在子类中也存在一份。只是根据继承方式不同，在子类中权限的体现不同。 继承:子类没有新的属性或者行为产生 父类 子类 派生:派生类中有新的属性产生 基类 派生类 单继承只有父类的继承称之为单继承 写法class 父类 &#123; &#125;; class 子类:继承方式 父类名 &#123; &#125;; //继承方式就是权限限定词 //公有继承: public //保护继承: protected //私有继承: private 继承中权限问题 public protected private public继承 public protected 不可访问 protected继承 protected protected 不可访问 private继承 private private 不可访问 综上: 权限限定词只会增强权限(public:最低权限 private:最高权限) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //父类 class MM &#123; public: string getName() &#123; return name; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; protected: int age = 18; private: string name = &quot;默认&quot;; &#125;; //子类 //公有继承 class Boy : public MM &#123; public: // print() void printBoy() &#123; // cout &lt;&lt; name &lt;&lt; endl; 不可能访问 cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // int age private: // string name; 不能访问 &#125;; //保护继承 class Girl : protected MM &#123; public: void printGirl() &#123; cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // void print() // int age; private: // string name; &#125;; //私有继承 class Son : private MM &#123; public: void printSon() &#123; print(); cout &lt;&lt; age &lt;&lt; endl; // cout &lt;&lt; name &lt;&lt; endl; // //父类的私有属性子类不能使用 只能间接调用父类的非私有方法访问 cout &lt;&lt; getName() &lt;&lt; endl; &#125; protected: private: // void print(); // int age; // string name; &#125;; int main(int argc, char** argv) &#123; Boy boy; boy.print(); boy.printBoy(); Girl girl; // girl.print(); //无法访问 girl.printGirl(); Son son; son.printSon(); return 0; &#125; 注意点: 继承的属性无论被继承多少次，都存在， A 被B继承 B被C继承 C被D继承 D包含ABC中所有属性 继承不易过多继承，导致子类臃肿 私有继承可以阻断父类属性被孙子类去使用(断子绝孙) 继承中构造函数写法 写法:子类必须先构造父类对象(子类必须调用父类的构造函数) ,调用父类的构造函数必须采用初始化参数列表 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A() &#123; cout &lt;&lt; a; &#125; A(string a) : a(a) &#123; cout &lt;&lt; a; &#125; ~A() &#123; cout &lt;&lt; a; &#125; protected: string a = &quot;A&quot;; &#125;; class B : public A &#123; public: B() &#123; //就算没写，也会调用父类的无参构造函数 cout &lt;&lt; b; &#125; //子类完整写法: 除了初始化自身数据，还需要初始化父类数据 B(string a, string b) : A(a) &#123; this-&gt;b = b; //自身属性可以采用初始化列表 cout &lt;&lt; b; &#125; void print() &#123; cout &lt;&lt; a; cout &lt;&lt; b; &#125; ~B() &#123; cout &lt;&lt; b; &#125; protected: string b = &quot;B&quot;; &#125;; class C : public B &#123; public: C(string a, string b, string c) : B(a, b), c(c) &#123; cout &lt;&lt; c; &#125; void print() &#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; &#125; ~C() &#123; cout &lt;&lt; c; &#125; protected: string c; &#125;; int main(int argc, char** argv) &#123; &#123; B b; cout &lt;&lt; endl; B object(&quot;A&quot;, &quot;B&quot;); cout &lt;&lt; endl; object.print(); cout &lt;&lt; endl; C c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); cout &lt;&lt; endl; c.print(); &#125; cout &lt;&lt; endl; &#123; cout &lt;&lt; &quot;构造和析构顺序问题:&quot; &lt;&lt; endl; C cobject(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // ABCCBA &#125; return 0; &#125; 多继承多继承就是存在两个以及两个以上父类 权限问题和构造函数和单继承一样的 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Father &#123; public: Father(string FFName) : FFName(FFName) &#123;&#125; protected: string FFName; &#125;; class Monther &#123; public: Monther(string MFName) : MFName(MFName) &#123;&#125; protected: string MFName; &#125;; class Son : public Father, public Monther &#123; public: Son(string FFName, string MFName, string SSName) : Father(FFName), Monther(MFName) &#123; this-&gt;SFName = FFName + MFName; this-&gt;SSName = SSName; &#125; void print() &#123; cout &lt;&lt; FFName &lt;&lt; endl; cout &lt;&lt; MFName &lt;&lt; endl; cout &lt;&lt; this-&gt;SFName + this-&gt;SSName &lt;&lt; endl; &#125; protected: string SFName; string SSName; &#125;; int main(int argc, char** argv) &#123; Son son(&quot;李&quot;, &quot;田&quot;, &quot;大牛&quot;); son.print(); return 0; &#125; 菱形继承菱形继承是因为多继承存在问题而衍生的继承方式(菱形继承就是虚继承) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A(int a) : a(a) &#123;&#125; int a = 666; &#125;; class B : virtual public A &#123; public: B(int a) : A(a) &#123;&#125; &#125;; class C : virtual public A &#123; public: C(int a) : A(a) &#123;&#125; &#125;; //多继承构造顺序只和这个地方顺序(继承顺序)有关 class D : public C, public B &#123; public: //子类必须调用爷爷构造函数 D(int a) : C(14), B(12), A(a) &#123;&#125; void print() &#123; cout &lt;&lt; A::a &lt;&lt; endl; cout &lt;&lt; B::a &lt;&lt; endl; cout &lt;&lt; C::a &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; D dobject(23); dobject.print(); return 0; &#125; 继承中同名问题 数据成员同名 成员函数同名 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name) : name(name) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;MM::name&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; class Son : public MM &#123; public: Son() : name(&quot;Son&quot;), MM(&quot;MM&quot;) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son::name&quot; &lt;&lt; endl; // No.1 不写任何标识 ，就近原则 cout &lt;&lt; name &lt;&lt; endl; // No.2 可以用类名 cout &lt;&lt; MM::name &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; void printInfo(MM* p) &#123; p-&gt;print(); &#125; int main(int argc, char** argv) &#123; //对象访问: // No.1 不写任何标识 ，就近原则 Son son; son.print(); son.MM::print(); son.Son::print(); MM mm(&quot;MM&quot;); mm.print(); //指针访问 //正常初始化访问 cout &lt;&lt; &quot;正常初始化指针访问&quot; &lt;&lt; endl; Son* pSon = new Son; pSon-&gt;print(); MM* pMM = new MM(&quot;MM&quot;); pMM-&gt;print(); //非正常初始化访问 // 1.1 父类指针用子类对象初始化 //在没有写任何修饰词的，看指针类型 MM* pFather = new Son; pFather-&gt;print(); //调用那个函数？ // 1.2 子类指针被父类对象初始化，危险，一般不这样做 // Son* pp = new MM(&quot;MM&quot;); //错误的 Son* pp = NULL; pp = static_cast&lt;Son*&gt;(&amp;mm); //强制类型转换类似C语言强制 // pp-&gt;print(); //程序中断，没办法执行 cout &lt;&lt; &quot;当父类指针成为函数参数时候,传参子类和父类对象通用&quot; &lt;&lt; endl; printInfo(pMM); printInfo(pSon); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++运算符重载","slug":"C++运算符重载","date":"2022-05-21T00:32:18.000Z","updated":"2022-09-18T02:35:21.074Z","comments":true,"path":"2022/05/21/C++运算符重载/","link":"","permalink":"http://goskp.github.io/2022/05/21/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++运算符重载 运算符重载赋予运算能够操作自定义类型。 运算符重载前提条件： 必定存在一个自定义类型 运算符重载实质: 就是函数调用 友元重载 类重载 在同一自定义类型中，一个运算符只能被重载一次 C++重载只能重载已有的运算符，不能重载没有 C++重载一般情况不能违背运算符原来的含义(就算语法正确) 注意点: . ,.* ,?：，:: 不能被重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; protected: string name; int score; &#125;; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 // MM result = mm + girl; //错误 return 0; &#125; 重载写法重载函数的写法 //函数定义方式 函数返回值类型 函数名(参数) &#123; //函数体； &#125; //运算符重载也是函数，只是函数名写法不同 //函数名: operator加上运算符组成函数名 //参数： // 友元重载: 参数个数等于操作数 // 类成员函数: 参数个数等于操作-1 // 函数返回值类型:运算符组成表达式 最终结果是什么类型就返回类型 // int a; int b; a+b 返回int // 函数体：写你真正要实现的效果 友元重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; MM operator+(MM a, MM b) &#123; return MM(a.name, a.score + b.score); //返回一个匿名对象 &#125; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 //重载函数的隐式调用 --&gt;mm + girl 解析为:operator+(mm, girl) MM result = mm + girl; //显示绿色就是运算符重载 result.print(); //重载函数显示调用：按照函数的调用方式 MM res = operator+(mm, girl); // operator+:函数名 参数 // string aa(&quot;12&quot;); // string bb(&quot;2323&quot;); // cout &lt;&lt; (aa &gt; bb) &lt;&lt; endl; return 0; &#125; 类重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; //类成员函数少一个参数： 对象本身可以表示参数 MM MM::operator-(MM object) &#123; return MM(this-&gt;name, this-&gt;score - object.score); &#125; int main(int argc, char** argv) &#123; MM mul = mm.operator-(girl); //类重载显示调用，跟调用普通成员函数一样的 mul.print(); MM girlFriend = mm - girl; //编译器mm - girl翻译为: mm.operator-(girl) girlFriend.print(); return 0; &#125; 特殊运算符重载 通常情况:单目运算符用类成员函数重载，双目用友元重载 &#x3D; ,（）,-&gt;,[] 只能采用成员函数重载 ++ –运算符重载 增加一个无用参数，标识是后置++或者– 流运算符重载(&gt;&gt; &lt;&lt;) 输入流对象(cin): istream类 输出流对象(cout): ostream类 流重载必须用引用 流重载一定要用友元重载 后缀重载 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; // MM operator=(MM) = delete; //删掉默认的 //函数重载 void operator=(int data) &#123; this-&gt;age += data; &#125; //++ 为例 MM operator++() &#123; //前置 this-&gt;age++; return *this; //返回对象本身 &#125; MM operator++(int) &#123; //后置的 return MM(this-&gt;name, this-&gt;age++); &#125; //流运算符的重载 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object); friend istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object); private: string name; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object) &#123; // out当做cout用 out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; endl; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object) &#123; cout &lt;&lt; &quot;输入对象属性:&quot;; // in当做cin用即可 in &gt;&gt; object.name &gt;&gt; object.age; return in; &#125; //文本重载, 一般写成下划线系列 //后缀的重载 unsigned long long operator&quot;&quot;_h(unsigned long long data) &#123; return data * 60 * 60; &#125; unsigned long long operator&quot;&quot;_m(unsigned long long data) &#123; return data * 60; &#125; unsigned long long operator&quot;&quot;_s(unsigned long long data) &#123; return data; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;小芳&quot;, 18); MM girl; girl = mm; //每一个类中都存在默认的赋值重载 girl = 8; girl.print(); MM result = ++girl; result.print(); girl.print(); result = girl++; result.print(); girl.print(); cin &gt;&gt; girl; cout &lt;&lt; girl &lt;&lt; endl; // this_thread::sleep_for(10s); cout &lt;&lt; 1_h &lt;&lt; endl; cout &lt;&lt; (1_h + 30_m + 49_s) &lt;&lt; endl; return 0; &#125; 对象的隐式转换对象隐式转换: 就是让对象能够赋值给普通数据 // operator 转换的类型() &#123; // return 要转换类型的数据； // &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; operator int() &#123; return this-&gt;age; &#125; protected: string name; int age; &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 39); int age = mm; cout &lt;&lt; age &lt;&lt; endl; return 0; &#125; ()运算符的重载仿函数让类型可以模仿函数调用的行为： 函数名(参数)； 类名() 调用的函数行为 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; class Data &#123; public: // operator()组成函数名 void operator()() &#123; cout &lt;&lt; &quot;无参重载()&quot; &lt;&lt; endl; &#125; void operator()(int a, int b) &#123; cout &lt;&lt; &quot;有参重载(a,b)&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; // greater&lt;int&gt;(); //比较准则 // int array[5] = &#123; 3,4,1,2,32 &#125;; // sort(array, array + 5, greater&lt;int&gt;()); // for (auto&amp; v : array) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; Data data; data.operator()(); //显式调用 data.operator()(1, 2); //显式调用 data(); //隐式调用 data(1, 2); //隐式调用 Data&#123;&#125;(); //&#123;&#125;帮助识别 Data() Data&#123;&#125;(2, 3); return 0; &#125; 智能指针智能指针是用对象方式管理new的内存，可以做到自动释放(本质是析构函数自动调用)内存的功能 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class Auto_Ptr &#123; public: Auto_Ptr(int* ptr) : ptr(ptr) &#123;&#125; ~Auto_Ptr() &#123; if (ptr) &#123; delete ptr; ptr = nullptr; &#125; &#125; //访问指针 int* operator-&gt;() &#123; return this-&gt;ptr; &#125; //访问数据 int&amp; operator*() &#123; return *ptr; &#125; //禁止拷贝，禁止赋值 Auto_Ptr(Auto_Ptr&amp;) = delete; Auto_Ptr&amp; operator=(Auto_Ptr&amp;) = delete; protected: int* ptr; &#125;; int main(int argc, char** argv) &#123; Auto_Ptr object(new int(1999)); cout &lt;&lt; *object &lt;&lt; endl; // shared_ptr&lt;int&gt; p(new int(19999)); // cout &lt;&lt; *p &lt;&lt; endl; // shared_ptr&lt;double&gt; p2(new double(19.99)); // cout &lt;&lt; *p2 &lt;&lt; endl; return 0; &#125; 封装数组#include &lt;iostream&gt; #include &lt;vector&gt; //动态数组 using namespace std; class my_vector &#123; public: my_vector(int capacity = 10) : capacity(capacity) &#123; mem = new int[capacity]&#123;0&#125;; curSize = 0; &#125; void push_back(int data) &#123; mem[curSize++] = data; &#125; int* begin() &#123; return mem + 0; &#125; int* end() &#123; return mem + capacity; &#125; int&amp; operator[](int index) &#123; if (curSize &lt; index) curSize = index; return mem[index]; &#125; //万金油函数 int size() &#123; return curSize; &#125; int empty() &#123; return curSize == 0; &#125; ~my_vector() &#123; if (mem) &#123; delete[] mem; mem = nullptr; &#125; &#125; protected: int* mem; int capacity; int curSize; &#125;; int main(int argc, char** argv) &#123; my_vector vec; for (int i = 0; i &lt; 3; i++) &#123; vec[i] = i; &#125; for (auto v : vec) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; vec.size() &lt;&lt; endl; for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 迭代器实现&#x2F;&#x2F;迭代器就是让一个类中类去遍历数据 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List() : headNode(new Node), curSize(0) &#123;&#125; void push_front(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); curSize++; &#125; Node* begin() &#123; return headNode-&gt;next;上 &#125; Node* end() &#123; return nullptr; &#125; class iterator &#123; public: iterator() : pmove(nullptr) &#123;&#125; void operator=(Node* pmove) &#123; this-&gt;pmove = pmove; &#125; bool operator!=(Node* pmove) &#123; return this-&gt;pmove != pmove; &#125; iterator operator++() &#123; this-&gt;pmove = this-&gt;pmove-&gt;next; //链表++不了 return *this; &#125; int operator*() &#123; return this-&gt;pmove-&gt;data; //*运算访问数据 &#125; private: Node* pmove; //需要指针访问数据 &#125;; protected: Node* headNode; int curSize; &#125;; void my_list() &#123; List list; for (int i = 0; i &lt; 3; i++) &#123; list.push_front(i); &#125; List::iterator it; for (it = list.begin(); it != list.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; string str = &quot;ILoveyou&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl; //类中类访问一个容器数据 string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; cout &lt;&lt; *it; //*指针取值运算 &#125; cout &lt;&lt; endl; // cout &lt;&lt; *str.end() &lt;&lt; endl; my_list(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++友元","slug":"C++友元","date":"2022-05-20T10:37:54.000Z","updated":"2022-09-18T02:35:38.145Z","comments":true,"path":"2022/05/20/C++友元/","link":"","permalink":"http://goskp.github.io/2022/05/20/C++%E5%8F%8B%E5%85%83/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++友元C++友元是用friend关键修饰的函数或者类，友元用来打破类封装(忽视权限限定) 友元并不是说直接访问数据成员，友元只是提供一个场所赋予对象具有打破权限限定 友元函数 友元类 友元函数和友元类不属于当前类，实现函数或者类不需要类名限定 友元函数 普通函数成为类的友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print(); //友元函数 friend void visitedData(); friend void visited(MM mm); protected: int num; private: int age; string name; &#125;; void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //友元函数 void visitedData() &#123; // name = &quot;ILoveyou&quot;; 不是直接访问，赋予对象的具有这样权限 //创建对象的无视权限 MM mm(&quot;girl&quot;, 18, 1001); cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; MM* p = new MM(&quot;new&quot;, 28, 1002); cout &lt;&lt; p-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;num &lt;&lt; endl; &#125; void visited(MM mm) &#123; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM girl(&quot;girl&quot;, 19, 1002); // girl.name=&quot;name&quot;; //类外只能访问public girl.print(); visitedData(); visited(girl); return 0; &#125; 以另一个类的成员函数为友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //前向声明 class A; class B &#123; public: B(int b) : b(b) &#123;&#125; void printA(A object); private: int b; &#125;; class A &#123; public: A(int a) : a(a) &#123;&#125; friend void B::printA(A object); private: int a; &#125;; void B::printA(A object) &#123; cout &lt;&lt; object.a &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; B b(111); A a(222); b.printA(a); return 0; &#125; /* A以B的成员函数为友元函数， B又以A类的成员函数为友元， 如果存在这种需求， 代码设计有问题， 但是C++允许这种关系 */ 友元类#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; friend class Boy; //声明boy类是MM友元类 public: MM(string name) : name(name) &#123;&#125; private: string name; &#125;; //友元类中，MM类的对象无视权限 class Boy &#123; public: Boy() : mm(&quot;mm&quot;) &#123; pObject = new MM(&quot;Object&quot;); &#125; void print() &#123; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; mm.name &lt;&lt; endl; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pObject-&gt;name &lt;&lt; endl; MM* pMM = new MM(&quot;new&quot;); cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pMM-&gt;name &lt;&lt; endl; &#125; private: MM mm; MM* pObject; &#125;; class A &#123; public: friend class B; void printA(); private: string a_name = &quot;A&quot;; &#125;; class B &#123; public: friend class A; void printB() &#123; A a; cout &lt;&lt; a.a_name &lt;&lt; endl; &#125; private: string b_name = &quot;B&quot;; &#125;; void A::printA() &#123; B b; cout &lt;&lt; b.b_name &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Boy boy; boy.print(); B b; b.printB(); A a; a.printA(); return 0; &#125; 顺便介绍一下C++的强制类型转换#include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; int num = 1.11; cout &lt;&lt; num &lt;&lt; endl; int cnum = (int)1.11; cout &lt;&lt; cnum &lt;&lt; endl; int cppnum = int(1.22); // C++强制类型转换 cout &lt;&lt; cppnum &lt;&lt; endl; return 0; &#125; static_cast类型转换类似C语言的强制类型转换，按照C++的说法 比C语言的更为安全 基本数据类型的强制转换 空指针转换目标类型指针 不能操作带const属性的类型 // static_cast&lt;要转换的类型&gt;(要转换目标) //要转换的类型: 数据类型 //要转换目标 可以是表达式，或者常量，都可以 #include &lt;iostream&gt; using namespace std; void test_static_cast() &#123; // No.1 基本数据类型的强制转换 int num = static_cast&lt;int&gt;(1.111); // No.2 空类型指针的转换 double* pD = new double(1.11); void* pVoid = static_cast&lt;void*&gt;(pD); // No.3 不能做const属性的类型的转换 //增加const属性 //不能去掉const属性 int number = 11; const int cNum = static_cast&lt;const int&gt;(number); const int ccNum = number; const int data = 1; int* pData = (int*)(&amp;data); // C语言强制类型转换 // int* pcData = static_cast&lt;int*&gt;(&amp;data); //错误 &#125; int main(int argc, char** argv) &#123; test_static_cast(); return 0; &#125; const_cast类型转换 去掉const属性(提供一个可以修改接口去操作const数据类型) 加上const属性(用的少一点) #include &lt;iostream&gt; using namespace std; class Str &#123; public: // 1.去掉const属性 Str(const char* str) : str(const_cast&lt;char*&gt;(str)) &#123;&#125; void print() &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; private: char* str; &#125;; class Test &#123; public: void print() &#123; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; private: &#125;; void printTest(const Test&amp; object) &#123; Test&amp; m_test = const_cast&lt;Test&amp;&gt;(object); m_test.print(); &#125; void test_const_cast() &#123; // 2.增加const属性 const int data = 1; int* pData = const_cast&lt;int*&gt;(&amp;data); *pData = 1001; //不会作用到const变量，只是单纯提供一个接口 cout &lt;&lt; &quot;data:&quot; &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;*pData:&quot; &lt;&lt; *pData &lt;&lt; endl; cout &lt;&lt; &amp;data &lt;&lt; endl; cout &lt;&lt; pData &lt;&lt; endl; Str str(&quot;ILoveyou&quot;); //错误，C++对于const要求更为严格 str.print(); char sstr[20] = &quot;ILoveyoud&quot;; Str str2(sstr); str2.print(); // 3.引用类型 Test test; test.print(); const Test&amp; c_test = test; // c_test.print(); //常属性的对象只能调用常成员函数 Test&amp; m_test = const_cast&lt;Test&amp;&gt;(c_test); m_test.print(); &#125; int main(int argc, char** argv) &#123; test_const_cast(); return 0; &#125; reinterpreat_cast类型转换把指针转换为一个整数，又可以把整数转换为一个指针，指针的效果依然有效 #include &lt;iostream&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; //官方案例 unsigned short Hash(void* p) &#123; unsigned int val = reinterpret_cast&lt;unsigned int&gt;(p); return (unsigned short)(val ^ (val &gt;&gt; 16)); &#125; void test_reinterpret_cast() &#123; int* p = reinterpret_cast&lt;int*&gt;(0); // p=nullptr; //官方案例 int a[20]; for (int i = 0; i &lt; 20; i++) cout &lt;&lt; Hash(a + i) &lt;&lt; endl; //允许将任何指针转换为任何其他指针类型。 //也允许将任何整数类型转换为任何指针类型以及反向转换 int* num = reinterpret_cast&lt;int*&gt;(Max); //把函数地址转换为int类型的数字 cout &lt;&lt; *num &lt;&lt; endl; auto pMax = reinterpret_cast&lt;int (*)(int, int)&gt;(num); cout &lt;&lt; &quot;max:&quot; &lt;&lt; pMax(1, 2) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; test_reinterpret_cast(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++特殊成员","slug":"C++特殊成员","date":"2022-05-19T13:07:35.000Z","updated":"2022-09-18T02:35:44.401Z","comments":true,"path":"2022/05/19/C++特殊成员/","link":"","permalink":"http://goskp.github.io/2022/05/19/C++%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++特殊成员const成员 const修饰的数据成员 初始化必须采用初始化参数列表 不能被修改 构造函数必须要初始化常数据成员 const修饰的成员函数 写法上要注意: const修饰是写在函数后面 const成员函数不能修改任何的数据成员 如果实在是要在常成员函数中修改该数据，用mutable修饰数据成员即可 常成员函数可以普通函数同时存在 const对象 const修饰的对象 常对象只能调用常成员函数 #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(int age) : name(&quot;小芳&quot;), num(4323) &#123; this-&gt;age = age; &#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; // MM() &#123;&#125; 常数据必须要初始化，错误 // MM() = default; //正确，可以构造无参对象 void print() &#123; age = 18; // num = 11; //不能修改常数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; //常成员函数： const写在函数后面 void print() const &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;常成员函数&quot; &lt;&lt; endl; &#125; void printData() const &#123; // age = 23; //常成员函数，不能修改数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; this-&gt;num &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; void test() &#123;&#125; protected: //常数据成员 const string name; const int num; int age; // mutable 可修改的意思 &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;小丽&quot;, 18, 1001); //如果普通函数和常成员函数同名 mm.print(); //普通对象优先调用普通函数 const MM object(18); object.print(); //常对象只能调用常成员函数 object.printData(); // object.test(); // //错误，常对象只能调用常成员函数 return 0; &#125; static成员static成员不属于某一个单独对象，是属于类的，通俗一点讲，是所有对象的共享的，static成员依然受权限 satic成员他的访问可以不需要对象(用类名限定的方式去访问) static数据成员 初始化必须在类外初始化 类实现的时候不需要用static修饰了 static成员函数 static写在修饰函数的前面 类外实现也不需要static修饰 静态函数中没有this指针 静态成员函数的访问问题 静态成员函数访问静态成员 是可以直接访问 静态成员函数访问非静态数据成员，必须通过指定对象的方式 静态成员函数传参 在静态成员函数定义对象去访问 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class User &#123; public: User(string name = &quot;默认&quot;) &#123; this-&gt;count++; //类中访问 this-&gt;m_count++; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl; &#125; // void test() &#123;&#125; 不能和普通函数形参重载效果，会造成重定义问题 public: static void test(); static void testData(User&amp; object); private: string name; public: static int count; int m_count = 0; &#125;; //必须在类外面做初始化，不需要static修饰了 int User::count = 0; void User::test() &#123; cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; // cout &lt;&lt; &quot;m_count:&quot; &lt;&lt; m_count &lt;&lt; endl; // //静态成员函数中不能直接调用非静态成员 cout &lt;&lt; &quot;静态函数&quot; &lt;&lt; endl; &#125; void User::testData(User&amp; object) &#123; cout &lt;&lt; object.m_count &lt;&lt; endl; //传参 User mm; cout &lt;&lt; mm.m_count &lt;&lt; endl; //创建对象 &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; User::count &lt;&lt; endl; // static 成员访问不需要对象 User object[3]; cout &lt;&lt; User::count &lt;&lt; endl; User mm; cout &lt;&lt; mm.count &lt;&lt; endl; cout &lt;&lt; User::count &lt;&lt; endl; //可以用类名访问，前提是权限没问题 cout &lt;&lt; mm.m_count &lt;&lt; endl; //不能用类名 User::test(); //因为存在这种调用，所以静态成员函数中不能存在this指针 mm.test(); return 0; &#125; 顺便介绍一下多文件的写法(Google) 一个类一个模块 声明写在.h 实现写在.cpp 声明和试下写在一起 .hpp 头文件包含尽量在.cpp完成 设计项目时候，头文件形成交叉包含，说明思想有问题，自己重新设计代码 不要为了拆分而拆分 静态数据成员多文件写法","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++类的组合案例","slug":"C++类的组合案例","date":"2022-05-18T11:07:35.000Z","updated":"2022-09-18T02:35:49.900Z","comments":true,"path":"2022/05/18/C++类的组合案例/","link":"","permalink":"http://goskp.github.io/2022/05/18/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++类的组合什么是类的组合类的组合就是以另一个的对象为数据成员，这种情况称之为类的组合 优先使用组合而不是继承 组合表达式的含义一部分的关系 初始化参数列表初始化参数列表是构造函数的另一种写法 应用场景： 形参名和数据成员相同，避免二义性问题 类和组合 必须要初始化参数列表的方式写构造 常数据成员必须采用初始化参数列表的方式 继承中子类的构造函数也必须初始化参数列表的方式 初始化参数列表基本形态 构造函数名(形参1，形参2....):数据成员1(形参1),数据成员2(形参2)... 初始化参数列表其他形态#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: //初始化参数列表 //可以避免形参名和数据成员名字相同 MM(string name, int age) : name(name), age(age) &#123;&#125; MM(string name) &#123; MM::name = name; //用类名标识一下帮助IDE去识别 &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; //初始化参数列表其他写法 string name = &quot;initName&quot;; int returnValue() &#123; return 23; &#125; class Boy &#123; public: //无参构造函数 Boy() : name(&quot;Boy&quot;), age(111) &#123;&#125; //::name标识name是全局的 Boy(int age) : name(::name), age(returnValue()) &#123; cout &lt;&lt; age &lt;&lt; endl; //就近原则 &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; private: string name; int age; &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;name&quot;, 18); mm.print(); Boy boy; boy.print(); Boy pInt(12); pInt.print(); return 0; &#125; 类的组合案例分析 类组合包含的类的对象，必须采用初始化参数列表方式调用各自类当中的构造函数去初始化 组合中初始化参数列表的写法 要通过包含的类的构造函数决定组合类的构造函数怎么写 构造函数名(形参1，形参2，形参3....):对象1(形参1，形参2),对象2(形参3)... 组合类注意问题 组合类必须要调用包含对象所属类的构造函数 形式上看不到包含对象所属类构造函数调用，必须准备无参的构造函数 #include &lt;iostream&gt; using namespace std; //一种的关系 //一部分：组合 class Button &#123; public: Button() &#123; cout &lt;&lt; &quot;Button&quot; &lt;&lt; endl; &#125; Button(int x, int y, int w, int h) : x(x), y(y), w(w), h(h) &#123; cout &lt;&lt; &quot;Button&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;按钮...&quot; &lt;&lt; endl; &#125; private: int x; int y; int w; int h; &#125;; class Edit &#123; public: Edit() &#123; cout &lt;&lt; &quot;Edit&quot; &lt;&lt; endl; &#125; Edit(int x, int y) : x(x), y(y) &#123; cout &lt;&lt; &quot;Edit&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;编辑框....&quot; &lt;&lt; endl; &#125; private: int x; int y; &#125;; class Label &#123; public: Label() &#123; cout &lt;&lt; &quot;Label&quot; &lt;&lt; endl; &#125; Label(int x, int y, string text) : x(x), y(y), text(text) &#123; cout &lt;&lt; &quot;Label&quot; &lt;&lt; endl; &#125; void Draw() &#123; cout &lt;&lt; &quot;标签:&quot; &lt;&lt; text &lt;&lt; endl; &#125; private: int x; int y; string text; &#125;; class Window &#123; public: // window():button(),label(),edit()&#123;&#125; //形式上没有调用，实际构造对象，必定调用包含对象的无参构造函数 Window() &#123;&#125; Window(int bx, int by, int bw, int bh, int lx, int ly, string text, int ex, int ey) : button(bx, by, bw, bh), edit(ex, ey), label(lx, ly, text) &#123;&#125; void Show() &#123; button.Draw(); label.Draw(); edit.Draw(); &#125; Button getButton() &#123; return button; &#125; Label getLabel() &#123; return label; &#125; Edit getEdit() &#123; return edit; &#125; private: //以其他类的对象为数据成员 //构造顺序只和此处有关，和初始化参数列表顺序无关 Button button; Label label; Edit edit; &#125;; //另一种包含指针写法 class A &#123; public: A(int a) : a(a) &#123;&#125; int geta() &#123; return a; &#125; private: int a; &#125;; class B &#123; public: B(int b) : b(b) &#123;&#125; int getb() &#123; return b; &#125; private: int b; &#125;; class C &#123; public: C() &#123; pa = new A(12); pb = new B(123); &#125; C(int a, int b) : pa(new A(a)), pb(new B(b)) &#123;&#125; void visitData() &#123; cout &lt;&lt; pa-&gt;geta() &lt;&lt; endl; cout &lt;&lt; pb-&gt;getb() &lt;&lt; endl; &#125; private: A* pa; B* pb; &#125;; int main(int argc, char** argv) &#123; Window object; //优先构造包含对象，在构造自身对象 // object.getButton().Draw(); // object.getEdit().Draw(); // object.getLabel().Draw(); object.Show(); Window window(10, 10, 10, 10, 20, 20, &quot;Label&quot;, 30, 30); window.Show(); C c; c.visitData(); C value(1, 2); value.visitData(); return 0; &#125; 组合中构造和析构顺序问题 一般构造顺序和析构是相反 类的组合中，优先构造包含对象，在构造自身对象 类的组合中，包含对象的构造顺序只和定义顺序有关，和初始化参数列表无关 #include &lt;iostream&gt; using namespace std; class A &#123; public: A() &#123; cout &lt;&lt; &quot;A&quot;; &#125; ~A() &#123; cout &lt;&lt; &quot;A&quot;; &#125; &#125;; class B &#123; public: B() &#123; cout &lt;&lt; &quot;B&quot;; &#125; ~B() &#123; cout &lt;&lt; &quot;B&quot;; &#125; &#125;; class C &#123; public: C() &#123; cout &lt;&lt; &quot;C&quot;; &#125; ~C() &#123; cout &lt;&lt; &quot;C&quot;; &#125; &#125;; class D &#123; public: D() &#123; cout &lt;&lt; &quot;D&quot;; &#125; //初始化参数列表写出去迷惑 ~D() &#123; cout &lt;&lt; &quot;D&quot;; &#125; A a; // A B b; // B C c; // C // D &#125;; int main(int argc, char** argv) &#123; &#123; D d; &#125; return 0; &#125; this指针任何类中都存在一个this指针，this指针只允许在类中函数的函数中使用 this指针代表的是每一个对象抽象地址 基本用法避免形参名和数据成员的名相同 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age); void modifyData(string name, int age) &#123; // MM::name = name; // MM::age = age; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; this &lt;&lt; endl; &#125; void print(); protected: string name; int age; &#125;; //初始化参数列表类外也行 MM::MM(string name, int age) : name(name), age(age) &#123;&#125; void MM::print() &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 18); mm.modifyData(&quot;MM&quot;, 28); // this=&amp;mm; cout &lt;&lt; &quot;&amp;mm:&quot; &lt;&lt; &amp;mm &lt;&lt; endl; MM girl(&quot;girl&quot;, 19); girl.modifyData(&quot;girl&quot;, 29); // this=&amp;girl; cout &lt;&lt; &quot;&amp;girl:&quot; &lt;&lt; &amp;girl &lt;&lt; endl; return 0; &#125; 其他作用操作对象自身做一些事情 返回对象本身函数 返回对象本身的地址 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age); void modifyData(string name, int age) &#123; // MM::name = name; // MM::age = age; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; this &lt;&lt; endl; &#125; MM&amp; returnMM() &#123; return *this; &#125; MM* returnMMPoint() &#123; return this; &#125; void print(); protected: string name; int age; &#125;; //初始化参数列表类外也行 MM::MM(string name, int age) : name(name), age(age) &#123;&#125; void MM::print() &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 18); mm.modifyData(&quot;MM&quot;, 28); // this=&amp;mm; cout &lt;&lt; &quot;&amp;mm:&quot; &lt;&lt; &amp;mm &lt;&lt; endl; MM girl(&quot;girl&quot;, 19); girl.modifyData(&quot;girl&quot;, 29); // this=&amp;girl; cout &lt;&lt; &quot;&amp;girl:&quot; &lt;&lt; &amp;girl &lt;&lt; endl; //奇葩写法 mm.returnMM().returnMM().returnMM().returnMM().print(); mm.returnMMPoint()-&gt;returnMMPoint()-&gt;returnMMPoint()-&gt;print(); mm.print(); mm.returnMMPoint()-&gt;print(); return 0; &#125; 类中类类中类就是一个类定义在另一个类当中 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List(); void insertData(int data); void printList() &#123; Node* pmove = headNode-&gt;next; while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;data &lt;&lt; &quot; &quot;; pmove = pmove-&gt;next; &#125; cout &lt;&lt; endl; &#125; Node* begin() &#123; return headNode; &#125; private: Node* headNode; public: //类中类 class Iterator &#123; public: Iterator(Node* pmove = nullptr); private: Node* pmove; &#125;; &#125;; List::List() &#123; headNode = new Node; &#125; void List::insertData(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); &#125; //类中类的访问剥洋葱 List::Iterator::Iterator(Node* pmove) : pmove(pmove) &#123;&#125; int main(int argc, char** argv) &#123; List list; List::Iterator it = list.begin(); list.insertData(1); list.insertData(2); list.insertData(3); list.printList(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++构造与析构","slug":"C++构造与析构","date":"2022-05-17T05:17:08.000Z","updated":"2022-09-18T02:35:55.011Z","comments":true,"path":"2022/05/17/C++构造与析构/","link":"","permalink":"http://goskp.github.io/2022/05/17/C++%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++构造和析构构造函数 名字和类名相同 没有返回值 构造函数是用来构造对象，构造对象时候必定调用构造函数 不写构造函数，存在一个默认的构造函数，默认的构造函数是无参，所以可以构造无参对象 默认的构造函数可以删掉，通过delete删除默认的构造函数 显示使用默认的构造函数, 通过default做显示调用 通常情况构造函数是public属性 自己写了构造函数，默认的构造函数就不存在了 构造函数决定对象的长相(构造函数无参，对象无参，构造有一个，对象必须也要一个参数) 构造函数通常做的事情，就是给数据成员初始化 构造函数也是函数，所以也可以重载，也可以缺省 通过重载和缺省，实现构造不同长相对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: // MM() = default; //显式使用默认的构造函数 // MM() = delete; //删掉默认的构造函数 MM(string name, int age) &#123; m_name = name; m_age = age; cout &lt;&lt; &quot;两个参数的构造函数&quot; &lt;&lt; endl; &#125; MM() = default; //默认无参构造函数，据说速度更快 void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; // MM::MM() //&#123; // cout &lt;&lt; &quot;调用无参构造函数&quot; &lt;&lt; endl; // &#125; struct Boy &#123; string name; int age; int num; //一旦C++结构体中写了构造函数，必须当做类去操作，不能用C语言的那种方式使用 Boy() &#123;&#125; Boy(string bname, int bage) &#123; name = bname; age = bage; &#125; &#125;; void testStruct() &#123; // Boy boy = &#123; &quot;string&quot;,18,1001&#125;; //错误 //这个地方也是创建对象过程，所以数据也需要和构造函数 Boy boy = &#123;&quot;string&quot;, 18&#125;; //这里数据必须和构造函数的一致 Boy boy2; Boy array[3]; &#125; int main(int argc, char** argv) &#123; // MM mm; // //因为构造函数有两个参数，对象也必须带有两参数 MM mm(&quot;对象&quot;, 18); //这步创建对象的过程就是调用构造函数构造函数的过程 mm.printMM(); MM empty; //调用无参构造函数 // new一个对象 MM* p = new MM; //调用无参的构造函数 MM* p2 = new MM(&quot;对象&quot;, 29); //调用有参的构造函数 return 0; &#125; 析构函数 ~类名 当做析构函数名字 没有参数 释放数据成员new的内存 在对象死亡前自动调用 通常如果数据成员没有做new操作，就可以不写析构函数 不写析构函数，存在一个默认的析构函数 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(const char* str =&quot;ILoveyou&quot;) &#123; //缺省,相当于存在两个构造函数，一个是无参的，一个是有参 int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; ~MM(); protected: char* name; &#125;; MM::~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; cout &lt;&lt; &quot;析构函数....\\n&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; &#123; MM mm; MM* p = new MM; cout &lt;&lt; &quot;1......&quot; &lt;&lt; endl; delete p; //立刻调用析构函数 p = nullptr; cout &lt;&lt; &quot;2.......&quot; &lt;&lt; endl; &#125; &#123; MM beauty(&quot;Continue&quot;); &#125; cout &lt;&lt; &quot;对象死亡&quot; &lt;&lt; endl; return 0; &#125; 拷贝构造函数 拷贝构造函数也是构造函数 拷贝构造函数参数是固定的:对对象的引用 拷贝构造函数不写会存在一个默认的拷贝构造函数 拷贝构造函数作用： 通过一个对象产生另一个对象 关键点：一定是有一个新的对象产生 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; MM(MM&amp; object); void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; //拷贝构造函数 //通过传入对象属性确定创建对象的属性 MM::MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用自己写的拷贝构造函数&quot; &lt;&lt; endl; &#125; //函数传参也可以隐式调用 void print(MM object) &#123; // MM object=girl object.printMM(); &#125; // C++中传参能用引用就用，效率搞 void printData(MM&amp; object) &#123; //引用就是别名，没有产生新的对象 object.printMM(); &#125; int main(int argc, char** argv) &#123; MM mm(&quot;C神&quot;, 18); //产生一个对象 MM beauty = mm; //隐式调用拷贝构造函数 MM girl(beauty); //显式调用拷贝构造函数 print(girl); //调用拷贝构造函数 printData(girl); MM boy; //对象先有了，才赋值，不调用拷贝 boy = girl; //不调用拷贝构造函数--&gt;默认重载=运算符(后续会详细阐述) return 0; &#125; 深浅拷贝问题浅拷贝 没有在拷贝构造函数中给数据成员做new操作 默认拷贝构造函数都是浅拷贝 深拷贝 在拷贝构造函数中做了new操作 浅拷贝导致内存释放问题浅拷贝会导致同一段内存重复释放问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; // MM(MM&amp; object) &#123; // name = object.name; // &#125; ~MM() &#123; if (name != nullptr) &#123; //浅拷贝导致内存释放问题 //浅拷贝会导致同一段内存重复释放问题 //两个指针都指向同一段内存 delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 深拷贝解决方案#include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; MM(MM&amp; object) &#123; // name = object.name; int length = strlen(object.name) + 1; name = new char[length]; strcpy(name, object.name); &#125; ~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 综上： 一旦类中有指针，做了内存申请，并且要对对象做拷贝操作，就必须使用深拷贝 匿名对象匿名对象就是无名对象，匿名对象只能充当右值，所以匿名对象拷贝必须存在移动拷贝，或者准备一个ecosnt限定普通拷贝构造函数。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM()&#123;&#125;; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; &#125; //移动构造---&gt;新标准的 MM(MM&amp;&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用移动构造&quot; &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构打印name:&quot; &lt;&lt; m_name &lt;&lt; endl; &#125; private: string m_name; int m_age; &#125;; MM returnMM(string name, int age) &#123; return MM(name, age); //构造一个匿名对象当做函数返回值 &#125; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;, 19); //匿名对象是一个右值 MM mm = MM(&quot;mm&quot;, 29); //匿名对象 ---&gt;匿名对象转正 ，mm接管所有权 cout &lt;&lt; &quot;匿名对象已死亡&quot; &lt;&lt; endl; &#125; MM beauty = returnMM(&quot;返回值&quot;, 18); beauty.printMM(); return 0; &#125; 构造和析构顺序问题 一般情况构造顺序和析构是相反的 静态的和全局的是最后释放的 delete 立刻调用析构函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test &#123; public: Test(string data = &quot;A&quot;) &#123; m_data = data; cout &lt;&lt; m_data; &#125; ~Test() &#123; cout &lt;&lt; m_data; &#125; protected: string m_data; &#125;; int main(int argc, char** argv) &#123; &#123; Test t1; // A static Test t2(&quot;B&quot;); // B Test array[3]; // AAA //数组就是多个无参 Test* p = new Test(&quot;C&quot;); // C delete p; // C p = nullptr; &#125; // ABAAACCAAAAB return 0; &#125; //用构造函数的方式简单实现单链表 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List(); void insertData(int data); void printList() &#123; Node* pmove = headNode-&gt;next; while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;data &lt;&lt; &quot; &quot;; pmove = pmove-&gt;next; &#125; cout &lt;&lt; endl; &#125; private: Node* headNode; &#125;; List::List() &#123; headNode = new Node; &#125; void List::insertData(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); &#125; int main(int argc, char** argv) &#123; List list; list.insertData(1); list.insertData(2); list.insertData(3); list.printList(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++类和对象","slug":"C++类和对象","date":"2022-05-16T03:58:16.000Z","updated":"2022-09-18T02:35:48.187Z","comments":true,"path":"2022/05/16/C++类和对象/","link":"","permalink":"http://goskp.github.io/2022/05/16/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++类和对象初识类的创建 类和结构体区别 在没写构造函数之前，C语言结构体就按照C语言的方式用即可 用了构造函数时候，结构体直接当做C++类去使用 结构体其实可以当做一个默认权限是公有属性的类 C++是允许空类和结构体存在 class 类名 &#123; //默认为私有属性 //..... public: //类外只能访问公有属性 //....公有属性 //公有函数---&gt;类外的公有接口 protected: //....保护属性 private: //....私有属性 &#125;; //保护和私有属性区别，暂时不需要知道，后续讲继承的时候会讲 //类中没有权限可言 创建类完整代码class MM &#123; public: void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); protected: private: //一般数据成员写：私有属性 string name; int age; int num; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; 结构体和类的区别// C++类和对象 #include &lt;iostream&gt; using namespace std; class MM &#123; int num; //类中默认的是私有属性 public: int age; private: string name; &#125;; struct Boy &#123; //结构体中默认的公有属性 int num; int age; private: string name; &#125;; // C语言是不能写空的结构体 // C++允许空结构体或者类 struct Empty &#123; //占用内存不是0 是1(标记),写了数据这个标记就不存在 &#125; m; //作用:泛型编程做参数包解析的递归循环终止处理 int main(int argc, char** argv) &#123; struct Boy boy; // boy.num = 1001; // boy.age = 12; MM mm; mm.age = 19; cout &lt;&lt; sizeof(Empty) &lt;&lt; endl; cout &lt;&lt; sizeof(Boy) &lt;&lt; endl; return 0; &#125; 对象创建和初始化对象创建 创建普通对象 创建对象数组 创建对象指针 对象的初始化 类中直接给数据赋值 提供一个共有接口去操作数据 提供一个返回引用的接口 完整代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void printData() &#123; //普通成员函数只是写在类中，不占对象内存 cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; int&amp; getNum() &#123; return num; &#125; protected: private: //一般数据成员写：私有属性 string name = &quot;默认值&quot;; int age = 0; int num = 0; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm; //创建对象 MM array[3]; MM* pMM; pMM = &amp;mm; pMM = new MM; // new一个对象 // new一个对象过程 // 1.创建一个匿名对象(没有名字的对象) // 2.把匿名对象的首地址赋值指针 pMM-&gt;print(); pMM-&gt;printData(); // pMM-&gt;name = &quot;小芳&quot;; 不可访问，类外不能访问public之外的所有属性 cout &lt;&lt; &quot;通过提供共有接口传参的方式初始化对象的数据&quot; &lt;&lt; endl; mm.initData(&quot;小芳&quot;, 18, 1001); mm.printData(); cout &lt;&lt; &quot;返回引用的去访问数据&quot; &lt;&lt; endl; MM* p = new MM; p-&gt;getName() = &quot;MM&quot;; p-&gt;getAge() = 28; p-&gt;getNum() = 1004; p-&gt;printData(); return 0; &#125; 成员的访问 类中普通数据成员和成员函数必须通过对象去访问 只有两种方案 普通对象: 用 对象.成员访问 对象指针:用 对象指针-&gt;成员 案例代码#include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; //不想让别人直接修改数据，不要返回引用，只能看不能操作 string getName() &#123; return name; &#125; int getAge() &#123; return age; &#125; int getNum() &#123; return num; &#125; private: string name; int age; int num; &#125;; void testObject() &#123; MM mm; mm.initData(&quot;小芳&quot;, 19, 1002); cout &lt;&lt; mm.getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getNum() &lt;&lt; endl; // IMAGE img; // img.getwidth(); // img.getheight(); &#125; void testObjectPoint() &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;小丽&quot;, 29, 1004); cout &lt;&lt; pMM-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getNum() &lt;&lt; endl; &#125; void testArray() &#123; MM array[3]; for (int i = 0; i &lt; 3; i++) &#123; string name = &quot;name&quot; + to_string(i); //iomanip array[i].initData(name, 18 + i, 1002 + i); cout &lt;&lt; (array + i)-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getNum() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // age = 123; 不能直接访问 testObject(); testObjectPoint(); testArray(); return 0; &#125; 类和对象的其他操作类中含有指针问题含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 // 含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: void initData(const char* mmName, int mmAge); void initMM(const char* mmName, int mmAge); void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; char*&amp; getName() &#123; return name; &#125; protected: char* name; int age; &#125;; //一般不采用这种方案处理,诟病很大 void MM::initData(const char* mmName, int mmAge) &#123; name = (char*)mmName; age = mmAge; &#125; void MM::initMM(const char* mmName, int mmAge) &#123; name = new char[strlen(mmName) + 1]; strcpy(name, mmName); age = mmAge; &#125; void printConst(const char* str) &#123; //传入常量和变量 传参const修饰 cout &lt;&lt; str &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;张三&quot;, 19); pMM-&gt;print(); // strcpy(pMM-&gt;getName(), &quot;ILoveyou&quot;); // // 百分百有问题，name没有指向一段可操作内存 char str[10] = &quot;ILoveyou&quot;; // C++const要求更为严格，尤其是字符串处理 printConst(&quot;ILoveyou&quot;); printConst(str); pMM-&gt;getName() = str; pMM-&gt;print(); MM* p = new MM; p-&gt;initMM(&quot;ILoveyou&quot;, 20); p-&gt;print(); strcpy(p-&gt;getName(), &quot;IMiss&quot;); p-&gt;print(); return 0; &#125; 类不能直接包含自身的对象只能包含自身指针不能包含自身对象 class Boy &#123; public: //Boy boy; 错误代码 Boy* pBoy; //指针正确 &#125;; 成员函数指针调用成员函数#include &lt;iostream&gt; using namespace std; class Test &#123; public: void print(string info) &#123; cout &lt;&lt; info &lt;&lt; endl; &#125; &#125;; void testFunc() &#123; Test test; // void (*Func)(string) = nullptr; // Func = &amp;Test::print; 错误写法，类型 // 1.auto自动推断出类成员函数指针类型 auto Funcf = &amp;Test::print; //没问题 (test.*Funcf)(&quot;测试函数&quot;); //调用还是要学会 Test testb; (testb.*Funcf)(&quot;测试函数2&quot;); testb.print(&quot;直接调用&quot;); // 2.正规写一下正常写法 //不是简单的用*指针名替换函数，而是要加上类名限定 void (Test::*Func)(string) = nullptr; Func = &amp;Test::print; //类中所有东西，无论怎么访问，必须类名限定 (test.*Func)(&quot;类成员函数指针访问成员函数&quot;); &#125; int main(int argc, char** argv) &#123; testFunc(); return 0; &#125; 对象本质 对象的本质就是一个数据,只是数据包含操作 因为对象的本质是一个数据，所以变量能做的，它都可以 当做函数参数 当做函数返回值 当做另一个结构体数据成员 当做另一个类的数据成员 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student &#123; public: void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; protected: string name; int age; &#125;; void printData(Student student) &#123; student.print(); &#125; //子函数修改实参，C语言传入实参地址，C++传引用 void modifyStudent(Student&amp; stu) &#123; stu.getName() = &quot;Memory&quot;; stu.getAge() = 28; &#125; Student* createStu(string name, int age) &#123; Student* p = new Student; p-&gt;getName() = name; p-&gt;getAge() = age; return p; &#125; void testStudent() &#123; Student stu; modifyStudent(stu); printData(stu); Student* p = createStu(&quot;C++&quot;, 19); p-&gt;print(); Student temp = *p; temp.print(); //除了赋值之外，其他运算不能直接做 // Student temp1 = temp + temp; //算术+条件 &#125; int main(int argc, char** argv) &#123; testStudent(); return 0; &#125; // C++的方式简单实现链表操作 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; struct Node* p_next; &#125;; class List &#123; public: void Initlist(); Node* CreateNode(int new_data); void InsertNode(int new_data); void DeleteNodeByPosData(int pos_data); void PrintList(); protected: Node* p_head_node; //表头 int cur_size; //链表中结点个数 &#125;; void List::Initlist() &#123; p_head_node = new Node; p_head_node-&gt;p_next = nullptr; cur_size = 0; &#125; Node* List::CreateNode(int new_data) &#123; Node* p_new_node = new Node; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = nullptr; return p_new_node; &#125; void List::InsertNode(int new_data) &#123; Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; cur_size++; &#125; void List::DeleteNodeByPosData(int pos_data) &#123; Node* p_pre_node = p_head_node; Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != nullptr &amp;&amp; p_cur_node-&gt;data != pos_data) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (p_cur_node == nullptr) &#123; cout &lt;&lt; &quot;没有找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; delete p_cur_node; p_cur_node = nullptr; &#125; &#125; void List::PrintList() &#123; Node* p_move = p_head_node-&gt;p_next; while (p_move != nullptr) &#123; cout &lt;&lt; p_move-&gt;data; p_move = p_move-&gt;p_next; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; List* p_list = new List; p_list-&gt;Initlist(); for (int i = 0; i &lt; 3; ++i) &#123; p_list-&gt;InsertNode(i); &#125; p_list-&gt;PrintList(); p_list-&gt;DeleteNodeByPosData(1); p_list-&gt;PrintList(); return 0; &#125; 结点和链表都用类#include &lt;iostream&gt; using namespace std; class Node &#123; public: int&amp; getData() &#123; return data; &#125; struct Node*&amp; getNext() &#123; return next; &#125; protected: int data; struct Node* next; &#125;; class List &#123; public: void initList(); void insertData(int data); void printData(); void deleteNode(int posData); protected: Node* headNode; //表示表头 int curSize; //当前节点个数 &#125;; void List::initList() &#123; headNode = new Node; headNode-&gt;getNext() = nullptr; curSize = 0; &#125; void List::insertData(int data) &#123; //创建新节点 Node* newNode = new Node; newNode-&gt;getData() = data; newNode-&gt;getNext() = nullptr; //表头插入链接 newNode-&gt;getNext() = headNode-&gt;getNext(); headNode-&gt;getNext() = newNode; curSize++; &#125; void List::printData() &#123; Node* pmove = headNode-&gt;getNext(); while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;getData() &lt;&lt; &quot; &quot;; pmove = pmove-&gt;getNext(); &#125; cout &lt;&lt; endl; &#125; void List::deleteNode(int posData) &#123; Node* preNode = headNode; Node* curPos = headNode-&gt;getNext(); while (curPos != nullptr &amp;&amp; curPos-&gt;getData() != posData) &#123; preNode = curPos; curPos = preNode-&gt;getNext(); &#125; if (curPos == nullptr) &#123; cout &lt;&lt; &quot;没有找到无法做指定位置删除...&quot; &lt;&lt; endl; &#125; else &#123; preNode-&gt;getNext() = curPos-&gt;getNext(); delete curPos; curPos = nullptr; &#125; &#125; int main(int argc, char** argv) &#123; List* p = new List; p-&gt;initList(); for (int i = 0; i &lt; 3; i++) &#123; p-&gt;insertData(i); &#125; p-&gt;printData(); p-&gt;deleteNode(1); p-&gt;printData(); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"C++和C的区别","slug":"C++和C的区别","date":"2022-05-15T07:24:31.000Z","updated":"2022-09-18T02:36:17.894Z","comments":true,"path":"2022/05/15/C++和C的区别/","link":"","permalink":"http://goskp.github.io/2022/05/15/C++%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ 不定期进行更新 C++和C的区别头文件包含问题#include &lt;iostream&gt; //不需要.h 直接包含 int main(int argc, char** argv) &#123; return 0; &#125; 创建的项目源文件是.cpp 头文件的包含不同 不需要.h 直接包含 C语言的标准库头文件 依然按照原来方式包含，一定程序C++兼容C语言 C++包含方式: c+原来的头文件，去掉.h #include &lt;ctime&gt; 完整代码#include &lt;stdio.h&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &quot;myhead.h&quot; //自己写的依旧是按照原来方式 int main(int argc, char** argv) &#123; printf(&quot;C语言的函数！\\n&quot;); return 0; &#125; C++命名空间什么是命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; // namespace 空间名 //用namespace 声明一个东西 可以提高标识符使用，可以避免命名污染 如何创建命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; //用namespace 声明一个东西 怎么访问命名空间 :: :作用域分辨符 访问空间中的成员: 空间名::成员名 用来区分全局变量和局部变量 ::全局变量 #include &lt;cstdio&gt; #include &lt;iostream&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; // namespace MM namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); return 0; &#125; 省略前缀的方式去调用 //using namespace 空间名; //要省略的空间名 //注意点：有作用域 #include &lt;iostream&gt; #include &lt;cstdio&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); MM::print(); using namespace MM; //省略前缀的调用方式 print(); using namespace Boy; //printf(&quot;%d\\n&quot;, age); //二义性问题：有两个选择，不知道找谁 printf(&quot;%d\\n&quot;, Boy::age); printf(&quot;%d\\n&quot;, MM::age); return 0; &#125; 命名空间嵌套namespace A &#123; int a=1; namespace B &#123; int b = 1; &#125; &#125; void test() &#123; //剥洋葱 A::a = 1; A::B::b = 2; using namespace A::B; b = 3; &#125; 先声明后实现//其他写法： 先声明后实现的一种写法 namespace Data &#123; void print(); struct student; &#125; //必须空间名限定 void Data::print() &#123; &#125; struct Data::student &#123; int age; int num; &#125;; 标准的命名空间std C++所有的函数和类都是属于标准命名空间 不写using namespace std; 意味着所有C++标准库中的东西都需要加上std:: using namespace std; //习惯性的操作 C++函数新思想函数重载什么是函数重载C++允许同名不同参数的函数存在，C语言不允许同名函数存在 不同参数的三个体现 数目不同 类型不同 顺序不同：前提条件是存在不同类型 #include &lt;iostream&gt; using namespace std; //类型不同 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; float Max(float a, float b) &#123; return a &gt; b ? a : b; &#125; //顺序不同 // error C2084: 函数“int Max(int,int)”已有主体 // int Max(int b, int a) //&#123; // //&#125; void print(int a, char c) &#123;&#125; void print(char a, int c) &#123;&#125; //数目不同 void print(int a, int b, int c) &#123;&#125; //想当然了 // double就是末尾加个d 错误的 // char就是加个c嘛 错误的 int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, Max(1, 2)); printf(&quot;%.1f\\n&quot;, Max(1.1f, 2.2f)); //错误，C++对于类型要求比C语言严格 1L; // long 1.1f; // float 1u; // unsiged; //默认的小数是double; return 0; &#125; 函数重载和函数返回值一点毛线关系都没有。 函数缺省什么是函数缺省函数缺省就是给形参赋初始值，当不传参的时候使用的是默认值 函数缺省规则 只能从右往左缺省，中间不能有空着的 多文件中，.h文件缺省了，cpp不需要缺省(声明做了缺省，实现就不需要缺省) 缺省的好处实现函数的不同形态的调用，针对不同需求做不同实现 #include &lt;iostream&gt; using namespace std; //函数缺省 void printData(int a = 1, float b = 1.11f, double c = 1.11, char d = &#39;A&#39;) &#123; printf(&quot;%d\\t%f\\t%lf\\t%c\\n&quot;, a, b, c, d); &#125; int main(int argc, char** argv) &#123; printData(); //所有形参都是默认值 printData(9); // a=9,其他值用默认值 printData(9, 2.22f); // a=9 b=2.22 其他默认值 printData(9, 2.22f, 9.9); // a=9,b=2.22 c=9.9 其他默认值 printData(9, 2.22f, 9.9, &#39;D&#39;); //所有的值用的是传入的值 return 0; &#125; C++标准输入和输出标准输出 cout + &lt;&lt; 一起完成的 换行: endl替换”\\n” #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; //单个数据输出 std::cout &lt;&lt; &quot;ILoveyou&quot;; //没有写using namespace std; 必须加前缀 cout &lt;&lt; 1; //多个数据的输出 cout &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;编号\\n&quot;; struct MM mm = &#123;&quot;mm&quot;, 18, 1001&#125;; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; //和上面一行代码效果一样 cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; endl; //等效:cout&lt;&lt;&quot;\\n&quot;; std::cout &lt;&lt; std::endl; //一样的是std命名空间中的 return 0; &#125; 标准输入 cin+ &gt;&gt; 一起完成 输入不需要任何的格式控制字符 #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;请输入一个整数:&quot;; int num; cin &gt;&gt; num; //变量名 cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;请输入一个字符串:&quot;; char str[20]; while (getchar() != &#39;\\n&#39;); //存在跳过显现:清空缓冲区 // setbuf(stdin, NULL); // //影响汉字输入，汉字的文件操作出现问题 fflush(stdin); // //C++中已经淘汰了，有时候使用没有效果 cin &gt;&gt; str; //数组名 cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input num and str:&quot;; cin &gt;&gt; num &gt;&gt; str; cout &lt;&lt; num &lt;&lt; &quot;\\t&quot; &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input name,age,num:&quot;; struct MM temp; cin &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; cout &lt;&lt; &quot;姓名\\t年龄\\t编号&quot; &lt;&lt; endl; cout &lt;&lt; temp.name &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.age &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.num &lt;&lt; endl; return 0; &#125; //用C++ 子函数的方式实现模拟登录 #include &lt;conio.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void Input(char* userName, char* passWord) &#123; //..... //登录实现密码不可见 cout &lt;&lt; &quot;用户名:&quot;; cin &gt;&gt; userName; while (getchar() != &#39;\\n&#39;); int i = 0; char key = 0; cout &lt;&lt; &quot;密 码:&quot;; while ((key = _getch()) != &#39;\\r&#39;) &#123; cout &lt;&lt; &quot;*&quot;; passWord[i++] = key; &#125; passWord[i] = &#39;\\0&#39;; cout &lt;&lt; endl; &#125; int Login(char* username, char* passWord, const char* root = &quot;root&quot;, const char* pass = &quot;12345&quot;) &#123; //比较验证 if (strcmp(username, root) == 0 &amp;&amp; strcmp(passWord, pass) == 0) &#123; return 1; &#125; return 0; &#125; int main(int argc, char** argv) &#123; char userName[20] = &#123;&quot;&quot;&#125;; char passWord[7] = &#123;&quot;&quot;&#125;; Input(userName, passWord); if (Login(userName, passWord) == 1) &#123; //登录成功 cout &lt;&lt; &quot;登录成功&quot; &lt;&lt; endl; &#125; else &#123; //打印用户名和密码错误 cout &lt;&lt; &quot;打印用户名和密码错误&quot; &lt;&lt; endl; &#125; return 0; &#125; 新基本数据类型bool类型 占用内存是1个字节 打印出来的值是： 0或者1 非零值表示成立 通常用的是false和true做初始化 #include &lt;iostream&gt; void testBool() &#123; bool bNum = 5; std::cout &lt;&lt; bNum &lt;&lt; std::endl; //一般是会用都用关键字初始化 bNum = false; bNum = true; //用途: //做开关 //做标记--&gt;查找类的操作 //做函数返回值 while (true) ; //死循环 &#125; int main(int argc, char** argv) &#123; testBool(); return 0; &#125; 引用类型把引用类型理解为一个起别名的用法 左值引用 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 // 引用类型 /* 左值引用: 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用: 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 */ #include &lt;iostream&gt; using namespace std; // 引用类型 // int&amp; x=b; void Modify(int&amp; x) &#123; x = 9999; &#125; //返回引用等效返回一个变量 //不能返回局部变量的引用 int g_num = 1001; int&amp; getValue() &#123; //就相当于与一个变量,可充当左值 return g_num; &#125; int getData() &#123; //返回变量相当于一个值,不能充当左值 return g_num; &#125; // char* str=&quot;Iloveyou&quot; void printString(const char* str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; void modifyNum(const int&amp; num) &#123; // num++; //常引用不能做++ cout &lt;&lt; num &lt;&lt; endl; &#125; //只能传入右值 void modifyNum2(int&amp;&amp; num) &#123; num++; //提供修改接口 cout &lt;&lt; num &lt;&lt; endl; &#125; void testNew() &#123; int a = 1; int&amp; b = a; b = 1001; cout &lt;&lt; a &lt;&lt; endl; //当做函数返回值：增加左值使用好处 //当做函数参数：防止拷贝本的产生 Modify(b); cout &lt;&lt; a &lt;&lt; endl; // getData() = 1003; 错误，返回是一个值，不是一个变量，不能充当运算符左值 getValue() = 9999; // 等效于g_num=9999; cout &lt;&lt; g_num &lt;&lt; endl; //常量起别名 // C++对于const属性要求更为严格 // 1.用常引用 const int&amp; xx = 13; cout &lt;&lt; xx &lt;&lt; endl; //char* pStr = &quot;ILoveyou&quot;; //error const char* pstr = &quot;ILoveyou&quot;; printString(&quot;ILoveyou&quot;); char array[10] = &quot;LLLL&quot;; printString(array); //常引用不能修改 // 2.右值引用 &amp;&amp; ---&gt;提供修改接口 int&amp;&amp; yy = 134; yy = 55; const int c_num = 112; //常属性的变量，依旧是左值 // int&amp;&amp; zz = c_num; //错误 modifyNum(1); modifyNum2(23); //左值变成右值 int data = 1001; int&amp;&amp; data2 = move(data); //移动函数：把左值变成右值 int value = 1234; // modifyNum2(value); // //错误，用右值引用当做函数参数，不能传左值 modifyNum2(move(value)); //移动语义(完美转发) &#125; int main(int argc, char** argv) &#123; testNew(); return 0; &#125; C++结构体类型 类型名不在需要struct关键字了 C++结构体可以给成员直接赋初始值 C++结构体可以包含函数 其实C++结构体的处理就是按照类的方式处理（后续在意） 用了构造函数时候C++结构体和C语言结构体处理方案是完全不同的 #include &lt;iostream&gt; using namespace std; //描述的是事物特征和行为 struct MM &#123; char name[20] = &quot;MM&quot;; int age = 111; int num = 1001; void initData(const char* str, int age, int num); //在结构体声明 void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; &#125;; //在外面实现，必须结构体名限定 void MM::initData(const char* str, int age, int num) &#123; strcpy_s(name, 20, str); //同名问题 MM::age = age; MM::num = num; &#125; int main(int argc, char** argv) &#123; // No.1 类型不需要struct MM mm; // cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; mm.printData(); MM mm2 = &#123;&quot;mm2&quot;, 18, 1030&#125;; // cout &lt;&lt; mm2.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.num &lt;&lt; endl; mm2.printData(); mm2.initData(&quot;小芳&quot;, 18, 1004); mm2.printData(); return 0; &#125; C++枚举类型#include &lt;iostream&gt; using namespace std; enum State &#123; Open, Close &#125;; enum class Color &#123; Red, Blue &#125;; void print(int state) &#123; cout &lt;&lt; state &lt;&lt; endl; &#125; void printEnum(Color color) &#123; // cout &lt;&lt; color &lt;&lt; endl; 不能直接打印 &#125; void testEnum() &#123; print(1); print(Open); // C++的枚举类型不能当做一个简单的int类型 // print(Color::Red); //访问必须要用枚举类型名限定 printEnum(Color::Red); &#125; int main(int argc, char** argv) &#123; testEnum() return 0; &#125; C++string类型C++string本身是一个类，所以大家本节课只要学会使用即可，不需要问问什么 头文件： #include 注意点和cstring区别，这个是C语言头文件 没有用using namespace std ; string类型需要改为std::string 掌握string常用方式 创建方式 基本操作(比较,连接) 转C语言char* 微软帮助文档:basic_string 类 | Microsoft Docs #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; // std::string str; // No.1创建 string str1; str1 = &quot;ILoveyoudsfasdfasdfasdfasdfasd&quot;; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;ILoveyousdfsdafads&quot;; cout &lt;&lt; str2 &lt;&lt; endl; string str3(str2); string str4 = str2; cout &lt;&lt; str3 &lt;&lt; endl; cout &lt;&lt; str4 &lt;&lt; endl; // No.2 基本操作 cout &lt;&lt; (str3 == str4) &lt;&lt; endl; cout &lt;&lt; (str3 &gt;= str4) &lt;&lt; endl; string password; cin &gt;&gt; password; cout &lt;&lt; password; //原理是：运算符重载 后面会讲 //比较直接比 if (password == string(&quot;12345&quot;)) &#123; cout &lt;&lt; endl &lt;&lt; &quot;密码正确&quot; &lt;&lt; endl; &#125; int a = (int)1.3; // C语言强制类型转换 int b = int(1.34); // C++强制类型转换 //连接直接加法 string name = &quot;张三&quot;; string info = name + &quot;很帅&quot;; cout &lt;&lt; info &lt;&lt; endl; //上述复杂的用法 cout &lt;&lt; info.compare(name) &lt;&lt; endl; //和strcmp 返回值一样 cout &lt;&lt; info.append(name) &lt;&lt; endl; //下标的方式访问 cout &lt;&lt; info.length() &lt;&lt; endl; //当前长度 cout &lt;&lt; info.size() &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info[i]; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info.at(i); &#125; cout &lt;&lt; endl; cout &lt;&lt; info.capacity() &lt;&lt; endl; //容量 //和C语言string.h有区别的 char* // 不能用%s的方式打印 // printf(&quot;%s\\n&quot;, info); // 图形库中传char* 函数 都不能直接用string类型 //提供两个函数： c_str() data(); printf(&quot;%s\\n&quot;, info.c_str()); printf(&quot;%s\\n&quot;, info.data()); return 0; &#125; C++自动推断类型 auto类型 decltype类型 #include &lt;iostream&gt; using namespace std; struct MM &#123; int age; &#125;; MM g_MM = &#123;12&#125;; MM* createMM() &#123; MM* p = &amp;g_MM; return p; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Max)(int, int), int a, int b) &#123; cout &lt;&lt; Max(a, b) &lt;&lt; endl; &#125; void printData(int (*)(int, int), int, int) &#123; cout &lt;&lt; &quot;另一个函数&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // auto 类型自动推断: 一定要有赋值 所以不能单独定义变量 // auto a; 没有赋值 推断不出来 auto a = 1; // int a = 134; auto pMM = createMM(); cout &lt;&lt; pMM-&gt;age &lt;&lt; endl; auto pFunc = print; // void (*)(int(*)(int, int), int , int ) pFunc(Max, 1, 3); pFunc = printData; pFunc(Max, 1, 3); int* p = nullptr; //新的空 等效C语言NULL // decltype 不需要赋值 decltype(123) num = 123; // decltype(123) 表示一个int类型 //函数指针必须取地址 decltype(&amp;print) ppFunc; ppFunc = printData; //推断一个int decltype(num) Num = num; decltype(&amp;num) pNum = &amp;num; //当你们用的时候，不知道类型，推断定义变量去赋值 return 0; &#125; C++动态内存申请C++申请的内存是自由存储区的，C语言的堆区内存，所以C++类的对象内存不能用malloc申请 &#x2F;&#x2F; IMAGE * new申请内存 申请单个变量内存 申请一段内存 申请内存可以手动初始化 申请内存后可以再分配 delete释放内存 释放单个变量内存：delete 指针名; 释放一段变量内存： delete[] 指针名; #include &lt;iostream&gt; using namespace std; struct MM &#123; char name[20]; int age; int num; &#125;; void testOne() &#123; int* pInt = new int; *pInt = 123; cout &lt;&lt; pInt[0] &lt;&lt; endl; delete pInt; pInt = nullptr; char* pc = new char; delete pc; int* pNum = new int(1234); //申请并且初始化 cout &lt;&lt; pNum[0] &lt;&lt; endl; delete pNum; MM* pMM = new MM(&#123;&quot;name&quot;, 12, 1101&#125;); cout &lt;&lt; pMM-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;num &lt;&lt; endl; &#125; void testTwo() &#123; //一段内存的申请 int size = 4; int* pArray = new int[size]; // int pArray[4]; MM* pMM = new MM[4]; // MM pMM[4]; delete[] pArray; delete[] pMM; pArray = nullptr; pMM = nullptr; int* pNum = new int[4]&#123;1, 2, 3, 4&#125;; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; pNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; delete[] pNum; pNum = nullptr; &#125; void testThree() &#123; char* pMem = new char[1024]; //在原来上面拿个20字节存整数 int* pInt = new (pMem + 0) int[5]&#123;1, 2, 3, 4, 5&#125;; //在原来上面拿出20个存字符 char* pChar = new (pMem + 20) char[20]&#123;&quot;ILoveyou&quot;&#125;; //等效：char* pChar = new(pInt + 5) char[20]&#123;&quot;ILoveyou&quot;&#125;; delete[] pMem; pMem = nullptr; &#125; int main(int argc, char** argv) &#123; testOne(); testTwo(); testThree(); return 0; &#125; 小试牛刀#include &lt;iostream&gt; using namespace std; int** create2DArray(int row, int cols) &#123; int** pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; return pArray; &#125; void create2DArray(int**&amp; pArray, int row, int cols) &#123; pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; &#125; void Free(int**&amp; array, int row) &#123; for (int i = 0; i &lt; row; i++) &#123; delete[] array[i]; &#125; delete[] array; array = nullptr; &#125; int main(int argc, char** argv) &#123; int** p2D = nullptr; int cols, rows; //让用户输入行列 cin &gt;&gt; rows &gt;&gt; cols; // create2DArray(p2D, rows, cols); p2D = create2DArray(rows, cols); //让用户赋值 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cin &gt;&gt; p2D[i][j]; &#125; &#125; //打印结果 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cout &lt;&lt; p2D[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //释放 Free(p2D, rows); &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"}]},{"title":"计组-计算机硬件基础","slug":"计组-计算机硬件基础","date":"2022-05-10T02:30:46.000Z","updated":"2022-10-01T02:50:07.228Z","comments":true,"path":"2022/05/10/计组-计算机硬件基础/","link":"","permalink":"http://goskp.github.io/2022/05/10/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"参考视频: 计算机硬件基础 机箱 够不够大. 主板能不能放下 散热 外观 主板 接口,型号,品牌… 可以理解为电路板 CPU:中央处理器 整个机箱里最重要的就是CPU,就是大脑 用于电脑下命令的 CPU如果卡了,其他的部件性能再好也没用 CPU厂商 IntelCPU实战分析Intel中国官网请点击此蓝色字体Intel 代表的处理器型号: 赛扬,奔腾 酷睿 core四类,分等级 :i3 i5 i7 i9 从*大体来看,越来越好*,注意是同代相比,不能拿今年的i5和几年前的i7相比 i3 针对的是轻量化办公, (打字,文稿,处理文档,客户沟通等等) i5 处理简单视频, 程序, 简答项目,游戏 i7 发烧, 大型游戏, 大型工程, 专业用户… i9 最屌 ,顶级性能 解读:Intel 第12代酷睿 i9-12900K台式机CPU处理器 16核24线程 单核睿频至高可达5.2Ghz 30M三级缓存 i9-12900K i9就不解释了,就代表酷睿的这一系列产品 12900K: (12就是代号) 读作:i9第十二代 如i9-9900K , 9900K中的第一个9是代号 读作:i9第九代 具体代号指是哪一年的产品 ,去官网搜索就可以了 后面的900K 在900K中,第一个9代表的是性能 数字排名[0-9] 举个例子, i9-12900K 和 i9-12700K ,那显然是i9-12900K性能好了(9&gt;7嘛) 但如果是i3-9500 i5-2700 ,这样就不好比较了, 可以google搜索,找一下测评视频,这两款cpu跑分怎么样 中间的两个0 不用管,没有什么特别的意义,注意台式机大部分是00 末尾的字母:K? KF? G1? G7? 产品后缀,同代相比G7是一定比G1好的 F,Intel全新推出的后缀,代表无内置核心显卡版本,显然买带F的需要自己配显卡 G,Y,主打续航,不是性能 U 稍微有点续航, 办公 H 焊接,不可拆卸,打游戏的 大多数台式是不带字母的, 如果带基本都是K,超频(满功率运行) 后缀比较多, 这里没有介绍的搜索就可以 英特尔® 处理器名称和编号请点击此蓝色字体 CPU厂商 AMDCPU实战分析AMD中国官网请点击此蓝色字体 AMD 于 2016&#x2F;8&#x2F;17 推出 Zen 架构，但直到 2017&#x2F;3 才发布第一款 Zen 架构处理器。现在已经进化到第四代，分别是 Zen、Zen+、Zen2、Zen3。 14nm Zen：2017&#x2F;3 12nm Zen+：2018&#x2F;4 7nm Zen2：2019&#x2F;7 7nm Zen3：2020&#x2F;11 在解释 AMD 命名规则前，先看看一些 AMD 处理器型号 Ryzen Threadripper 1950X Ryzen 7 2700X Ryzen 5 3600XT Ryzen 7 4700G …. 命名规则 AMD Ryzen 5 3600X AMD: Company Name Ryzen: Brand Name 5: CPU Family 3: CPU Generation 6: CPU Performance Level 00: Model Number Or SKU Number X: Power Suffix 型号的第一个数字 这里说的型号，是指由 4 个数字和字母后缀组成的那段字符，例如“5900X”。AMD 官方通常根据型号的第一个数字，把处理器称为 xxxx 系列，例如 5700U 是 5000 系列移动处理器，5900X 是 5000 系列桌面处理器。 Ryzen 后的数字 Ryzen 后面的系列，主要有 3、5、7、9、Threadripper。除了有 Ryzen，还有 Ryzen pro、Ryzen Threadripper Pro，它们主要面向商业用途，而不是大众消费者。 同一个系列下，Ryzen 后面的第一个数字越大，性能通常越强，最强的是 Threadripper(线程撕裂者)。如果系列不同，则不一定。 比如 Ryzen 7 5800X 的性能比 Ryzen 9 3900XT 强，虽然前者是 Ryzen 7，后者是 Ryzen 9，似乎 9 强于 7，但前者是 5000 系列，后者是 3000 系列。不同的系列代表不同的架构，前者是 Zen3 架构，后者是 Zen2 架构。 CPU性能天梯图请点击此蓝色字体 总结:比较两款处理器的性能，首先看型号的第一个数字，即先看系列(架构)，系列(架构)相同，则看 代号后的数字，数字越大性能通常越强。如果系列不同，则需要考虑更多因素。16核24线程 可以理解为16个脑子,24个脑仁, 肯定是越多越好 单核 主频 睿频 主频:智商.平常工作时的节奏 睿频:智商爆表, 比如玩游戏时的节奏,集中注意力的运行这个东西 30M三级缓存 就相当于是库存,能存多块,同样是越高越好 如何查看电脑CPU详细信息 CPU-Z下载地址请点击此蓝色字体 内存(RAM 运行内存) 意味着最大能开多少的空间 每个正在运行的软件都会占用内存空间 也就是说此电脑后台和前台能同时运行多少APP 现在是2022年8月, 就电脑来讲大部分都是16G运行内存了,属于是最低标准 内存频率的用途DDR4 3200 代号 DDR1 DDR2 DDR3 3200 当然也是越高越好… 但是需要注意的是, 频率越高,需要的主板应当越好 电源(主要针对台式机) 好的CPU,好的显卡,功率可能会更大 功率如果不够,硬件可能出现带不动的情况,导致不能发挥顶级的性能 硬盘注意:硬盘和内存是不一样的 内存 :吃完了扔了,扔完再放(完全是临时的东西) 一旦关机,临时的东西全部释放, 内存条 保存的是开机时运行的APP和数据 硬盘(存储永久数据的) 机械硬盘(不推荐个人用户买机械硬盘) 最古老的硬盘 现在是2022年8月,机械硬盘并不流行 举个例子: 2TB 256MB 7200PRM SATA接口 2TB : 2000G, 256MB: 缓存 7200RPM: 转 硬盘的转速,越大越好 SATA接口: 详见文章开篇电路板图片 固态硬盘(部分可支持台式,笔记本互联) SATA接口 为了兼容旧电脑 MiniSATA PCI-E U.2 M.2 读写速度,缓存速度 机械银盘读写速度都 &lt;&#x3D; 110MB&#x2F;S 固态硬盘读写速度 SATA接口 &lt;&#x3D; 550 MB&#x2F;s MiniSATA接口,老式笔记本电脑使用,即将被淘汰 PCI-E占用了一个显卡的接口位置 读6000M&#x2F;s 写 4000M&#x2F;s(不推荐),注意查看主板是否支持 U.2 即将被淘汰 M.2(21世纪20年代的主流硬盘, 遵循NVME协议) 读写速度没有看到具体上限 显卡(图形显示处理器,3D,动画渲染的能力)AMD NVIDIA IntelArc(新潮流) NVIDIA(玩游戏推荐) GeForce900 GTX980 GeForce10 GTX1050TI GeForce16 GeForce RTX 20系列 RTX2060(RTX采用了光线追中技术,游戏里的光反射,画面更加好) GeForce RTX 30系列 RTX2080 RTX3090 同代相比Ti比super好,super比什么都不带的好 显存 能丢多少图形渲染到显卡里(3A大作) 显卡分类 集成显卡(核显): 买CPU送显卡 作用就是链接显示器(屏幕): 显示内容 ,玩游戏不行 独立显卡 注意: Intel CPU后缀是F的都不带显卡 如何查看自己电脑显卡 GPU-Z下载地址请点击此蓝色字体 桌面显卡性能天梯图请点击此蓝色字体 显示器 分辨率越高,画面显示越好,显卡负载越大 1080p 3060 2k 3060 4k 3080TI 3090 屏幕刷新率 144hz 感谢Frank","categories":[{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://goskp.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://goskp.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/categories/QT/"},{"name":"后端","slug":"后端","permalink":"http://goskp.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://goskp.github.io/tags/DesignPattern/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://goskp.github.io/tags/Algorithm/"},{"name":"QT","slug":"QT","permalink":"http://goskp.github.io/tags/QT/"},{"name":"Rust","slug":"Rust","permalink":"http://goskp.github.io/tags/Rust/"},{"name":"数据结构","slug":"数据结构","permalink":"http://goskp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://goskp.github.io/tags/C/"},{"name":"计算机硬件","slug":"计算机硬件","permalink":"http://goskp.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"}]}