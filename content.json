{"meta":{"title":"欢迎访问我的博客(skp)","subtitle":"","description":"","author":"孙楷朋","url":"http://am900skp.github.io","root":"/"},"pages":[{"title":"category","date":"2022-08-14T04:20:49.000Z","updated":"2022-08-14T04:20:50.000Z","comments":true,"path":"category/index.html","permalink":"http://am900skp.github.io/category/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-07-14T04:24:56.000Z","updated":"2022-10-13T13:05:24.000Z","comments":true,"path":"about/index.html","permalink":"http://am900skp.github.io/about/index.html","excerpt":"","text":"个人简介孙楷朋准大二计算机相关专业在读热爱编程,乐于合作,善于总结分享,有良好的的编程习惯目标BAT大厂联系方式 QQ: 1287923885 WeChat: code_cpp Email: &#x6b;&#112;&#x73;&#x75;&#x6e;&#64;&#102;&#111;&#120;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;"}],"posts":[{"title":"操作系统概念","slug":"操作系统概念","date":"2023-03-04T04:54:12.000Z","updated":"2023-03-04T04:58:38.260Z","comments":true,"path":"2023/03/04/操作系统概念/","link":"","permalink":"http://am900skp.github.io/2023/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/","excerpt":"","text":"操作系统(Operating System , OS):是指控制和管理整个计算机系统的硬件和软件资源,并合理组织调度计算机的工作和资源的分配,以提供给用户和其他软件方便的接口和环境,它是计算机系统中最基本的系统软件.(系统资源的管理者)","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://am900skp.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://am900skp.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计网复习","slug":"计网复习","date":"2023-02-26T14:14:26.000Z","updated":"2023-02-26T15:31:30.750Z","comments":true,"path":"2023/02/26/计网复习/","link":"","permalink":"http://am900skp.github.io/2023/02/26/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"互联网的两个重要基本特点: 1&gt;连通性(用户可以交换信息) 2&gt; 共享(资源共享:信息共享,软件共享….) 互联网(Internet):遵循TCP&#x2F;IP标准,利用路由器将各种计算机网络连接起来而形成的,一个覆盖全球的,特定的”互连网”,主义是使用TCP&#x2F;IP,一个专用名词 互连网(internet):泛指由多个不同的计算机网络互联而成的网络,除TCP&#x2F;IP外,还可以使用其他协议(比如自定义的协议),能够成相互通信,就可以理解为互连网 ISP(Internet Service Provider)互连网服务器提供者 作用是可以获取IP地址的使用权,并可通过该ISP接入互连网 从互联网的工作方式上看,大致分为两块:1&gt;边缘部分,2&gt;核心部分 边缘部分:1–&gt;由所有连接在互联网上的主机组成,这部分是用户直接使用的,用来进行通信(传送数据,…)资源共享 核心部分:2–&gt;由大量网络和连接这些网络的路由器组成,这部分是为边缘部分提供服务的 核心部分的3种交换方式:电路交换,报文交换,分组交换(路由器是实现分组交换的关键构件,其任务是转发收到的分组,这是网络核心部分最重要的功能)分组交换是网络核心部分最重要的功能. 所谓交换: 其含义可以理解为转接:,使他们连接起来,按照某种方式动态的分配传输线路的资源. n部电话机相连,需要n(n-1)&#x2F;2对电线,与n方成正比 电路交换三个阶段:1&gt;建立连接,2&gt;通信3&gt;释放连接 报文交换:要求信息转换到另一交换节点去,但输出线路或其他设施都已被占用,就先把该信息在此交换节点处存储起来排队等待,等输出线路空闲时再转发至下一个节点.优点是线路利用率高,缺点:时延大 分组交换:采用存储转发技术,在发送端,先把较长的报文化分成较短的,固定长度的数据端,每一个数据段前面添加上首部构成分组,以分组作为数据传输单元,一次把个分组发送到接收端, 边缘部分两种通信方式:C&#x2F;S,(Client&#x2F;Server) P2P(Peer-to-Peer方式) 客户(Client)和服务器(server都是指通信所涉及的两个应用进程) 服务请求方和服务提供方都要使用网络核心部分所提供的服务 P2P:两个主机在通信时并不区分哪一个是服务请求方还是服务提供方,只要两个主机都运行了对等连接软件,他们就可以进行平等的,对等连接通信.双方都可以下载对方已经存储在硬盘中的共享文档, 客户与服务器的通信关系建立后,通信可以是双向的,客户和服务器都可发送和接收数据","categories":[{"name":"计网","slug":"计网","permalink":"http://am900skp.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[{"name":"计网","slug":"计网","permalink":"http://am900skp.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"大二下开学这两天","slug":"大二下开学这两天","date":"2023-02-26T11:06:44.000Z","updated":"2023-02-26T11:12:27.228Z","comments":true,"path":"2023/02/26/大二下开学这两天/","link":"","permalink":"http://am900skp.github.io/2023/02/26/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E5%BC%80%E5%AD%A6%E8%BF%99%E4%B8%A4%E5%A4%A9/","excerpt":"","text":"2023年2&#x2F;25号开学,疫情彻底放开了,学校不再封校,这学期的课有点多,从明天开始(27号),可能每天都很忙了,在3月份我不仅要把四级准备好(名额很难抢,大一两次都没抢到,所以我一定会非常珍惜这次机会),还要准备计算机网络的考试,在业余时间我也要练琴,学乐理,因为我一直担任着我们队的主音吉他手,准备排练&lt;无地自容&gt;&lt;海阔天空&gt;&lt;极恶都市&gt;等等…..关于乐队,我可能大三就不准备搞了,看看情况吧.这一学期希望玩能玩好,学也不会落下,","categories":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"关于搭建Hexo博客","slug":"关于搭建Hexo博客","date":"2023-02-23T03:12:14.000Z","updated":"2023-02-23T04:40:59.123Z","comments":true,"path":"2023/02/23/关于搭建Hexo博客/","link":"","permalink":"http://am900skp.github.io/2023/02/23/%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"hexo 上传到github失败，链接服务失败，端口号链接失败： 取消代理：git config –global –unset http.proxy 登录验证： git config –global user.email “xxx”git config –global user.name “xxx” 插入图片： 在source目录下新建一个images文件夹 引入图片: 更改_config文件下的 post_asset_folder: true","categories":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"重新养成写博客的习惯","slug":"重新养成写博客的习惯","date":"2023-02-22T09:22:26.000Z","updated":"2023-02-22T09:23:33.319Z","comments":true,"path":"2023/02/22/重新养成写博客的习惯/","link":"","permalink":"http://am900skp.github.io/2023/02/22/%E9%87%8D%E6%96%B0%E5%85%BB%E6%88%90%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B9%A0%E6%83%AF/","excerpt":"","text":"重新养成写博客的习惯","categories":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"MySQL配置过程的细节","slug":"MySQL配置过程的细节","date":"2022-10-13T13:05:13.000Z","updated":"2022-10-19T11:31:34.000Z","comments":true,"path":"2022/10/13/MySQL配置过程的细节/","link":"","permalink":"http://am900skp.github.io/2022/10/13/MySQL%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BB%86%E8%8A%82/","excerpt":"","text":"最好全在管理员权限下运行管理员打开bin,转到D盘, cd bin目录 安装MySQL , mysqld –install —&gt;Service successfully Installed mysqld –initalize –console —&gt;初始化mysqld服务 net start mysql —&gt;启动服务 mysql -uroot -p默认密码 —&gt;登录mysql show databases; —&gt;查看数据库 set password for ‘root‘@’localhost’&#x3D;’123456’; —&gt;修改密码 —&gt;Query OK quit; —&gt;退出数据库 mysql -uroot -p123456 —&gt;重新登录mysql 停止MySQL服务 删除注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL默认路径C盘：C:\\Program Files\\MySQL\\MySQL Server 5.7 mysql 服务路径:HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\MySql mysql\\mysql-5.6.26-winx64\\bin\\mysqld.exe 控制面板-&gt;卸载MySQL Server 删除MySQL安装的位置 删除C:\\Program Files (x86)\\MySQL 删除隐藏的ProgramData 忘记密码:先关闭mysql服务net stop mysql mysqld –console –skip-grant-tables –shared-memory在打开一个cmd窗口(管理员),上面的不要关了mysqlshow databases;use mysql;更新权限:flush privileges;alter user root@localhost identified by ‘123456’;quitBye","categories":[{"name":"数据库","slug":"数据库","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://am900skp.github.io/tags/MySQL/"}]},{"title":"Rust(1)","slug":"Rust(1)","date":"2022-08-31T10:39:55.000Z","updated":"2023-02-09T11:44:52.639Z","comments":true,"path":"2022/08/31/Rust(1)/","link":"","permalink":"http://am900skp.github.io/2022/08/31/Rust(1)/","excerpt":"","text":"参考视频: Rust编程语言入门教程（Rust语言&#x2F;Rust权威指南配套) ahead-of-time语言 安装验证 rustc –version rust帮助文档: rustup doc 编译: rustc main.rs 在windows上还会生成一个.pdb文件 rustc只适合编译简单的rust程序 Cargo : cargo new hello_cargo 可以使用其他的VCS,或不适用VCS,cargo new 的时候使用 -vcs这个flag 代码的包称作crate cargo.toml Cargo构建项目 cargo build cargo.lock,不要乱动这个文件 构建和运行Cargo项目 cargo run cargo check 检查代码,确保能通过编译,但是不产生任何可执行文件 为发布构建 cargo build –release 尽量用Cargo [package] name = &quot;hello_cargo&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] rand = &quot;0.8.4&quot; use std::io; //prelude use std::cmp::Ordering; use rand::Rng; //trait fn main() &#123; println!(&quot;guess the number of bytes to read_line&quot;); let secret_number = rand::thread_rng().gen_range(1..1024); println!(&quot;secret number: &#123;&#125;&quot;, secret_number); let _res = 1; //mut可以改变 let mut guess = String::new(); //返回字符串新的实例 //new:创建一个空的字符串 //&amp; : 表示参数是引用类型 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); //io:Result Ok, Err //&#123;&#125;: 占位符, 对应后面变量的值 let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;); println!(&quot;number: &#123;&#125;&quot;,guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; println!(&quot;To Win!&quot;), &#125; &#125; use rand::Rng; use std::cmp::Ordering; use std::io; //prelude //trait fn main() &#123; let secret_number = rand::thread_rng().gen_range(1..1024); loop &#123; println!(&quot;guess the number of bytes to read_line&quot;); let mut guess = String::new(); //返回字符串新的实例 io::stdin().read_line(&amp;mut guess).expect(&quot;Unable to read_line&quot;); let guess: u32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; println!(&quot;number: &#123;&#125;&quot;, guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(&quot;Too small!&quot;), Ordering::Greater =&gt; println!(&quot;To big&quot;), Ordering::Equal =&gt; &#123; println!(&quot;To Win!&quot;); break; &#125; &#125; &#125; &#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"http://am900skp.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://am900skp.github.io/tags/Rust/"}]},{"title":"数据结构-排序算法(sort)","slug":"数据结构-排序算法(sort)","date":"2022-07-18T02:35:06.000Z","updated":"2023-02-09T11:44:45.029Z","comments":true,"path":"2022/07/18/数据结构-排序算法(sort)/","link":"","permalink":"http://am900skp.github.io/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(sort)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 冒泡排序 思路:基于比较 循环比较相邻两个元素 如果不符合要求 就交换 最后那个已然符合要求 每次冒出来一个 所以循环 len-1 次 可以达成目标 void BubbleSort(int* arr, int len) &#123; for (int i = 0; i &lt; len - 1; ++i) &#123; for (int j = 0; j &lt; len - 1 - i; ++j) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; 选择排序 思路:每次选择最小的，放到应该放的位置 选 len-1 完事 void SelectSort(int* arr, int len) &#123; int min_idx; int tmp; for (int i = 0; i &lt; len - 1; ++i) &#123; min_idx = i; for (int j = i + 1; j &lt; len; ++j) &#123; min_idx = ((arr[min_idx] &lt; arr[j]) ? min_idx : j); &#125; tmp = arr[i]; arr[i] = arr[min_idx]; arr[min_idx] = tmp; // TraverArray(arr, len, false); &#125; &#125; 可以优化的选择排序(插入排序) 思路:把待排数组的第一个元素看成是一个有序数组,然后一个个的把其他元素插入到这个有序数组中去 临时存储待插入数据 从待插数据的前一个位置开始 从后往前找插入位置 没找到插入位置前 往后覆盖 找到插入位置 结束循环 然后待插数据覆盖当前位置 void InsertSort(int* arr, int len) &#123; int pre_idx; int current; for (int i = 1; i &lt; len; ++i) &#123; pre_idx = i - 1; current = arr[i]; while (pre_idx &gt;= 0 &amp;&amp; arr[pre_idx] &gt; current) &#123; arr[pre_idx + 1] = arr[pre_idx]; pre_idx--; &#125; arr[pre_idx + 1] = current; &#125; &#125; 希尔排序 思路:先分组 在组内做插入排序 一般是先分成 len&#x2F;2 组 然后分成 len&#x2F;2&#x2F;2 组 ​ 。。。。 ​ 2组 最后 1组 组的数量 我们称之为 步长 step： len&#x2F;2 len&#x2F;4 … 2 1 void ShellSort(int* arr, int len) &#123; for (int grap = len / 2; grap &gt; 0; grap /= 2) &#123; for (int i = grap; i &lt; len; ++i) &#123; int j = i; int current = arr[i]; while (j - grap &gt;= 0 &amp;&amp; current &lt; arr[j - grap]) &#123; arr[j] = arr[j - grap]; j = j - grap; &#125; arr[j] = current; &#125; &#125; &#125; 简单总结一下: 冒泡排序 每次冒出一个 选择排序 每次选出一个放到合适位置 插入排序 把左边一个元素看成一个有序数组 从第二个元素起把元素一个个的插入到有序数组中 希尔排序 按步长 分组 组内作插入排序 截止到目前,这四种基于比较的排序算法,都不稳定,数据一换,可能效率就会改变很多. 下面阐述一下分治思想二分查找: mid &#x3D; l + (r-l)&#x2F;2;分组排序 快速排序 把数据分成两组 左边的 比中间值小 右边的比中间值大 假定 a[l]是中间值 temp &#x3D; a[l] 循环让l和r并拢 如果l小于r 循环继续 循环判断 a[r] 是否大于temp 如果大于 r– 如果不大于 循环结束 循环结束后 a[l] &#x3D; a[r] 循环判断 a[l] 是否小于temp 如果小于 l++ 如果不小于 循环结束 循环结束后 a[r] &#x3D; a[l] l和r并拢后 temp覆盖 a[l] l和r并拢后 left - l 小于 temp l+1 到right 大于temp left到l 继续分组 l+1 到right 继续分组 直到 无法拆分 左边的继续分两组 右边的继续分两组 一直到无法分割为止 计数排序 void CountSort(int* arr, int len) &#123; int* count_arr = (int*)calloc(sizeof(int), 100); assert(count_arr); for (int i = 0; i &lt; len; ++i) &#123; count_arr[arr[i]]++; //把数据当做数组下标去记录当前数据的个数 &#125; int* sort_arr = (int*)malloc(sizeof(int) * len); assert(sort_arr); for (int i = 1; i &lt; 100; ++i) &#123; //求和 count_arr[i] += count_arr[i - 1]; &#125; //取数据 for (int i = len; i &gt; 0; --i) &#123; sort_arr[count_arr[arr[i - 1]] - 1] = arr[i - 1]; count_arr[arr[i - 1]]--; &#125; memcpy(arr, sort_arr, len * sizeof(int)); free(count_arr); free(sort_arr); &#125; 快速排序 //交换辅助函数 void Swap(int* arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; //改变基准 int Partition(int* arr, int left, int right) &#123; int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; ++i) &#123; if (arr[i] &lt; arr[pivot]) &#123; Swap(arr, i, index); index++; &#125; &#125; Swap(arr, pivot, index - 1); return index - 1; &#125; void Quick(int* arr, int left, int right) &#123; if (left &lt; right) &#123; int partition_index = Partition(arr, left, right); Quick(arr, left, partition_index - 1); Quick(arr, partition_index + 1, right); &#125; &#125; //统一接口 void QuickSort(int* arr, int len) &#123; Quick(arr, 0, len - 1); &#125; 归并排序 思路:把两个有序数组合并成一个有序数组 创建临时数组 一个个比较把两个有序数组中的元素逐个放到临时数组中 把剩下的放到临时数组中 临时数组覆盖待排序数组 /普通的归并排序 void BasicMerge(int* arr, int f_begin, int f_end, int s_begin, int s_end, int* new_arr) &#123; int index = f_begin; int f = f_begin; int s = s_begin; while (f &lt;= f_end &amp;&amp; s &lt;= s_end) &#123; if (arr[f] &lt;= arr[s]) &#123; new_arr[++index] = arr[++f]; &#125; else &#123; new_arr[++index] = arr[++s]; &#125; &#125; //处理剩下元素 while (f &lt;= f_end) &#123; new_arr[++index] = arr[++f]; &#125; while (s &lt;= s_end) &#123; new_arr[++index] = arr[++s]; &#125; // 1 2 3 3-1 = 2 其实元素有三个 memcpy(arr + f_begin, new_arr + f_begin, sizeof(int) * (s_end - f_begin + 1)); &#125; void Merge(int* arr, int left, int right, int* new_arr) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; Merge(arr, left, mid, new_arr); Merge(arr, mid + 1, right, new_arr); BasicMerge(arr, left, mid, mid + 1, right, new_arr); &#125; //统一接口 void MergeSort(int* arr, int len) &#123; int* tmp = (int*)malloc(sizeof(int) * len); Merge(arr, 0, len - 1, tmp); free(tmp); &#125; 基数排序与桶排序 基数排序思路:数组下标天然有序 限制超级多 只能是正整数 (如果有负数，转成正数先) 不能重复 需要特别注意空间 桶排序思路:先把数据分成若干个桶，然后桶内用其他排序方式排序，排完之后再合并 非常稳定 空间换时间 //获取当前数字的任意位上的数字 int GetPosNumber(int num, int pos) &#123; int tmp = 1; for (int i = 0; i &lt; pos - 1; ++i) &#123; tmp *= 10; &#125; return (num / tmp) % 10; &#125; //获取数组最大值 int GetMaxNumber(int* arr, int len) &#123; int max = arr[0]; for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; max = arr[i]; &#125; &#125; return max; &#125; //求最大值的位数 int GetMaxNumberCount(int num) &#123; int count = 1; while (num / 10) &#123; count++; num /= 10; &#125; return count; &#125; //桶排序 void BucketSort(int* arr, int len, int pos) &#123; int* bucket_arr[10] = &#123;NULL&#125;; for (int i = 0; i &lt; 10; i++) &#123; //初始化为0 如果数据中有0的数据，换一个标记 bucket_arr[i] = (int*)calloc(sizeof(int), len); assert(bucket_arr[i]); &#125; //装桶 for (int i = 0; i &lt; len; ++i) &#123; int index = GetPosNumber(arr[i], pos); for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[index][j] == 0) &#123; bucket_arr[index][j] = arr[i]; break; &#125; &#125; &#125; //出桶 int k = 0; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; len; ++j) &#123; if (bucket_arr[i][j] != 0) &#123; arr[k] = bucket_arr[i][j]; bucket_arr[i][j] = 0; k++; &#125; &#125; &#125; &#125; //基数排序 void RadixSort(int* arr, int len) &#123; int max_num = GetMaxNumber(arr, len); int loop = GetMaxNumberCount(max_num); for (int i = 1; i &lt;= loop; ++i) &#123; BucketSort(arr, len, i); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉搜索树(tree)","slug":"数据结构-二叉搜索树(tree)","date":"2022-07-08T11:34:11.000Z","updated":"2023-02-09T11:44:49.453Z","comments":true,"path":"2022/07/08/数据结构-二叉搜索树(tree)/","link":"","permalink":"http://am900skp.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 描述二叉搜索树单一类型://处理二叉搜索树的数据 typedef struct DatePair &#123; int first; //比较准备 char second[20]; //字符串数据为例 &#125; DATA, *LPDATA; //二叉树结点类型 typedef struct TreeNode &#123; DATA data; struct TreeNode* p_left_child; struct TreeNode* p_right_child; &#125; NODE, *LPNODE; //二叉搜索树 BST typedef struct BinarySearchTree &#123; LPNODE p_root; //用一个根节点表述整个树 int tree_size; //结点个数 &#125; BST, *LPBST; 创建结点://创建结点 LPNODE CreateTreeNode(DATA data) &#123; LPNODE p_new_tree_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_tree_node) &#123; return NULL; &#125; p_new_tree_node-&gt;data = data; p_new_tree_node-&gt;p_left_child = NULL; p_new_tree_node-&gt;p_right_child = NULL; return p_new_tree_node; &#125; 描述二叉搜索树最初状态://描述二叉搜索树最初状态 LPBST CreateBinarySearchTree() &#123; LPBST p_binary_search_tree = (LPBST)malloc(sizeof(BST)); if (NULL == p_binary_search_tree) &#123; return NULL; &#125; p_binary_search_tree-&gt;p_root = NULL; p_binary_search_tree-&gt;tree_size = 0; return p_binary_search_tree; &#125; 万金油://万金油 int Size(LPBST p_tree) &#123; return p_tree-&gt;tree_size; &#125; int Empty(LPBST p_tree) &#123; return p_tree-&gt;tree_size == 0; &#125; 二叉搜索树的插入://二叉搜索树的插入 void InsertTreeNode(LPBST p_tree, DATA data) &#123; LPNODE p_new_tree_node = CreateTreeNode(data); //找合适的位置 LPNODE p_move = p_tree-&gt;p_root; LPNODE p_move_parent = NULL; while (NULL != p_move) &#123; p_move_parent = p_move; if (data.first &lt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_left_child; &#125; else if (data.first &gt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_right_child; &#125; else &#123; //相等采用覆盖的方式 strcpy(p_move-&gt;data.second, data.second); return; &#125; &#125; //分析查找结果 if (p_tree-&gt;p_root == NULL) &#123; p_tree-&gt;p_root = p_new_tree_node; &#125; else &#123; //如果不为NULL,考虑插在parent左边还是右边 if (p_move_parent-&gt;data.first &gt; data.first) &#123; p_move_parent-&gt;p_left_child = p_new_tree_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_new_tree_node; &#125; &#125; p_tree-&gt;tree_size++; &#125; 二叉搜索树的遍历:void PrintNode(LPNODE p_cur_node) &#123; printf(&quot;%d:%s\\n&quot;, p_cur_node-&gt;data.first, p_cur_node-&gt;data.second); &#125; //二叉搜索树中序遍历 void MidOrderBinaryTree(LPNODE p_tree) &#123; if (NULL != p_tree) &#123; MidOrderBinaryTree(p_tree-&gt;p_left_child); PrintNode(p_tree); MidOrderBinaryTree(p_tree-&gt;p_right_child); &#125; &#125; 查找树结点LPNODE SearchBST(LPBST p_tree, int first) &#123; LPNODE p_move = p_tree-&gt;p_root; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; if (p_move-&gt;data.first &gt; first) &#123; p_move = p_move-&gt;p_left_child; &#125; else &#123; p_move = p_move-&gt;p_right_child; &#125; &#125; return p_move; &#125; 测试数据:int main(int argc, char* argv[]) &#123; LPBST p_binary_search_tree = CreateBinarySearchTree(); DATA data[8] = &#123;10, &quot;倪妮&quot;, 18, &quot;睿睿&quot;, 3, &quot;王冰冰&quot;, 8, &quot;bug&quot;, 12, &quot;gg&quot;, 2, &quot;MM&quot;, 7, &quot;HH&quot;, 4, &quot;王菲&quot;&#125;; for (int i = 0; i &lt; 8; ++i) &#123; InsertTreeNode(p_binary_search_tree, data[i]); &#125; MidOrderBinaryTree(p_binary_search_tree-&gt;p_root); LPNODE result = SearchBST(p_binary_search_tree,100); if (NULL == result) &#123; printf(&quot;未找到相关信息\\n&quot;); &#125; printf(&quot;18:%s\\n&quot;,SearchBST(p_binary_search_tree,18)-&gt;data.second); return 0; &#125; 二叉搜索树的删除://二叉搜索树的删除 void DeleteNode(LPBST p_tree, int first) &#123; LPNODE p_move = p_tree-&gt;p_root; LPNODE p_move_parent = NULL; while (NULL != p_move &amp;&amp; p_move-&gt;data.first != first) &#123; p_move_parent = p_move; if (first &lt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_left_child; &#125; else if (first &gt; p_move-&gt;data.first) &#123; p_move = p_move-&gt;p_right_child; &#125; else &#123; break; &#125; &#125; //分析结果 if (NULL == p_move) &#123; printf(&quot;无此处,删除失败\\n&quot;); return; &#125; else if (p_move-&gt;p_left_child != NULL &amp;&amp; p_move-&gt;p_right_child != NULL) &#123; //左右子树都健在的情况 LPNODE p_move_node = p_move-&gt;p_left_child; LPNODE p_move_node_parent = p_move; while (NULL != p_move_node-&gt;p_right_child) &#123; p_move_node_parent = p_move_node; p_move_node = p_move_node-&gt;p_right_child; &#125; LPNODE p_new_node = CreateTreeNode(p_move_node-&gt;data); p_new_node-&gt;p_left_child = p_move-&gt;p_left_child; p_new_node-&gt;p_left_child = p_move-&gt;p_right_child; //分类讨论父节点是否存在 if (NULL == p_move_parent) &#123; p_tree-&gt;p_root = p_new_node; &#125; else if (p_move == p_move_parent-&gt;p_left_child) &#123; p_move_parent-&gt;p_left_child = p_new_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_new_node; &#125; //调整二叉树 //改变删除指针的位置 if (p_move_node_parent == p_move) &#123; //调整的结点在左边 p_move_parent = p_new_node; &#125; else &#123; p_move_parent = p_move_node_parent; &#125; free(p_move); //原来的结点干掉 p_move = p_move_node; //删除指针调整到要调节的位置 &#125; //只有一边的情况的删除 LPNODE p_side_node = NULL; if (NULL != p_move-&gt;p_left_child) &#123; p_side_node = p_move-&gt;p_left_child; &#125; else &#123; p_side_node = p_move-&gt;p_right_child; &#125; if (p_tree-&gt;p_root == p_move) &#123; p_tree-&gt;p_root = p_side_node; &#125; else &#123; if (p_move == p_move_parent-&gt;p_left_child) &#123; p_move_parent-&gt;p_left_child = p_side_node; &#125; else &#123; p_move_parent-&gt;p_right_child = p_side_node; &#125; &#125; free(p_move); p_tree-&gt;tree_size--; &#125; 测试数据:printf(&quot;删除3结点:\\n&quot;); DeleteNode(p_binary_search_tree,3); printf(&quot;中序遍历二叉搜素树:\\n&quot;); MidOrderBinaryTree(p_binary_search_tree-&gt;p_root);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-二叉树(tree)","slug":"数据结构-二叉树(tree)","date":"2022-07-07T00:26:46.000Z","updated":"2023-02-09T11:44:49.590Z","comments":true,"path":"2022/07/07/数据结构-二叉树(tree)/","link":"","permalink":"http://am900skp.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91(tree)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 最容易想到的创建方法 先创建结点,在根据树结构链接树结点 //结构体描述 typedef struct TreeNode &#123; char data; struct TreeNode* p_left_child; struct TreeNode* p_right_child; &#125; TREE, *LPTREE; //暴力创建法 LPTREE CreateTreeNode(char data) &#123; LPTREE p_tree_node = (LPTREE)malloc(sizeof(TREE)); p_tree_node-&gt;data = data; p_tree_node-&gt;p_left_child = NULL; p_tree_node-&gt;p_right_child = NULL; return p_tree_node; &#125; //插入树 void InsertTreeNode(LPTREE p_parent, LPTREE p_left_child, LPTREE p_right_child) &#123; p_parent-&gt;p_left_child = p_left_child; p_parent-&gt;p_right_child = p_right_child; &#125; int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 递归遍历: //先序遍历 void PreOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; printf(&quot;%c\\t&quot;, p_root-&gt;data); PreOrderTree(p_root-&gt;p_left_child); PreOrderTree(p_root-&gt;p_right_child); &#125; &#125; //中序 void MidOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; MidOrderTree(p_root-&gt;p_left_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); MidOrderTree(p_root-&gt;p_right_child); &#125; &#125; //后序 void LastOrderTree(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; else &#123; LastOrderTree(p_root-&gt;p_left_child); LastOrderTree(p_root-&gt;p_right_child); printf(&quot;%c\\t&quot;, p_root-&gt;data); &#125; &#125; 递归法创建二叉树//递归创建 void CreateTree(LPTREE* p_tree) &#123; char user_key = &#39;\\0&#39;; scanf(&quot;%c&quot;, &amp;user_key); if (user_key == &#39;#&#39;) &#123; *p_tree = NULL; &#125; else &#123; *p_tree = (TREE*)malloc(sizeof(TREE)); (*p_tree)-&gt;data = user_key; CreateTree(&amp;(*p_tree)-&gt;p_left_child); CreateTree(&amp;(*p_tree)-&gt;p_right_child); &#125; &#125; int main(int argc, char** argv) &#123; //测试数据:ABD#G###CE##F## LPTREE A = NULL; CreateTree(&amp;A); printf(&quot;先序遍历:&quot;); PreOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;中序遍历:&quot;); MidOrderTree(A); putchar(&#39;\\n&#39;); printf(&quot;后序遍历:&quot;); LastOrderTree(A); putchar(&#39;\\n&#39;); return 0; &#125; 先序遍历:A B D G C E F 中序遍历:D G B A E C F 后序遍历:G D B E F C A 层次遍历://层次遍历,(队列) void LayerOrder(LPTREE p_root) &#123; //准备一个移动结点 LPTREE p_move = p_root; //准备一个队列 LPTREE p_queue[1024]; int front = 0; int tail = 0; p_queue[tail++] = p_move; printf(&quot;%c\\t&quot;, p_move-&gt;data); while (front != tail) &#123; //出队 p_move = p_queue[front++]; //如果有左子树,左子树入队,右子树同理 if (p_move-&gt;p_left_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_left_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_left_child-&gt;data); &#125; if (p_move-&gt;p_right_child != NULL) &#123; p_queue[tail++] = p_move-&gt;p_right_child; printf(&quot;%c\\t&quot;,p_move-&gt;p_right_child-&gt;data); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); // LPTREE A = NULL; // CreateTree(&amp;A); // printf(&quot;先序遍历:&quot;); // PreOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;中序遍历:&quot;); // MidOrderTree(A); // putchar(&#39;\\n&#39;); // printf(&quot;后序遍历:&quot;); // LastOrderTree(A); // putchar(&#39;\\n&#39;); printf(&quot;层次遍历:&quot;); LayerOrder(A); return 0; &#125; 非递归遍历(通过栈的方式): 先序: //非递归遍历 //先序遍历 // 1.一直走走左子树,边走边打印相关结点数据,ABD,把走过的结点入栈,不然回退不了,当前栈里元素:DBA // 2.p_move = D, 栈里还剩下BA, 出栈后,p_move走右边,做同样的事情 void PreOrderTreeByStack(LPTREE p_root) &#123; if (p_root == NULL) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (stack_top != -1 || NULL != p_move) &#123; //往左边走,边走边打印,走过的路入栈 while (p_move) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_stack[++stack_top] = p_move; //走过的地方入栈 p_move = p_move-&gt;p_left_child; &#125; //出栈 if (stack_top != -1) &#123; p_move = p_stack[stack_top--]; //出站后往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 中序: //中序遍历的非递归方式 //左边一直走,不做打印,入栈即可 //出栈的时候,打印结点,再去找右边 void MidOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return; &#125; LPTREE p_move = p_root; LPTREE p_stack[1000]; int stack_top = -1; while (NULL != p_move || stack_top != -1) &#123; while (p_move) &#123; //入栈 p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; if (stack_top != -1) &#123; //出栈 p_move = p_stack[stack_top--]; printf(&quot;%c\\t&quot;, p_move-&gt;data); //往右面走 p_move = p_move-&gt;p_right_child; &#125; &#125; &#125; 后序: //后续非递归遍历 //把最后一次访问过的结点标注 void LastOrderTreeByStack(LPTREE p_root) &#123; if (NULL == p_root) &#123; return NULL; &#125; LPTREE p_stack[1000]; int stack_top = -1; LPTREE p_move = p_root; LPTREE p_last_visit = NULL; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; while (stack_top != -1) &#123; p_move = p_stack[stack_top--]; // D if (p_move-&gt;p_right_child == NULL || p_move-&gt;p_right_child == p_last_visit) &#123; printf(&quot;%c\\t&quot;, p_move-&gt;data); p_last_visit = p_move; &#125; else &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_right_child; while (p_move) &#123; p_stack[++stack_top] = p_move; p_move = p_move-&gt;p_left_child; &#125; &#125; &#125; &#125; 测试数据: int main(int argc, char** argv) &#123; LPTREE A = CreateTreeNode(&#39;A&#39;); LPTREE B = CreateTreeNode(&#39;B&#39;); LPTREE C = CreateTreeNode(&#39;C&#39;); LPTREE D = CreateTreeNode(&#39;D&#39;); LPTREE E = CreateTreeNode(&#39;E&#39;); LPTREE F = CreateTreeNode(&#39;F&#39;); LPTREE G = CreateTreeNode(&#39;G&#39;); InsertTreeNode(A, B, C); InsertTreeNode(B, D, NULL); InsertTreeNode(C, E, F); InsertTreeNode(D, NULL, G); printf(&quot;非递归前序遍历:&quot;); PreOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归中序遍历:&quot;); MidOrderTreeByStack(A); putchar(&#39;\\n&#39;); printf(&quot;非递归后序遍历:&quot;); LastOrderTreeByStack(A); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-堆(heap)","slug":"数据结构-堆(heap)","date":"2022-07-06T04:50:51.000Z","updated":"2023-02-09T11:44:51.405Z","comments":true,"path":"2022/07/06/数据结构-堆(heap)/","link":"","permalink":"http://am900skp.github.io/2022/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86(heap)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 系统堆: malloc, new出来的内存,可以随便拿,随便取人为堆: 引申出的一种特定堆,按照二叉树形式排列的一种堆大顶堆: 数组中依次插入元素: 从下标1开始依次插入元素, ++cur_size 形成二叉树形式: 父结点的下标等于孩子结点的一半 相邻的层数相比,上面的元素要比下面的大 描述大顶堆单一结构://存10个元素, 第0个位置不存放元素 const int g_MAX = 11; typedef struct &#123; int* p_heap_data; int heap_size; &#125; HEAP, *LPHEAP; 创建堆:LPHEAP CreateHeap() &#123; LPHEAP p_heap = (LPHEAP)malloc(sizeof(HEAP)); if (NULL == p_heap) &#123; return NULL; &#125; p_heap-&gt;heap_size = 0; p_heap-&gt;p_heap_data = (int*)malloc(sizeof(int) * g_MAX); return p_heap; &#125; 形成二叉树:void CreateBigHeap(LPHEAP p_heap, int cur_pos) &#123; while (cur_pos &gt; 1) &#123; int max = p_heap-&gt;p_heap_data[cur_pos]; //假设当前下标为最大元素 int parent_index = cur_pos / 2; //父结点的下标 //父结点与最大元素相比,如果当前元素大,就交换 if (max &gt; p_heap-&gt;p_heap_data[parent_index]) &#123; //父结点与当前结点元素交换 p_heap-&gt;p_heap_data[cur_pos] = p_heap-&gt;p_heap_data[parent_index]; p_heap-&gt;p_heap_data[parent_index] = max; //当前下标变为父结点 cur_pos = parent_index; &#125; else &#123; break; &#125; &#125; &#125; 向堆中插入元素:void InsertHeap(LPHEAP p_heap, int new_data) &#123; if (p_heap-&gt;heap_size == g_MAX - 1) &#123; return; &#125; //直接插在当前下标 p_heap-&gt;p_heap_data[++p_heap-&gt;heap_size] = new_data; CreateBigHeap(p_heap, p_heap-&gt;heap_size); &#125; 遍历大顶堆:void PrintHeap(LPHEAP p_heap) &#123; for (int i = 1; i &lt;= p_heap-&gt;heap_size; ++i) &#123; printf(&quot;%d\\t&quot;, p_heap-&gt;p_heap_data[i]); &#125; putchar(&#39;\\n&#39;); &#125; 有序出堆://出堆 //先将堆顶,再找下面一层最大的依次抛出 int OutHeap(LPHEAP p_heap) &#123; int max = p_heap-&gt;p_heap_data[1]; //大顶堆第一个元素就是最大的 int cur_pos = 1; //当前下标 int child_pos = cur_pos * 2; //孩子结点序号 while (child_pos &lt;= p_heap-&gt;heap_size) &#123; int tmp = p_heap-&gt;p_heap_data[child_pos]; //每一层的第一个 //同一层上进行左右结点比较 if (child_pos + 1 &lt;= p_heap-&gt;p_heap_data &amp;&amp; //左边的元素小于右边的元素 tmp &lt; p_heap-&gt;p_heap_data[child_pos + 1]) &#123; tmp = p_heap-&gt;p_heap_data[++child_pos]; &#125; //向下去找 p_heap-&gt;p_heap_data[cur_pos] = tmp; cur_pos = child_pos; child_pos *= 2; &#125; p_heap-&gt;p_heap_data[cur_pos]=p_heap-&gt;p_heap_data[p_heap-&gt;heap_size]; --p_heap-&gt;heap_size; return max; &#125; int Size(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size; &#125; int Empty(LPHEAP p_heap) &#123; return p_heap-&gt;heap_size == 0; &#125; //测试数据 int main(int argc, char** argv) &#123; srand((unsigned int)time(NULL)); LPHEAP p_heap = CreateHeap(); for (int i = 0; i &lt; 10; ++i) &#123; InsertHeap(p_heap, rand() % 100); &#125; printf(&quot;存储情况:&quot;); PrintHeap(p_heap); putchar(&#39;\\n&#39;); printf(&quot;堆排序:&quot;); while(!Empty(p_heap)) &#123; printf(&quot;%d\\t&quot;,OutHeap(p_heap)); &#125; return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希表(hash)","slug":"数据结构-哈希表(hash)","date":"2022-07-05T10:06:58.000Z","updated":"2023-02-09T11:44:48.165Z","comments":true,"path":"2022/07/05/数据结构-哈希表(hash)/","link":"","permalink":"http://am900skp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 链式结构描述哈希表// 保证有序性插入 //产生相同的就以当前结点为表头创建链表插在后面 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct DataType &#123; int key; char element[20]; &#125;; struct Node &#123; struct DataType data; struct Node* p_next; &#125;; struct Node* CreateNode(struct DataType data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //散列表结点的描述 struct SkipListNode &#123; struct DataType data; struct Node* p_first_node; //横向链表的第一个结点 struct SkipListNode* p_next; //纵向,第一列的链表链接 &#125;; struct SkipListNode* CreateSkipListNode(struct DataType data) &#123; struct SkipListNode* p_new_node = (struct SkipListNode*)malloc(sizeof(struct SkipListNode)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_first_node = NULL; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //描述哈希结构 struct ListHash &#123; struct SkipListNode* p_head_node; int hash_size; int divisor; &#125;; //创建哈希结构 struct ListHash* CreateHash(int divisor) &#123; struct ListHash* p_hash = (struct ListHash*)malloc(sizeof(struct ListHash)); if (NULL == p_hash) &#123; return NULL; &#125; p_hash-&gt;divisor = divisor; p_hash-&gt;hash_size = 0; p_hash-&gt;p_head_node = NULL; return p_hash; &#125; void InsertHash(struct ListHash* p_hash, struct DataType data) &#123; int data_hash_pos = data.key % p_hash-&gt;divisor; //变成散列表结点 struct SkipListNode* p_new_skip_node = CreateSkipListNode(data); //头结点为空,直接充当表头,无头链表 if (p_hash-&gt;p_head_node == NULL) &#123; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; return; &#125; else &#123; //头结点不为空 struct SkipListNode* p_move = p_hash-&gt;p_head_node; struct SkipListNode* p_move_left = NULL; //存在哈希冲突 //第一个结点的key大于元素的key:无表头链表的表头法插入 if (p_move-&gt;data.key % p_hash-&gt;divisor &gt; data_hash_pos) &#123; p_new_skip_node-&gt;p_next = p_hash-&gt;p_head_node; p_hash-&gt;p_head_node = p_new_skip_node; p_hash-&gt;hash_size++; &#125; else &#123; //找到合适的位置,(找到了,没找到,相同的(键相同,hash地址相同)) //第一次大于要插入元素哈希地址的位置 while (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) &lt; data_hash_pos) &#123; p_move_left = p_move; p_move = p_move_left-&gt;p_next; &#125; //存在冲突,则插入到横向链表中 if (p_move != NULL &amp;&amp; (p_move-&gt;data.key % p_hash-&gt;divisor) == data_hash_pos) &#123; if (p_move-&gt;data.key == data.key) &#123; //键相同采用覆盖的方式 strcpy(p_move-&gt;data.element, data.element); &#125; else &#123; //横向插入 struct Node* p_new_node = CreateNode(data); struct Node* p_move_ = p_move-&gt;p_first_node; if (NULL == p_move_left) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; //横向中冲突的元素是否存在相同的键 while (p_move_ != NULL &amp;&amp; p_move_-&gt;data.key != data.key) &#123; p_move_ = p_move_-&gt;p_next; &#125; if (NULL == p_move_) &#123; p_new_node-&gt;p_next = p_move-&gt;p_first_node; p_move-&gt;p_first_node = p_new_node; p_hash-&gt;hash_size++; &#125; else &#123; strcpy(p_move_-&gt;data.element, data.element); &#125; &#125; &#125; &#125; else &#123; //不存在冲突的情况,直接插在纵向链表中 p_move_left-&gt;p_next = p_new_skip_node; p_new_skip_node-&gt;p_next = p_move; p_hash-&gt;hash_size++; &#125; &#125; &#125; &#125; void PrintHash(struct ListHash* p_hash) &#123; struct SkipListNode* p_move = p_hash-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d:%s\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); //横向遍历 struct Node* p_move_ = p_move-&gt;p_first_node; while (NULL != p_move_) &#123; printf(&quot;%d:%s\\t\\t&quot;, p_move-&gt;data.key, p_move-&gt;data.element); p_move_ = p_move_-&gt;p_next; &#125; putchar(&#39;\\n&#39;); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; struct ListHash* p_hash = CreateHash(10); struct DataType array[] = &#123; 1,&quot;王菲&quot;,12,&quot;刘亦菲&quot;,11,&quot;LZG&quot;,15,&quot;Baby&quot;,1,&quot;睿睿&quot; ,22,&quot;王菲&quot;,32,&quot;Oracle&quot;,56,&quot;LZG&quot;,75,&quot;Baby&quot;,80,&quot;睿睿&quot; &#125;; for (int i = 0; i &lt; 10; ++i) &#123; InsertHash(p_hash, array[i]); &#125; PrintHash(p_hash); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-哈希存储(hash)","slug":"数据结构-哈希存储(hash)","date":"2022-07-05T09:12:58.000Z","updated":"2023-02-09T11:44:46.482Z","comments":true,"path":"2022/07/05/数据结构-哈希存储(hash)/","link":"","permalink":"http://am900skp.github.io/2022/07/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8(hash)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss Hash基础(hash叫做哈希,又称为散列)哈希构造函数(用来求hash地址的,不是指针),人为的地址 取余法: h(k) &#x3D; k % p h(key) &#x3D; key % p p &#x3D; 10(p由自己决定) h(10) &#x3D; 10 % 10 &#x3D; 0; h(14) &#x3D; 14 % 10 &#x3D; 4; 直接定址: h(k) &#x3D; k array[12] &#x3D; 12; array[13] &#x3D; 13 随机数法: rand(); 哈希冲突: 不同的元素会产生相同的哈希地址 如何处理哈希冲突 开放地址法: 产生冲突的元素存放到空的空间中 邻接表-&gt;图: 在冲突位置创建一个链表 任何有冲突的元素都存到此链表中 数组描述Hash结构:为数据构建关键字:typedef struct Pair &#123; int hash_address; //为数据构建一个关键字,用来产生hash地址 char element[20]; &#125; DATA, *LPDATA; Hash结构:typedef struct HashTable &#123; LPDATA* table; //注意这里是二级指针 int divisor; //除数, 采用取余法 key%p, p就是divisor int hash_size; //当前元素个数 &#125; HASH, *LPHASH; 创建Hash表LPHASH CreateHash(int divisor) &#123; LPHASH p_hash_table = (LPHASH)malloc(sizeof(HASH)); if (NULL == p_hash_table) &#123; return NULL; &#125; //初始化hash表 p_hash_table-&gt;hash_size = 0; p_hash_table-&gt;divisor = divisor; //动态内存申请HashTable p_hash_table-&gt;table = (LPDATA*)malloc(sizeof(LPDATA) * p_hash_table-&gt;divisor); // p_hash_table[i]:一级指针 for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; p_hash_table-&gt;table[i] = NULL; &#125; return p_hash_table; &#125; 获取Hash地址:int SearchHashAddress(LPHASH p_hash_table, int data_address) &#123; //因为存在哈希地址,所以我这里单独封装一个函数做这个事情 int pos = data_address % p_hash_table-&gt;divisor; int cur_pos = pos; //查找结束的结果 do &#123; //没有值就可以存到里面 if (p_hash_table-&gt;table[cur_pos] == NULL || p_hash_table-&gt;table[cur_pos]-&gt;hash_address == data_address) &#123; return cur_pos; &#125; cur_pos = (cur_pos + 1) % p_hash_table-&gt;divisor; &#125; while (cur_pos != pos); return cur_pos; &#125; 向Hash表中插入数据:void InsertData(LPHASH p_hash_table, DATA data) &#123; //求出哈希地址 int pos = SearchHashAddress(p_hash_table, data.hash_address); if (p_hash_table-&gt;table[pos] == NULL) &#123; p_hash_table-&gt;table[pos] = (LPDATA)malloc(sizeof(DATA)); memcpy(p_hash_table-&gt;table[pos], &amp;data, sizeof(DATA)); p_hash_table-&gt;hash_size++; &#125; else &#123; //有元素 if (p_hash_table-&gt;table[pos]-&gt;hash_address == data.hash_address) &#123; //相同关键字采用覆盖方式 strcpy(p_hash_table-&gt;table[pos]-&gt;element, data.element); &#125; else &#123; printf(&quot;空间已满,无法插入\\n&quot;); return; &#125; &#125; &#125; 遍历Hash表与测试数据:void PrintHashTable(LPHASH p_hash_table) &#123; for (int i = 0; i &lt; p_hash_table-&gt;divisor; ++i) &#123; if (p_hash_table-&gt;table[i] == NULL) &#123; printf(&quot;NULL\\n&quot;); &#125; else &#123; printf(&quot;%d:%s\\n&quot;, p_hash_table-&gt;table[i]-&gt;hash_address, p_hash_table-&gt;table[i]-&gt;element); &#125; &#125; &#125; //测试数据 int main(int argc, char** argv) &#123; LPHASH p_hash_table = CreateHash(10); DATA array[5] = &#123;1,&quot;刘亦菲&quot;,12,&quot;王菲&quot;, 11,&quot;王冰冰&quot;,15,&quot;Baby&quot;, 1,&quot;睿睿&quot;&#125;; for (int i = 0; i &lt; 5; ++i) &#123; InsertData(p_hash_table, array[i]); &#125; PrintHashTable(p_hash_table); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-串(string,BF,KMP)","slug":"数据结构-串(string,BF,KMP)","date":"2022-07-03T06:36:09.000Z","updated":"2023-02-11T12:36:08.373Z","comments":true,"path":"2022/07/03/数据结构-串(string,BF,KMP)/","link":"","permalink":"http://am900skp.github.io/2022/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2(string,BF,KMP)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 串的基本操作(string)串结构:#define MAX_SIZE 1024 typedef struct &#123; char memory[MAX_SIZE]; //串的内存 int cur_size; //当前串的大小 &#125; STR, *LPSTR; 创建串: 初始化串 内存拷贝 更新串的长度 //创建一个串 LPSTR CreateStr(const char* str) &#123; //开内存 LPSTR p_str = (LPSTR)malloc(sizeof(STR)); //防止&#39;\\0&#39;的问题,这里我选择全初始化为&#39;\\0&#39; for (int i = 0; i &lt; MAX_SIZE; ++i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; //形参拷贝到串的内存 int count = 0; //串的长度 while (str[count] != &#39;\\0&#39;) &#123; p_str-&gt;memory[count] = str[count]; count++; &#125; //更新串的长度 p_str-&gt;cur_size = count; return p_str; &#125; 串的插入: 分两种方式 在串后面插新串(push_back) 在串中间插 注意:最后一个元素的下表是p_str-&gt;cursize - 1 (数组下标从0开始) pos是数组下标,这里写的是在pos的下一个位置进行插入 先腾位置(根据插入串的个数来决定) 插入点后面的元素要向后挪动len(插入进来的串长度)个位置 最后插入新串 //串的插入(在当前串插入多个元素) //pos是数组下标,这里写的是在pos的下一个位置进行插入 void InsertStrByPos(LPSTR p_str, const char* str, int str_len, int pos) &#123; //插在下标前面做减操作 // pos -= 1; if (pos &lt; 0 || pos &gt;= MAX_SIZE) &#123; printf(&quot;下标有误,无法插入\\n&quot;); return; &#125; //大于数组容量 if (p_str-&gt;cur_size + str_len &gt;= MAX_SIZE) &#123; printf(&quot;超出串的容量,无法插入\\n&quot;); return; &#125; //插在原来串的后面 if (pos &gt; p_str-&gt;cur_size) &#123; for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[p_str-&gt;cur_size++] = str[i]; &#125; &#125; else &#123; //腾位置 //从最后一个元素开始挪动(p_str-&gt;cursize - 1) for (int i = p_str-&gt;cur_size - 1; i &gt;= pos; i--) &#123; p_str-&gt;memory[str_len + i] = p_str-&gt;memory[i]; &#125; //插入新串 for (int i = 0; i &lt; str_len; ++i) &#123; p_str-&gt;memory[pos + i] = str[i]; &#125; p_str-&gt;cur_size += str_len; &#125; &#125; 串的删除: 这里写的是区间删除,匹配删除在BF算法中在阐述 如何删除: 直接将后面的元素往前移动 置空后面的元素即可 void DeleteStrByIndex(LPSTR p_str, int start_idx, int end_idx) &#123; if (start_idx &lt;= 0 || start_idx &gt; end_idx || end_idx &gt; MAX_SIZE) &#123; printf(&quot;区间有误,无法删除\\n&quot;); return; &#125; int count = end_idx - start_idx + 1; //真实的区间元素个数 //后面的元素往前移动 for (int i = end_idx, j = start_idx - 1; i &lt; p_str-&gt;cur_size; ++i, ++j) &#123; p_str-&gt;memory[j] = p_str-&gt;memory[i]; &#125; //置空后面的元素 for (int i = p_str-&gt;cur_size; i &gt;= p_str-&gt;cur_size - count; --i) &#123; p_str-&gt;memory[i] = &#39;\\0&#39;; &#125; p_str-&gt;cur_size -= count; &#125; 串的遍历: 也可以用%s //串的打印 void PrintStr(LPSTR p_str) &#123; for (int i = 0; i &lt; p_str-&gt;cur_size; ++i) &#123; printf(&quot;%c&quot;, p_str-&gt;memory[i]); &#125; putchar(&#39;\\n&#39;); &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str = CreateStr(&quot;ILoveyou&quot;); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;插在原来串的后面:\\n&quot;); InsertStrByPos(p_str, &quot;back&quot;, 4, p_str-&gt;cur_size); PrintStr(p_str); printf(&quot;插入XXX:\\n&quot;); InsertStrByPos(p_str, &quot;XXX&quot;, 3, 2); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); printf(&quot;删除1-&gt;3的元素:\\n&quot;); DeleteStrByIndex(p_str, 1, 3); PrintStr(p_str); printf(&quot;p_str-&gt;cur_size:%d\\n&quot;, p_str-&gt;cur_size); return 0; &#125; BF算法: 从父串中找字串,并返回字串的第一个元素位置 父串下标: i , 字串下标: j 从字串的第一个元素开始遍历,并与父串进行匹配 如果不匹配 将字串下标 j 归为0, 字串再从第一个元素与父串进行匹配,并将临时记录序号+1 如果字串的最后一个元素为’\\0’,证明找完了, 返回index + 1 验证的最好方法,代数即可 int BruteForce(LPSTR p_str_one, LPSTR p_str_two) &#123; int index = 0; //临时记录序号,用来返回找到的位置 int i = 0; int j = 0; while (p_str_one-&gt;memory[i] != &#39;\\0&#39; &amp;&amp; p_str_two-&gt;memory[j] != &#39;\\0&#39;) &#123; if (p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; //不匹配, 重新从第一个 ++index; i = index; j = 0; //换第二个位置又从父串第一个位置开始比 &#125; &#125; if (p_str_two-&gt;memory[j] == &#39;\\0&#39;) &#123; return ++index; &#125; return -1; &#125; //测试数据 int main(int argc, char* argv[]) &#123; LPSTR p_str1 = CreateStr(&quot;abcabcacb&quot;); LPSTR p_str2 = CreateStr(&quot;abcac&quot;); printf(&quot;从第%d个元素开始匹配&quot;, BruteForce(p_str1, p_str2)); return 0; &#125; KMP算法: 基本概念: 字符串的”前缀”和”后缀” “前缀”指除了最后一个字符外,一个字符串的全部头部组合; “后缀”指除了第一个字符以外,一个字符串的全部尾组合. 以ABCDABD为例 前缀: A AB ABC ABCD ABCDA ABCDAB 后缀: BCDABD CDABD DABD ABD BD D 部分匹配表 每一个字串里去找前缀和后缀中相同的元素的长度 “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]， 共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]， 共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]， 共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]， 共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]， 共有元素的长度为0。 生成部分匹配表 //获取匹配值 void GetNext(LPSTR p_str, int next[]) &#123; int len = p_str-&gt;cur_size; //用的是数组下标 int i = 0; int j = -1; // 0在这里表示共同元素为0, 有具体的含义,所以初始化为-1了 next[0] = -1; while (i &lt; len) &#123; if (j == -1 || p_str-&gt;memory[i] == p_str-&gt;memory[j]) &#123; ++i; ++j; next[i] = j; //部分匹配元素的长度 &#125; else &#123; j = next[j]; //重置j为-1 &#125; &#125; &#125; int KMP(LPSTR p_str_one, LPSTR p_str_two, int next[]) &#123; //第一个得到表 GetNext(p_str_two, next); int i = 0; int j = 0; while (i &lt; p_str_one-&gt;cur_size &amp;&amp; j &lt; p_str_two-&gt;cur_size) &#123; if (j == -1 || p_str_one-&gt;memory[i] == p_str_two-&gt;memory[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (j == p_str_two-&gt;cur_size) &#123; return i - j; &#125; return -1; &#125; //测试数据 int main(int argc, char** argv) &#123; LPSTR p_str = CreateStr(&quot;ABCDABD&quot;); int next[8]; GetNext(p_str, next); for (int i = 0; i &lt; 8; ++i) &#123; printf(&quot;%d\\t&quot;, next[i]); &#125; putchar(&#39;\\n&#39;); LPSTR p_str_one = CreateStr(&quot;BBC ABCDAB ABCDABCDABDE&quot;); LPSTR p_str_two = CreateStr(&quot;ABCDABD&quot;); printf(&quot;第%d个元素开始匹配\\n&quot;, KMP(p_str_one, p_str_two, next)); putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-队列(queue)","slug":"数据结构-队列(queue)","date":"2022-07-02T07:38:29.000Z","updated":"2023-02-09T11:44:51.131Z","comments":true,"path":"2022/07/02/数据结构-队列(queue)/","link":"","permalink":"http://am900skp.github.io/2022/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97(queue)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 队列(FIFO)先进先出const int g_MAX = 10; //队列大小 入队: 队尾往后走 队头不动 出队: 队头往后走 队尾不动 注意:如果做了一次入元素和出元素,会出现伪溢出问题,最大元素个数就不是g_MAX了如何避免伪溢出:做成循环队列通过取余的方式让队尾回到队头描述队列结构:typedef struct &#123; int* p_queue_memory; int q_front; //队头 int q_tail; //队尾 int q_size; //队列大小 &#125; QUEUE, *LPQUEUE; 用数组描述队列://入队 //只需要将数据存到数组中 void Push(LPQUEUE p_queue, int data) &#123; //判断队是否满,空 if (p_queue-&gt;q_tail &gt;= g_MAX || p_queue-&gt;p_queue_memory == NULL) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail++] = data; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_front &lt; p_queue-&gt;q_tail) &#123; p_queue-&gt;q_front++; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front]; &#125; //判断是否为空 int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; 数组描述循环队列:void Push(LPQUEUE p_queue, int data) &#123; if (p_queue-&gt;q_size == g_MAX) &#123; return; &#125; p_queue-&gt;p_queue_memory[p_queue-&gt;q_tail % g_MAX] = data; p_queue-&gt;q_tail++; p_queue-&gt;q_size++; &#125; //出队 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; p_queue-&gt;q_front = (p_queue-&gt;q_front + 1) % g_MAX; p_queue-&gt;q_size--; &#125; &#125; //获取队头元素 int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_queue_memory[p_queue-&gt;q_front % g_MAX]; &#125; 链式描述队列:typedef struct &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct &#123; LPNODE p_front_node; //队尾 LPNODE p_tail_node; //队头 int q_size; &#125; QUEUE, *LPQUEUE; 创建结点: LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; 创建队列: LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(QUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; p_queue-&gt;p_front_node = NULL; p_queue-&gt;p_tail_node = NULL; p_queue-&gt;q_size = 0; return p_queue; &#125; 相关操作: //入队 //就是无表头链表的表尾法插入 void Push(LPQUEUE p_queue, int data) &#123; LPNODE p_new_node = CreateNode(data); if (0 == p_queue-&gt;q_size) &#123; p_queue-&gt;p_front_node = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; else &#123; p_queue-&gt;p_tail_node-&gt;p_next = p_new_node; p_queue-&gt;p_tail_node = p_new_node; &#125; p_queue-&gt;q_size++; &#125; //出队,表头法删除 void Pop(LPQUEUE p_queue) &#123; if (p_queue-&gt;q_size != 0) &#123; LPNODE p_next_node = p_queue-&gt;p_front_node-&gt;p_next; free(p_queue-&gt;p_front_node); p_queue-&gt;p_front_node = p_next_node; p_queue-&gt;q_size--; &#125; &#125; int Front(LPQUEUE p_queue) &#123; return p_queue-&gt;p_front_node-&gt;data; &#125; int Empty(LPQUEUE p_queue) &#123; return p_queue-&gt;q_size == 0; &#125; void DeleteQueue(LPQUEUE p_queue) &#123; while (!Empty(p_queue)) &#123; Pop(p_queue); &#125; free(p_queue); p_queue = NULL; &#125; 优先队列://优先队列 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef int ElementType; #define g_MAX_SIZE 10 typedef struct &#123; int priority; //工作量 ElementType element; //队列中的元素 &#125; DataType; typedef struct &#123; int size; DataType memory[g_MAX_SIZE]; &#125; PQUEUE, *LPQUEUE; LPQUEUE CreateQueue() &#123; LPQUEUE p_queue = (LPQUEUE)malloc(sizeof(PQUEUE)); if (NULL == p_queue) &#123; return NULL; &#125; // p_queue = (DataType*)malloc(sizeof(DataType)); memset(p_queue-&gt;memory, 0, g_MAX_SIZE * sizeof(DataType)); p_queue-&gt;size = 0; return p_queue; &#125; int Empty(LPQUEUE p_queue) &#123; if (p_queue-&gt;size == 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; void Push(LPQUEUE p_queue, DataType data) &#123; if (p_queue-&gt;size &gt;= g_MAX_SIZE) &#123; return; &#125; else &#123; p_queue-&gt;memory[p_queue-&gt;size++] = data; &#125; &#125; void Pop(LPQUEUE p_queue, DataType* data) &#123; DataType min; int min_idx = 0; if (p_queue-&gt;size &lt;= 0) &#123; return; &#125; else &#123; min = p_queue-&gt;memory[0]; for (int i = 1; i &lt; p_queue-&gt;size; ++i) &#123; //当前作业量西小于原来的 if (p_queue-&gt;memory[i].priority &lt; min.priority) &#123; min = p_queue-&gt;memory[i]; min_idx = i; &#125; &#125; *data = p_queue-&gt;memory[min_idx]; //调整数组 for (int i = min_idx + 1; i &lt; p_queue-&gt;size; ++i) &#123; p_queue-&gt;memory[i - 1] = p_queue-&gt;memory[i]; min_idx = i; &#125; p_queue-&gt;size--; &#125; &#125; int main(int argc, char** argv) &#123; LPQUEUE p_queue = CreateQueue(); DataType tmp_data; FILE* fp = fopen(&quot;task.txt&quot;, &quot;r&quot;); while (!feof(fp)) &#123; fscanf(fp, &quot;%d\\t%d\\n&quot;, &amp;tmp_data.element, &amp;tmp_data.priority); Push(p_queue, tmp_data); &#125; int i = 1; //序号 printf(&quot;序号\\t任务\\t优先级啊\\n&quot;); while (!Empty(p_queue)) &#123; Pop(p_queue, &amp;tmp_data); printf(&quot;%d\\t%d\\t%d\\n&quot;, i, tmp_data.element, tmp_data.priority); i++; &#125; putchar(&#39;\\n&#39;); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-栈(stack)","slug":"数据结构-栈(stack)","date":"2022-07-01T12:29:22.000Z","updated":"2023-02-09T11:44:40.506Z","comments":true,"path":"2022/07/01/数据结构-栈(stack)/","link":"","permalink":"http://am900skp.github.io/2022/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88(stack)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 栈(FILO)先进后出 入栈 出栈 获取栈顶元素 数组栈: 封装栈单一结构 因为是用数组做的,这里定义一个变量表示数组大小 typedef int TYPE; const TYPE g_MAX = 100; typedef struct Stack &#123; TYPE* memory; //栈的容量 int top; //栈顶标记 &#125; STACK, *LPSTACK; 创建一个栈 用一个结构体指针表示栈 memory是指针变量,所以要二次申请内存 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (TYPE*)malloc(sizeof(TYPE) * g_MAX); p_stack-&gt;top = -1; //栈顶标记初始化为-1 return p_stack; &#125; 入栈操作 void PushStack(LPSTACK p_stack, TYPE data) &#123; if (NULL == p_stack || p_stack-&gt;top &gt;= g_MAX) &#123; //栈已满 return; &#125; p_stack-&gt;memory[++p_stack-&gt;top] = data; &#125; 出栈操作 void PopStack(LPSTACK p_stack) &#123; if (NULL == p_stack || p_stack-&gt;top == -1) &#123; return; &#125; //栈顶标记往0靠拢 p_stack-&gt;top--; &#125; 获取栈顶元素 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 栈是否为空 TYPE GetTop(LPSTACK p_stack) &#123; return p_stack-&gt;memory[p_stack-&gt;top]; &#125; 双端栈: 两个栈使用同一段内存 封装栈结构单一个体 typedef struct Stack &#123; int* memory; int stack_top[2]; //双端栈 &#125; STACK, *LPSTACK; //双端栈的方向 enum Direction &#123; left = 0, right = 1 &#125;; 创建栈 LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;memory = (int*)malloc(sizeof(int) * g_MAX); p_stack-&gt;stack_top[0] = -1; ///左边 p_stack-&gt;stack_top[1] = g_MAX; //右边 return p_stack; &#125; 入栈 要清楚是左边还是右边 void Push(LPSTACK p_stack, int data, int direction) &#123; //左边的标记+1等于右边的标记就满了 if (p_stack-&gt;stack_top[0] + 1 == p_stack-&gt;stack_top[1]) &#123; printf(&quot;栈空间已满\\n&quot;); return; &#125; switch (direction) &#123; case left: p_stack-&gt;memory[++p_stack-&gt;stack_top[0]] = data; break; case right: p_stack-&gt;memory[--p_stack-&gt;stack_top[1]] = data; break; &#125; &#125; 出栈 void Pop(LPSTACK p_stack, int* data, int direction) &#123; switch (direction) &#123; case left: if (p_stack-&gt;stack_top[0] == -1) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[0]--]; break; case right: if (p_stack-&gt;stack_top[1] == g_MAX) &#123; return; &#125; *data = p_stack-&gt;memory[p_stack-&gt;stack_top[1]++]; break; &#125; &#125; 链式栈 入栈:表头法插入 出栈:表头法删除 封装栈结构单一个体 typedef struct Node &#123; int data; struct Node* p_next; &#125; NODE, *LPNODE; 描述栈结构 typedef struct &#123; LPNODE p_stack_top; int size; &#125; STACK, *LPSTACK; 创建结点,创建栈 LPNODE CreateNode(int data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; LPSTACK CreateStack() &#123; LPSTACK p_stack = (LPSTACK)malloc(sizeof(STACK)); if (NULL == p_stack) &#123; return NULL; &#125; p_stack-&gt;p_stack_top = NULL; p_stack-&gt;size = 0; return p_stack; &#125; 入栈,出栈,获取栈顶元素 void Push(LPSTACK p_stack, int data) &#123; LPNODE p_new_node = CreateNode(data); //无头链表的表头法插入 p_new_node-&gt;p_next = p_stack-&gt;p_stack_top; p_stack-&gt;p_stack_top = p_new_node; p_stack-&gt;size++; &#125; //获取栈顶元素 int GetTop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; return p_stack-&gt;p_stack_top-&gt;data; &#125; return INT_MAX; &#125; //出栈 void Pop(LPSTACK p_stack) &#123; if (p_stack-&gt;size != 0) &#123; LPNODE p_next_node = p_stack-&gt;p_stack_top-&gt;p_next; //保存下一个结点 free(p_stack-&gt;p_stack_top); p_stack-&gt;p_stack_top = p_next_node; p_stack-&gt;size--; &#125; &#125; 括号匹配算法简单实现 //遇到左面的出栈,遇到右面的出栈 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int Match(char* str) &#123; char stak_memory[1024]; int top = -1; //栈顶标记 int i = 0; while (str[i] != &#39;\\0&#39;) &#123; if (str[i] == &#39;)&#39;) &#123; if (top &gt; -1) &#123; top--; &#125; else &#123; return -1; &#125; &#125; else if (str[i] == &#39;(&#39;) &#123; stak_memory[++top] = str[i]; &#125; i++; &#125; if (top == -1) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; int main(int argc, char** argv) &#123; while (1) &#123; char str[1024] = &quot;&quot;; gets(str); int res = Match(str); if (res == 0) &#123; printf(&quot;匹配\\n&quot;); &#125; else if (res == 1) &#123; printf(&quot;多了左边括号\\n&quot;); &#125; else &#123; printf(&quot;多了右边括号\\n&quot;); &#125; &#125; return 0; &#125; 进制转换 //栈应用:进制转化 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;stack&gt; int main(int argc, char** argv) &#123; int stack[100]; int top = -1; int num = 123; //入栈 while (num != 0) &#123; stack[++top] = num % 2; num /= 2; &#125; //出栈获取栈顶元素 while (top != -1) &#123; printf(&quot;%d&quot;, stack[top--]); &#125; putchar(&#39;\\n&#39;); std::stack&lt;int&gt; my_stack; num = 123; while (num != 0) &#123; my_stack.push(num % 2); num /= 2; &#125; while (!my_stack.empty()) &#123; std::cout &lt;&lt; my_stack.top(); my_stack.pop(); &#125; return 0; &#125; 寻路算法 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //人物坐标属性 struct Position &#123; int row; int col; &#125;; //准备栈 struct Position path_stack[100]; // 100步 int stack_top = -1; //标记 //迷宫属性 int** maze = NULL; int size = 0; //创建二维数组 int** CreateArray(int row, int col) &#123; int** array = (int**)malloc(sizeof(int*) * row); for (int i = 0; i &lt; row; ++i) &#123; array[i] = (int*)malloc(sizeof(int) * col); &#125; return array; &#125; void CreateMaze() &#123; printf(&quot;输入迷宫大小:&quot;); scanf(&quot;%d&quot;, &amp;size); maze = CreateArray(size + 2, size + 2); printf(&quot;输入地图:\\n&quot;); for (int i = 1; i &lt;= size; ++i) &#123; for (int j = 1; j &lt;= size; ++j) &#123; scanf(&quot;%d&quot;, &amp;maze[i][j]); &#125; &#125; //边框 // size + 1是最大下标 //假设用 1 表示墙 for (int i = 0; i &lt;= size + 1; ++i) &#123; maze[0][i] = maze[size + 1][i] = 1; //第一行,最后一行 maze[i][0] = maze[i][size + 1] = 1; //第一列,最后一列 &#125; &#125; //寻路的过程 int FindPath() &#123; //准备位移变换 //用0-3表示四个方向 struct Position offset[4]; //往右走 offset[0].row = 0; offset[0].col = 1; //往下走 offset[1].row = 1; offset[1].col = 0; //左 offset[2].row = 0; offset[2].col = -1; //上 offset[3].row = -1; offset[3].col = 0; //选定入口 struct Position here = &#123;1, 1&#125;; //起始位置 maze[1][1] = 1; //下一个方向 int start_dir = 0; //起始方向设定为右边,顺时针转 int end_dir = 3; //终止方向 //出口&#123; size, size &#125; while (here.row != size || here.col != size) &#123; //记录变化 int row_num; int col_num; //试探 while (start_dir &lt;= end_dir) &#123; //行变化: 原位置 + 偏移值 row_num = here.row + offset[start_dir].row; col_num = here.col + offset[start_dir].col; //当试探出一条路,直接走,走过的要入栈 if (0 == maze[row_num][col_num]) &#123; break; //能走就退出循环 &#125; start_dir++; //不能走试探下一个方向 &#125; //能走: if (start_dir &lt;= end_dir) &#123; //走下一个,上一个位置入栈 path_stack[++stack_top] = here; here.row = row_num; here.col = col_num; //走过的地方堵上 maze[row_num][col_num] = 1; //重新试探 start_dir = 0; &#125; else &#123; //出栈 if (-1 == stack_top) &#123; return 0; &#125; //出栈 struct Position next = path_stack[stack_top--]; //方向的处理:要去的方向要改为原来试探过方向的下一个 //提高效率的操作 if (next.row == here.row) &#123; //把方向变成 1 或者 3 start_dir = 2 + next.col - here.col; &#125; else &#123; // 0 2 start_dir = 3 + next.row - here.row; &#125; here = next; &#125; &#125; return 1; &#125; //打印路径 void PrintPath() &#123; printf(&quot;路径:\\n&quot;); struct Position cur_pos; //栈不为空 while (stack_top != -1) &#123; cur_pos = path_stack[stack_top--]; //栈结构,路径是反向的 printf(&quot;(%d,%d)--&gt;&quot;, cur_pos.row, cur_pos.col); &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char** argv) &#123; CreateMaze(); if (FindPath()) &#123; PrintPath(); &#125; else &#123; printf(&quot;没有找到路径\\n&quot;); &#125; return 0; &#125; /* 测试数据: 输入迷宫大小:6 输入地图: 0 1 0 1 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 1 1 1 1 1 0 0 */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-顺序表(list)","slug":"数据结构-顺序表(list)","date":"2022-06-30T04:46:33.000Z","updated":"2023-02-09T11:44:42.019Z","comments":true,"path":"2022/06/30/数据结构-顺序表(list)/","link":"","permalink":"http://am900skp.github.io/2022/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 顺序表(有序插入结点)与链表大差不大,只是存一下代码,不做详细解释了, 链表如果理解的透彻,顺序表就如探囊取物数组描述: 元素容量: #define MAX 2 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; //序号 struct MM mm_data; &#125;; //顺序表的结构体 typedef struct SqList &#123; int sqlist_size; //顺序表中元素个数 struct Data* p_memory; &#125; SQLIST, *LPSQLIST; 创建顺序表: LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sqlist_size = 0; p_sqlist-&gt;p_memory = (struct Data*)malloc(sizeof(struct Data) * MAX); return p_sqlist; &#125; 开辟更多内存 void ReallocMemory(LPSQLIST p_sqlist, int cur_size, int new_size) &#123; printf(&quot;开辟更多内存\\n&quot;); int max_size = cur_size &gt; new_size ? cur_size : new_size; p_sqlist-&gt;p_memory = (struct Data*)realloc(p_sqlist-&gt;p_memory, sizeof(struct Data) * max_size); &#125; 结点插入顺序表 void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; //元素个数已满,内存重新申请为当前大小的两倍 if (MAX == p_sqlist-&gt;sqlist_size) &#123; ReallocMemory(p_sqlist, MAX, 2 * MAX); &#125; //直接插在表尾 p_sqlist-&gt;p_memory[p_sqlist-&gt;sqlist_size] = new_data; //调整位置 //后面的和前面的相比 for (int i = p_sqlist-&gt;sqlist_size; i &gt;= 0; --i) &#123; if (p_sqlist-&gt;p_memory[i - 1].index &gt; p_sqlist-&gt;p_memory[i].index) &#123; struct Data tmp = p_sqlist-&gt;p_memory[i - 1]; p_sqlist-&gt;p_memory[i - 1] = p_sqlist-&gt;p_memory[i]; p_sqlist-&gt;p_memory[i] = tmp; &#125; else &#123; break; &#125; &#125; //元素个数+1 p_sqlist-&gt;sqlist_size++; &#125; 删除顺序表 因为顺序表本身就有顺序,所以只需挪位置即可,移动元素 void DeleteData(LPSQLIST p_sqlist, int del_index) &#123; //找到删除元素的下标 int del_pos = -1; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; if (p_sqlist-&gt;p_memory[i].index == del_index) &#123; del_pos = i; break; &#125; &#125; //调整数组 if (del_pos == -1) &#123; printf(&quot;未找到指定元素&quot;); return; &#125; else &#123; //数组后面的元素往前移动 for (int i = del_pos; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; p_sqlist-&gt;p_memory[i] = p_sqlist-&gt;p_memory[i + 1]; &#125; //元素个数-1 p_sqlist-&gt;sqlist_size--; &#125; &#125; 遍历顺序表 void PrintSqList(LPSQLIST p_sqlist) &#123; for (int i = 0; i &lt; p_sqlist-&gt;sqlist_size; ++i) &#123; printf(&quot;序号:%d\\t名字:%s\\t年龄:%d\\n&quot;, p_sqlist-&gt;p_memory[i].index, p_sqlist-&gt;p_memory[i].mm_data.name, p_sqlist-&gt;p_memory[i].mm_data.age); &#125; putchar(&#39;\\n&#39;); &#125; 链表描述: 元素数据类型: struct MM &#123; char name[20]; int age; &#125;; struct Data &#123; int index; struct MM mm_data; &#125;; typedef struct Node &#123; struct Data data; struct Node* p_next; &#125; NODE, *LPNODE; typedef struct SqList &#123; int sql_size; LPNODE p_head_node; &#125; SQLIST, *LPSQLIST; LPNODE CreateList() &#123; LPNODE p_head_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_head_node) &#123; return NULL; &#125; p_head_node-&gt;p_next = NULL; return p_head_node; &#125; LPNODE CreateNode(struct Data new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //创建顺序表 LPSQLIST CreateSqList() &#123; LPSQLIST p_sqlist = (LPSQLIST)malloc(sizeof(SQLIST)); if (NULL == p_sqlist) &#123; return NULL; &#125; p_sqlist-&gt;sql_size = 0; p_sqlist-&gt;p_head_node = CreateList(); return p_sqlist; &#125; void PrintSqList(LPSQLIST p_sqlist) &#123; LPNODE p_move = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d\\t姓名:%s\\t年龄:%d\\n&quot;, p_move-&gt;data.index, p_move-&gt;data.mm_data.name, p_move-&gt;data.mm_data.age); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; void InsertData(LPSQLIST p_sqlist, struct Data new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //找到指定位置 LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index &lt; new_data.index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pre_node-&gt;p_next; &#125; // if (NULL == p_pos_node) &#123; // p_pre_node-&gt;p_next = p_new_node; // &#125; else &#123; // p_pre_node-&gt;p_next = p_new_node; // p_new_node-&gt;p_next = p_pos_node; // &#125; p_pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = p_pos_node; p_sqlist-&gt;sql_size++; &#125; void DeleteNode(LPSQLIST p_sqlist, int index) &#123; LPNODE p_pre_node = p_sqlist-&gt;p_head_node; LPNODE p_pos_node = p_sqlist-&gt;p_head_node-&gt;p_next; while (NULL != p_pos_node &amp;&amp; p_pos_node-&gt;data.index != index) &#123; p_pre_node = p_pos_node; p_pos_node = p_pos_node-&gt;p_next; &#125; if (NULL == p_pos_node) &#123; printf(&quot;未找到数据&quot;); return; &#125; else &#123; p_pre_node-&gt;p_next = p_pos_node-&gt;p_next; free(p_pos_node); p_pos_node = NULL; p_sqlist-&gt;sql_size--; &#125; &#125; 测试数据: LPSQLIST p_sqlist = CreateSqList(); struct Data array[4] = &#123;3, &quot;小红&quot;, 18, 1, &quot;小明&quot;, 14, 0, &quot;雨墨&quot;, 18, 2, &quot;小asd&quot;, 4&#125;; for (int i = 0; i &lt; 4; ++i) &#123; InsertData(p_sqlist, array[i]); &#125; PrintSqList(p_sqlist); printf(&quot;删除序号为3的结点:\\n&quot;); DeleteNode(p_sqlist, 3); PrintSqList(p_sqlist);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-合并,反转,有序链表(list)","slug":"数据结构-合并,反转,有序链表(list)","date":"2022-06-29T02:40:49.000Z","updated":"2023-02-09T11:44:46.482Z","comments":true,"path":"2022/06/29/数据结构-合并,反转,有序链表(list)/","link":"","permalink":"http://am900skp.github.io/2022/06/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%90%88%E5%B9%B6,%E5%8F%8D%E8%BD%AC,%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 注意:阅读本篇博客前请先学会”基础单链表”找两个链表中的相同元素组成第三个链表如何合并: 遍历两个链表,找到相同元素 调用一种插入方式即可 插入方式 void InsertNode(struct Node* p_list, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); p_new_node-&gt;p_next = p_list-&gt;p_next; p_list-&gt;p_next = p_new_node; &#125; 取交集,将两个链表中的相同元素合并为第三个链表 void Intersection(struct Node* p_list_one, struct Node* p_list_two, struct Node* p_list_three) &#123; for (struct Node* p_first = p_list_one-&gt;p_next; NULL != p_first; p_first = p_first-&gt;p_next) &#123; for (struct Node* p_second = p_list_two-&gt;p_next; NULL != p_second; p_second = p_second-&gt;p_next) &#123; if (p_first-&gt;data == p_second-&gt;data) &#123; InsertNode(p_list_three, p_second-&gt;data); &#125; &#125; &#125; &#125; 反转链表 第一种方法: 创建一个临时链表 遍历当前链表,将结点逆序插入到临时链表中 释放原有链表内存 指向新链表 代码如下: //释放链表 void FreeList(struct Node** p_list) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_next_node = NULL; while (NULL != *p_list) &#123; p_next_node = (*p_list)-&gt;p_next; free(*p_list); *p_list = p_next_node; &#125; &#125; //反转链表第一种方法 void ReverseFirstWay(struct Node** p_list) &#123; struct Node* p_tmp_list = CreateList(); struct Node* p_move = (*p_list)-&gt;p_next; while (NULL != p_move) &#123; InsertNode(p_tmp_list, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; //释放原有的内存 FreeList(p_list); *p_list = p_tmp_list; //指向新的链表 &#125; 第二种方法(节省空间) 思路: 将每一个结点的p_next指针反转 第一个结点指向最后一个结点 实现: 第一个结点的前驱结点用空表示(p_pre_node &#x3D;&#x3D; NULL) 第一个结点的p_next指针指向前驱结点,而前驱结点是NULL,导致下一个结点就找不到了 所以在更改当前结点的指向之前应当先保存下一个结点(p_next_node &#x3D; p_cur_node-&gt;p_next;) 后面的结点也要做以上相同的事情 前驱结点变成当前结点 当前结点变成下一个结点 表头指向最后一个结点 实现代码如下: void ReverseSecondWay(struct Node** p_list) &#123; struct Node* p_pre_node = NULL; //前驱结点 struct Node* p_cur_node = (*p_list)-&gt;p_next; //当前结点 struct Node* p_next_node = (*p_list)-&gt;p_next; //当前结点的下一个结点 while (NULL != p_cur_node) &#123; p_next_node = p_cur_node-&gt;p_next; //保存下一个结点 p_cur_node-&gt;p_next = p_pre_node; //当前结点的p_next指针指向前驱结点 p_pre_node = p_cur_node; //前驱结点变成当前结点 p_cur_node = p_next_node; //当前结点变成下一个结点 &#125; (*p_list)-&gt;p_next = p_pre_node; //表头指向最后一个结点 &#125; 有序链表 再插入结点时让链表有序,这个比较简单,看一眼就可以了 /* @author: KaiPeng_Sun @Time: 2022年7月11日18:22:13 @brief: 有序链表 @message: 代码的上一行为所写注释 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-双向链表(list)","slug":"数据结构-双向链表(list)","date":"2022-06-28T02:34:06.000Z","updated":"2023-02-09T11:44:42.126Z","comments":true,"path":"2022/06/28/数据结构-双向链表(list)/","link":"","permalink":"http://am900skp.github.io/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 双向链表本篇博客中变量采用如下命名方式://结点类型,单一个体 typedef struct Node &#123; int data; struct Node* p_left; //指向左面的结点 struct Node* p_right; //指向右面的结点 &#125; NODE, *LPNODE; //链表类型 typedef struct List &#123; LPNODE p_head_node; //头结点 LPNODE p_tail_node; //尾结点 int size; //当前链表中结点个数 &#125; LIST, *LPLIST; 熟悉的套路:创建结点,创建链表//创建结点 LPNODE CreateNode(int new_data) &#123; LPNODE p_new_node = (LPNODE)malloc(sizeof(NODE)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_left = NULL; p_new_node-&gt;p_right = NULL; return p_new_node; &#125; //创建链表 LPLIST CreateList() &#123; LPLIST p_new_list = (LPLIST)malloc(sizeof(LIST)); if (NULL == p_new_list) &#123; return NULL; &#125; p_new_list-&gt;size = 0; p_new_list-&gt;p_head_node = NULL; p_new_list-&gt;p_tail_node = NULL; return p_new_list; &#125; 表头法插入,在有头结点前插入新节点 先判断链表中结点个数是否为空,为空则直接将头&#x2F;尾结点赋为新节点 链表不为空: 新节点的新节点的右指针指向头结点 头结点的左指针指向新结点 头结点变为新结点 结点个数+1 实现代码如下: void InsertNewNodeByHead(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; //链表为空 p_list-&gt;p_tail_node = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_right = p_list-&gt;p_head_node; p_list-&gt;p_head_node-&gt;p_left = p_new_node; // p_list-&gt;p_head_node = p_new_node; &#125; p_list-&gt;p_head_node = p_new_node; //头结点变成新结点 p_list-&gt;size++; &#125; 表尾法插入,在尾结点后插入新结点 和表头法插入大同小异 void InsertNewNodeByTail(int new_data, LPLIST p_list) &#123; LPNODE p_new_node = CreateNode(new_data); if (p_list-&gt;size == 0) &#123; p_list-&gt;p_head_node = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; else &#123; p_new_node-&gt;p_left = p_list-&gt;p_tail_node; p_list-&gt;p_tail_node-&gt;p_right = p_new_node; // p_list-&gt;p_tail_node = p_new_node; &#125; p_list-&gt;p_tail_node = p_new_node; p_list-&gt;size++; &#125; 指定位置插入 和单链表的指定位置插入类似 也是采用双结点遍历整个链表,因为两个结点能确定另一个结点 插入的方式: 前驱结点的右指针指向新结点 新结点的左指针指向前驱结点 新结点的右指针指向当前结点 当前结点的左指针指向新结点 结点个数+1 void InsertByPosData(LPLIST p_list, int new_data, int pos_data) &#123; LPNODE pos_front = NULL; LPNODE pos_node = p_list-&gt;p_head_node; //遍历寻找指定结点 while (NULL != pos_node &amp;&amp; pos_node-&gt;data != pos_data) &#123; pos_front = pos_node; pos_node = pos_front-&gt;p_right; &#125; if (NULL == pos_node) &#123; printf(&quot;未找到指定结点&quot;); return; &#125; else &#123; //表头法插入 if (NULL == pos_front) &#123; InsertNewNodeByHead(new_data, p_list); &#125; else &#123; //指定结点插入 LPNODE p_new_node = CreateNode(new_data); pos_front-&gt;p_right = p_new_node; p_new_node-&gt;p_left = pos_front; p_new_node-&gt;p_right = pos_node; pos_node-&gt;p_left = p_new_node; p_list-&gt;size++; &#125; &#125; &#125; 遍历双向链表(看一眼就行了,和单链表遍历一个道理) 顺序遍历 void OrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_head_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPLIST p_list) &#123; LPNODE p_move = p_list-&gt;p_tail_node; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125; 双向循环链表 这里我就写了一个表尾法插入,有时间在写别的,其实都大同小异 注意:不需要找表尾,表尾就是默认头结点的p_left指针所指向的位置 也就是说,我们用头结点来描述尾结点 如何插入: 头结点的左指针的结点的右指针指向新结点 新结点的左指针指向头结点的左指针指向的结点 新结点的右指针指向头结点 头结点的左指针指向新结点 void InsertNewNodeByTail(LPNODE p_head_node, int new_data) &#123; LPNODE p_new_node = CreateNode(new_data); //换了一种方式表示表尾,用表头的左指针表示表尾 // p_head_node-&gt;p_left-&gt;p_right = p_new_node //也就是说表尾-&gt;p_right = p_new_node; p_head_node-&gt;p_left-&gt;p_right = p_new_node; p_new_node-&gt;p_left = p_head_node-&gt;p_left; // p_new_node-&gt;p_left = p_head_node-&gt;p_left // p_new_node-&gt;p_left等价于表尾 p_new_node-&gt;p_right = p_head_node; p_head_node-&gt;p_left = p_new_node; &#125; 遍历双向循环链表 因为是环形的,所以不能用老规矩(NULL结束遍历) 只需要遍历一圈,再走到头结点结束遍历即可 顺序遍历 void OrderPrintList(LPNODE p_head_node) &#123; //因为是环形的,所以不能用老规矩(NULL结束遍历) //只需要遍历一圈,再走到头结点结束遍历即可 LPNODE p_move = p_head_node-&gt;p_right; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_right; &#125; putchar(&#39;\\n&#39;); &#125; 逆序遍历 void ReverseOrderPrintList(LPNODE p_head_node) &#123; LPNODE p_move = p_head_node-&gt;p_left; while (p_head_node != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_left; &#125; putchar(&#39;\\n&#39;); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-基础单链表(list)","slug":"数据结构-基础单链表(list)","date":"2022-06-27T12:54:15.000Z","updated":"2023-02-09T11:44:45.265Z","comments":true,"path":"2022/06/27/数据结构-基础单链表(list)/","link":"","permalink":"http://am900skp.github.io/2022/06/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E5%8D%95%E9%93%BE%E8%A1%A8(list)/","excerpt":"","text":"参考书籍: 数据结构与算法分析(黑皮书) 作者:Mark Allen Weiss 博客中所有关于链表的代码命名方式如下//结点类型 struct Node &#123; int data; struct Node* p_next; //指向下一个结点的结构体指针 &#125;; int new_data; //插入的新数据 struct Node* p_pre_node; //前驱结点 struct Node* p_cur_node; //当前结点 struct Node* p_new_node; //新节点 struct Node* p_move; //移动结构体指针,用于遍历链表 struct Node* p_list; //链表 struct Node** p_list; //链表 初识链表: //创建三个结点 struct Node node1 = &#123;1, NULL&#125;; struct Node node2 = &#123;2, NULL&#125;; struct Node node3 = &#123;3, NULL&#125;; //将结点连接在一起,形成链表 node1.p_next = &amp;node2; node2.p_next = &amp;node3; //遍历链表 struct Node* p_move = &amp;node1; printf(&quot;第一个节点数据:%d\\n&quot;, p_move-&gt;data); printf(&quot;第二个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;data); printf(&quot;第三个节点数据:%d\\n&quot;, p_move-&gt;p_next-&gt;p_next-&gt;data); //上面不太方便，用循环来做 while (p_move != NULL) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; 链式结构基础操作 创建表头 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct data &#123; int index; //构建序号 int data; //数据 &#125;; struct Node &#123; struct data my_data; struct Node* p_next; &#125;; //创建有头链表 struct Node* CreateList() &#123; struct Node* p_list = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_list) &#123; return NULL; &#125; //初始化头结点 p_list-&gt;p_next = NULL; return p_list; &#125; //创建结点 struct Node* CreateNewNode(struct data my_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化结点数据 p_new_node-&gt;my_data = my_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; void InsertOrderList(struct Node* p_list, struct data my_data) &#123; struct Node* p_new_node = CreateNewNode(my_data); struct Node* pre_node = p_list; //前驱结点 struct Node* cur_node = p_list-&gt;p_next; //当前结点 //升序 while (NULL != cur_node &amp;&amp; cur_node-&gt;my_data.index &lt; my_data.index) &#123; pre_node = cur_node; cur_node = pre_node-&gt;p_next; &#125; if (NULL == cur_node) &#123; pre_node-&gt;p_next = p_new_node; &#125; else &#123; pre_node-&gt;p_next = p_new_node; p_new_node-&gt;p_next = cur_node; &#125; &#125; void PrintList(struct Node* p_list) &#123; struct Node* p_move = p_list-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;序号:%d,数据:%d\\n&quot;, p_move-&gt;my_data.index, p_move-&gt;my_data.data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; int main(int argc, char* argv[]) &#123; //五对数据,两个两个是一对 struct data array[5] = &#123;2, 1, 5, 3, 6, 8, 7, 10, 11, 0&#125;; struct Node* p_list = CreateList(); for (int i = 0; i &lt; 5; ++i) &#123; InsertOrderList(p_list, array[i]); &#125; PrintList(p_list); return 0; &#125; 创建新节点 有头和无头的区别就在于头结点的data有没有存放数据罢了 //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(int new_data) &#123; struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == new_node) &#123; return NULL; &#125; //初始化新结点 new_node-&gt;data = new_data; new_node-&gt;p_next = NULL; return new_node; &#125; 遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move) &#123; printf(&quot;%d &quot;, p_move-&gt;data); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; 在头结点的前驱位置(头结点前面)插入新结点 新结点的p_next指针指向头结点 新结果点赋值给头结点 void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; 在头结点与下一个结点之间插入新结点 新节点的p_next指针指向头结点的p_next指针(换句话说就是新结点的p_next指针指向头结点的下一个结点) 头结点的p_next指针指向新结点 注意:这种插入方式会导致插入结点的顺序与遍历结点的顺序相反 void InsertNewNodeByHead(struct Node* p_head_node, int new_data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(new_data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; 在尾结点后插入新结点 遍历找到尾结点 尾结点的p_next指针指向新结点 void InsertNewNodeByTail(struct Node* p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNewNode(new_data); struct Node* p_tail_node = p_head_node; //找到尾结点 while (NULL != p_tail_node-&gt;p_next) &#123; p_tail_node = p_tail_node-&gt;p_next; &#125; //表尾法插入 p_tail_node-&gt;p_next = p_new_node; &#125; 指定位置插入(以数据作为参照),数据指data 遍历找到data(这里以第一次出现data终止遍历) 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByDataValue(struct Node* p_head_node, int data_value, int new_data) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; // 注意:条件不能交换(短路现象) // p_p_cur_node == NULL,NULL-&gt;data // 判断是否为所寻找的数据的前提是p_p_cur_node!=NULL while (p_cur_node != NULL &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_p_pre_node = p_p_pre_node-&gt;p_next; // p_p_cur_node = p_p_cur_node-&gt;p_next; // 下面的写法更能够体现相邻的特色 p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; //分析结果 if (NULL == p_cur_node) &#123; printf(&quot;没有找到指定结点,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 指定位置插入(以第几个结点作为参照) 注意: 若传入函数的下标为4,则是在3的位置插入 遍历找到指定位置 前驱结点的p_next指针指向新结点 新结点的p_next指针指向当前结点 void InsertByNodeIndex(struct Node* p_head_node, int node_index, int new_data) &#123; if (node_index &lt; 0) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); return; &#125; //因为是不存在第0个元素的 int count = 1; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != NULL &amp;&amp; count &lt; node_index) &#123; p_pre_node = p_cur_node; p_cur_node = p_cur_node-&gt;p_next; ++count; &#125; if (NULL == p_cur_node) &#123; printf(&quot;序号有问题,无法插入\\n&quot;); &#125; else &#123; struct Node* new_node = CreateNewNode(new_data); p_pre_node-&gt;p_next = new_node; new_node-&gt;p_next = p_cur_node; &#125; &#125; 删除头结点(实质是删除头结点的下一个结点) 头结点的p_next指针指向下一个结点的p_next指针 释放结点内存 结点置为空 void DeleteByHead(struct Node* p_head_node) &#123; struct Node* p_next_node = p_head_node-&gt;p_next; //防御性编程 if (NULL == p_head_node || NULL == p_next_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; else &#123; p_head_node-&gt;p_next = p_next_node-&gt;p_next; free(p_next_node); p_next_node = NULL; &#125; &#125; 删除尾结点 遍历找到尾结点 前驱结点的p_next指向空 释放尾结点内存 结点置为空 void DeleteByTail(struct Node* p_head_node) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_tail_node = p_head_node-&gt;p_next; if (NULL == p_head_node || p_tail_node == NULL) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_tail_node-&gt;p_next) &#123; p_pre_node = p_tail_node; p_tail_node = p_pre_node-&gt;p_next; &#125; //将尾结点置为空 p_pre_node-&gt;p_next = NULL; free(p_tail_node); p_tail_node = NULL; &#125; 通过data删除指定位置结点 遍历找到data 前驱结点的p_next指针指向当前结点的p_next指针 释放当前结点 结点置为空 void DeleteByNodeIndex(struct Node* p_head_node, int data_value) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; 寻找结点 遍历链表 返回struct Node* 类型结点 struct Node* SearchNode(struct Node* p_head_node, int data_value) &#123; struct Node* p_move = p_head_node-&gt;p_next; while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; 删除所有相同的结点 void DeleteAllSameNode(struct Node* p_head_node, int data_value) &#123; while (NULL != SearchNode(p_head_node, data_value)) &#123; DeleteByNodeIndex(p_head_node, data_value); &#125; &#125; 销毁链表 传入二级指针 *p_head_node就代表一个结点 结点置为空 void DestoryList(struct Node** p_head_node) &#123; while (NULL != (*p_head_node)-&gt;p_next) &#123; DeleteByHead(*p_head_node); &#125; free(*p_head_node); *p_head_node = NULL; &#125; 没经过优化的版本(C风格)#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define IS_LIST 0 struct Node &#123; int data; struct Node* p_next; &#125;; #if IS_LIST struct List &#123; struct Node* p_root; &#125;; #endif #if IS_LIST void InitList(struct List* p_list); #endif struct Node* CreateNode(int new_data); #if IS_LIST void AppendNode(struct List* p_list, int new_data); #else void AppendNode(struct Node** p_head_node, int new_data); #endif #if IS_LIST void PrintList(struct List* p_list); #else void PrintList(struct Node* p_head); #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data); #endif #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data); #else void InsertPosNode(struct Node** head, int pos, int new_data); #endif void DeletePosNode(struct Node** p_head, int pos); void DeleteHeadNode(struct Node** p_head); int main(int argc, char** argv) &#123; #if IS_LIST struct List list; InitList(&amp;list); for (int i = 0; i &lt; 10; ++i) &#123; AppendNode(&amp;list, i); &#125; PrintList(&amp;list); #else struct Node* p_head = NULL; for (int i = 0; i &lt; 10; ++i) &#123; InsertNewNodeByHead(&amp;p_head, i); PrintList(p_head); &#125; InsertPosNode(&amp;p_head, 2, 666); PrintList(p_head); #endif return 0; &#125; #if IS_LIST void InitList(struct List* p_list) &#123; p_list-&gt;p_root = NULL; &#125; #endif struct Node* CreateNode(int new_data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; #if IS_LIST void AppendNode(struct List* p_list, int new_data) &#123; if (NULL == p_list) &#123; return; &#125; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (p_list-&gt;p_root) &#123; struct Node* p_tmp = p_list-&gt;p_root; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; p_list-&gt;p_root = p_new_node; &#125; &#125; #else void AppendNode(struct Node** p_head_node, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); if (NULL == p_new_node) &#123; return; &#125; if (*p_head_node) &#123; struct Node* p_tmp = *p_head_node; while (NULL != p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new_node; &#125; else &#123; *p_head_node = p_new_node; &#125; &#125; #endif #if IS_LIST void PrintList(struct List* p_list) &#123; struct Node* p_tmp = p_list-&gt;p_root; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #else void PrintList(struct Node* p_head) &#123; struct Node* p_tmp = p_head; printf(&quot;list: &quot;); while (p_tmp) &#123; printf(&quot;%d &quot;, p_tmp-&gt;data); p_tmp = p_tmp-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; #endif #if IS_LIST #else void InsertNewNodeByHead(struct Node** p_head, int new_data) &#123; struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = *p_head; *p_head = p_new_node; &#125; #endif //从head链表中找到pos结点并返回,找不到返回NULL struct Node* FindPos(struct Node* p_head_node, int pos) &#123; if (NULL == p_head_node) &#123; return NULL; &#125; struct Node* p_tmp = p_head_node; for (int i = 0; i &lt; pos; ++i) &#123; if (NULL == p_tmp) &#123; return NULL; &#125; p_tmp = p_tmp-&gt;p_next; &#125; return p_tmp; &#125; #if IS_LIST //中间插入 void InsertPosNode(struct List* p_list, int pos, int new_data) &#123;&#125; #else void InsertPosNode(struct Node** head, int pos, int new_data) &#123; if (NULL == *head) &#123; return; &#125; if (NULL == *head || 0 == pos) &#123; AppendNode(head, new_data); &#125; //这里我写的是以数组下标为基准插入,所以pos - 1 struct Node* p_tmp = FindPos(*head, pos - 1); struct Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_tmp-&gt;p_next; p_tmp-&gt;p_next = p_new_node; &#125; #endif //删除链表中第一个节点 void DeleteHeadNode(struct Node** p_head) &#123; if (NULL == p_head) &#123; return; &#125; //临时存储要删的节点 struct Node* p_del = *p_head; //*head 的下一个节点要成为新的头节点 *p_head = (*p_head)-&gt;p_next; //释放内存 free(p_del); &#125; //删除链表中第pos个节点 void DeletePosNode(struct Node** p_head, int pos) &#123; if (NULL == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(p_head); return; &#125; //临时存储pos节点地址 struct Node* p_del = FindPos(*p_head, pos); if (NULL == p_del) &#123; return; &#125; //先找到pos-1节点 struct Node* p_del_prev = FindPos(*p_head, pos - 1); if (NULL == p_del_prev) &#123; return; &#125; // pos-1节点的next指针指向pos的下一个节点 p_del_prev-&gt;p_next = p_del-&gt;p_next; //释放pos节点内存 free(p_del); &#125; 没经过优化的版本(C++风格)#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_next = nullptr; &#125; &#125;; Node* p_head; public: MyList() &#123; p_head = NULL; &#125; void AppendNode(const T&amp; new_data); //尾插 void AddNode(const T&amp; new_data); //头插 void InsertNode(int pos, int new_data); //中间插 void Traver(); //遍历 void DeletePosNode(int pos); //删除特定结点 void DeleteHeadNode(); //删除头结点 private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); Node* p_tmp = p_head; if (p_tmp) &#123; while (p_tmp-&gt;p_next) &#123; p_tmp = p_tmp-&gt;p_next; &#125; p_tmp-&gt;p_next = p_new; &#125; else &#123; p_head = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::AddNode(const T&amp; new_data) &#123; Node* p_new = new Node(new_data); p_new-&gt;p_next = p_head; p_head = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::InsertNode(int pos, int new_data) &#123; if (pos &lt; 0) &#123; return; &#125; if (nullptr == p_head || 0 == pos) &#123; AddNode(new_data); &#125; Node* p_new = new Node(new_data); Node* p_prev = _FindPos(pos); p_new-&gt;p_next = p_prev-&gt;p_next; p_prev-&gt;p_next = p_new; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list: &quot;; while (p_tmp) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; &#39;\\n&#39;; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeletePosNode(int pos) &#123; if (nullptr == p_head || pos &lt; 0) &#123; return; &#125; if (0 == pos) &#123; DeleteHeadNode(); return; &#125; Node* p_del_prev = _FindPos(pos - 1); if (nullptr == p_del_prev) &#123; return; &#125; Node* p_del = _FindPos(pos); if (nullptr == p_del) &#123; return; &#125; p_del_prev-&gt;p_next = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::DeleteHeadNode() &#123; if (nullptr == p_head) &#123; return; &#125; Node* p_del = p_head; p_head = p_del-&gt;p_next; delete p_del; &#125; template &lt;class T&gt; typename MyList&lt;T&gt;::Node* MyList&lt;T&gt;::_FindPos(int pos) &#123; Node* p_pos = p_head; for (int i = 0; i &lt; pos; ++i) &#123; if (nullptr == p_pos) &#123; return nullptr; &#125; else &#123; p_pos = p_pos-&gt;p_next; &#125; &#125; return p_pos; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; list.InsertNode(5, 666); list.Traver(); list.DeleteHeadNode(); list.Traver(); list.DeletePosNode(5); list.Traver(); return 0; &#125; 双向循环链表(C++风格)具体请查看”双向链表”这篇博客#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template &lt;class T&gt; class MyList &#123; private: struct Node &#123; T data; Node* p_next; //指向下一个结点 Node* p_prev; //指向前一个结点 Node() &#123;&#125; Node(const T&amp; data) &#123; this-&gt;data = data; p_prev = p_next = nullptr; &#125; &#125;; Node* p_head; Node* p_tail; public: MyList() &#123; p_tail = p_head = NULL; &#125; void AppendNode(const T&amp; new_data); void Traver(); private: Node* _FindPos(int pos); &#125;; template &lt;class T&gt; void MyList&lt;T&gt;::AppendNode(const T&amp; new_data) &#123; // 1 创建新结点 Node* p_new = new Node(new_data); if (p_tail) &#123; //不是空链表 //新结点连接到尾结点后 p_tail-&gt;p_next = p_new; p_new-&gt;p_prev = p_tail; //更新p_tail p_tail = p_new; //维持循环双链表结构 p_tail-&gt;p_next = p_head; p_head-&gt;p_prev = p_tail; &#125; else &#123; //空链表 p_head = p_tail = p_new; &#125; &#125; template &lt;class T&gt; void MyList&lt;T&gt;::Traver() &#123; Node* p_tmp = p_head; cout &lt;&lt; &quot;list:&quot;; if (p_head == NULL) &#123; cout &lt;&lt; &quot;链表为空&quot; &lt;&lt; endl; return; &#125; if (p_head == p_tail) &#123; cout &lt;&lt; p_head-&gt;data &lt;&lt; endl; return; &#125; while (p_tmp != p_tail) &#123; cout &lt;&lt; p_tmp-&gt;data &lt;&lt; &quot; &quot;; p_tmp = p_tmp-&gt;p_next; &#125; cout &lt;&lt; p_tail-&gt;data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MyList&lt;int&gt; list; for (int i = 0; i &lt; 10; ++i) &#123; list.AppendNode(i); list.Traver(); &#125; return 0; &#125; 基础链式结构的应用#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //美女类型 struct MM &#123; char name[20]; int age; int num; &#125;; //结点类型 struct Node &#123; // int data; struct MM data; struct Node* p_next; &#125;; //创建表头 struct Node* CreateHeadNode(); //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data); //遍历链表 void PrintList(struct Node* p_head_node); //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data); //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name); //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name); //菜单 void Menu(); //录入信息 void InsertMMData(struct Node* p_head_node); //查找信息 void SearchMMData(struct Node* p_head_node); //修改信息 void ModifyMMData(struct Node* p_head_node); //删除信息 void DeleteMMData(struct Node* p_head_node); //冒泡排序 void BubbleSort(struct Node* p_head_node); //选项 void KeyDown(struct Node* p_list); int main(int argc, char* argv[]) &#123; struct Node* p_list = CreateHeadNode(); while (1) &#123; Menu(); KeyDown(p_list); system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; return 0; &#125; //创建表头 struct Node* CreateHeadNode() &#123; struct Node* p_head_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_head_node) &#123; return NULL; &#125; //这里我写的是有头链表,表头不存储数据,所以不需要将data进行初始化 p_head_node-&gt;p_next = NULL; return p_head_node; &#125; //创建新结点,每次需要插入数据时就调用该函数,将int类型的数据初始化为结点类型 struct Node* CreateNewNode(struct MM data) &#123; struct Node* p_new_node = (struct Node*)malloc(sizeof(struct Node)); if (NULL == p_new_node) &#123; return NULL; &#125; //初始化新结点 p_new_node-&gt;data = data; p_new_node-&gt;p_next = NULL; return p_new_node; &#125; //遍历链表 void PrintList(struct Node* p_head_node) &#123; //定义移动指针,因为头结点不存储数据,所以直接指向头结点的下一个结点 struct Node* p_move = p_head_node-&gt;p_next; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); while (NULL != p_move) &#123; printf(&quot;%s\\t%d\\t%d\\n&quot;, p_move-&gt;data.name, p_move-&gt;data.age, p_move-&gt;data.num); p_move = p_move-&gt;p_next; &#125; putchar(&#39;\\n&#39;); &#125; //表头法插入 void InsertNewNodeByHead(struct Node* p_head_node, struct MM data) &#123; //调用生成新结点函数 struct Node* p_new_node = CreateNewNode(data); //表头法插入 p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; &#125; //通过data删除指定位置结点 void DeleteByName(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_pre_node = p_head_node; struct Node* p_cur_node = p_head_node-&gt;p_next; if (NULL == p_head_node || NULL == p_cur_node) &#123; printf(&quot;链表为空,无法删除\\n&quot;); return; &#125; // while (NULL != p_cur_node &amp;&amp; p_cur_node-&gt;data != data_value) &#123; // p_pre_node = p_cur_node; // p_cur_node = p_pre_node-&gt;p_next; // &#125; //相同返回0, while (NULL != p_cur_node &amp;&amp; strcmp(p_cur_node-&gt;data.name, p_mm_name)) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (NULL == p_cur_node) &#123; printf(&quot;未找到指定结点\\n&quot;); &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; free(p_cur_node); p_cur_node = NULL; &#125; &#125; //寻找相同的结点 struct Node* SearchNode(struct Node* p_head_node, const char* p_mm_name) &#123; struct Node* p_move = p_head_node-&gt;p_next; // while (NULL != p_move &amp;&amp; p_move-&gt;data != data_value) &#123; // p_move = p_move-&gt;p_next; // &#125; while (NULL != p_move &amp;&amp; strcmp(p_move-&gt;data.name, p_mm_name)) &#123; p_move = p_move-&gt;p_next; &#125; return p_move; &#125; void Menu() &#123; printf(&quot;-----------【MM管理系统】-------------\\n&quot;); printf(&quot;\\t\\t0.退出功能\\n&quot;); printf(&quot;\\t\\t1.录入信息\\n&quot;); printf(&quot;\\t\\t2.浏览信息\\n&quot;); printf(&quot;\\t\\t3.查找信息\\n&quot;); printf(&quot;\\t\\t4.修改信息\\n&quot;); printf(&quot;\\t\\t5.删除信息\\n&quot;); printf(&quot;\\t\\t6.排序显示\\n&quot;); printf(&quot;-------------------------------------\\n&quot;); printf(&quot;请输入(0-6):&quot;); &#125; //录入美女信息 void InsertMMData(struct Node* p_head_node) &#123; struct MM mm; printf(&quot;输入美女信息:&quot;); scanf(&quot;%s%d%d&quot;, mm.name, &amp;mm.age, &amp;mm.num); InsertNewNodeByHead(p_head_node, mm); &#125; void SearchMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入查找美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;姓名\\t年龄\\t编号\\n&quot;); printf(&quot;%s\\t%d\\t%d\\n&quot;, p_result-&gt;data.name, p_result-&gt;data.age, p_result-&gt;data.num); &#125; &#125; void ModifyMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入修改美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); struct Node* p_result = SearchNode(p_head_node, mm_name); if (NULL == p_result) &#123; printf(&quot;未找到指定位置\\n&quot;); &#125; else &#123; printf(&quot;重新输入美女的信息:&quot;); scanf(&quot;%s%d%d&quot;, p_result-&gt;data.name, &amp;p_result-&gt;data.age, &amp;p_result-&gt;data.num); printf(&quot;修改成功\\n&quot;); &#125; &#125; void DeleteMMData(struct Node* p_head_node) &#123; char mm_name[20]; printf(&quot;请输入删除美女的姓名:&quot;); scanf(&quot;%s&quot;, mm_name); DeleteByName(p_head_node, mm_name); &#125; void BubbleSort(struct Node* p_head_node) &#123; for (struct Node* p = p_head_node-&gt;p_next; p != NULL; p = p-&gt;p_next) &#123; for (struct Node* q = p_head_node-&gt;p_next; q != NULL; q = q-&gt;p_next) &#123; //按照年龄方式升序 if (q-&gt;p_next != NULL &amp;&amp; q-&gt;data.age &gt; q-&gt;p_next-&gt;data.age) &#123; struct MM tmp = q-&gt;data; q-&gt;data = q-&gt;p_next-&gt;data; q-&gt;p_next-&gt;data = tmp; &#125; &#125; &#125; PrintList(p_head_node); &#125; void KeyDown(struct Node* p_list) &#123; struct MM mm; int options = 0; scanf(&quot;%d&quot;, &amp;options); switch (options) &#123; case 0: printf(&quot;----退出----\\n&quot;); exit(0); break; case 1: printf(&quot;----录入----\\n&quot;); InsertMMData(p_list); break; case 2: printf(&quot;----浏览----\\n&quot;); PrintList(p_list); break; case 3: printf(&quot;----查找----\\n&quot;); SearchMMData(p_list); break; case 4: printf(&quot;----修改----\\n&quot;); ModifyMMData(p_list); break; case 5: printf(&quot;----删除----\\n&quot;); DeleteMMData(p_list); break; case 6: printf(&quot;-----排序----\\n&quot;); BubbleSort(p_list); break; default: printf(&quot;----error----\\n&quot;); break; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++可变参数模板","slug":"C++可变参数模板","date":"2022-06-21T10:15:05.000Z","updated":"2023-02-19T08:04:10.887Z","comments":true,"path":"2022/06/21/C++可变参数模板/","link":"","permalink":"http://am900skp.github.io/2022/06/21/C++%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++折叠参数可变参数函数模板#include &lt;initializer_list&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;tuple&gt; using namespace std; /* 参数包： class ...Args 参数包展开： 1.递归方式展开参数包 2.采用列表的方式展开参数包 */ //递归终止条件 template &lt;class _Ty&gt; void print(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty, class... Args&gt; void print(_Ty head, Args... args) //&#123;1,&quot;string&quot;,1.3&#125; &#123; cout &lt;&lt; head &lt;&lt; &quot; &quot;; //头部 print(args...); //参数包中的参数 &#123;&quot;string&quot;,1.3&#125; // args... 抽一个参数出来充当head //当参数包中只有一个参数时候，不满足调用自身的条件 &#125; //采用列表的方式 template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; template &lt;class... Args&gt; void printArgs(Args... args) &#123; initializer_list&lt;int&gt;&#123;(printData(args), 0)...&#125;; cout &lt;&lt; endl; &#125; // printf函数 void my_printf(const char* str) &#123; while (*str) &#123; cout &lt;&lt; *str &lt;&lt; endl; &#125; &#125; template &lt;class _Ty, class... Args&gt; void my_printf(const char* str, _Ty value, Args... args) &#123; //%d %c while (*str) &#123; if (*str == &#39;%&#39; &amp;&amp; (*++str) != &#39;%&#39;) &#123; //格式控制字符时候，参数包解析 cout &lt;&lt; value; my_printf(*str ? ++str : str, args...); return; &#125; cout &lt;&lt; *str++; //原样字符，直接打印 &#125; &#125; int main(int argc, char** argv) &#123; print(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); print(&quot;string&quot;, 1.3); printArgs(&quot;string&quot;, 1.3, 43, 554, &quot;string&quot;, 1.44); printArgs(&quot;string&quot;, 1.3); my_printf(&quot;整数:%d,字符:%c,整数:%d,字符:%c&quot;, 123, &#39;A&#39;, 123, &#39;A&#39;); return 0; &#125; 可变参数模板类#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;tuple&gt; using namespace std; // No.1 采用继承+模板特化的方式展开参数包 template &lt;class... Args&gt; class Test; //递归终止，特化模板 template &lt;&gt; class Test&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Test&lt;_Ty, Args...&gt; : public Test&lt;Args...&gt; &#123; public: Test() &#123;&#125; //构造函数做参数包展开 Test(_Ty data, Args... args) : data(data), Test&lt;Args...&gt;(args...) &#123;&#125; //&#123;int,double,string&#125; Test&lt;int&gt; //&#123;double,string&#125; Test&lt;double&gt; //&#123;string&#125; Test&lt;string&gt; //访问数据 _Ty&amp; GetData() &#123; return data; &#125; Test&lt;Args...&gt;&amp; GetObject() &#123; return *this; &#125; protected: _Ty data; &#125;; void testFirst() &#123; Test&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetObject().GetObject().GetData() &lt;&lt; endl; Test&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetObject().GetObject().GetObject().GetData() &lt;&lt; endl; &#125; // No.2 递归方式展开 template &lt;class... Args&gt; class Tup; //终止使用的特化模板 template &lt;&gt; class Tup&lt;&gt; &#123;&#125;; template &lt;class _Ty, class... Args&gt; class Tup&lt;_Ty, Args...&gt; &#123; public: Tup() &#123;&#125; //参数包展开 Tup(_Ty data, Args... args) : data(data), args(args...) &#123;&#125; //数据访问 _Ty&amp; GetData() &#123; return data; &#125; Tup&lt;Args...&gt;&amp; GetArgs() &#123; return args; &#125; protected: _Ty data; Tup&lt;Args...&gt; args; &#125;; void testSecond() &#123; Tup&lt;int, double, string&gt; test(1, 1.11, &quot;string&quot;); // Test&lt;int, double, string, float &gt; test2(1, 1.11, &quot;string&quot;,1.1f); cout &lt;&lt; test.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; test.GetArgs().GetArgs().GetData() &lt;&lt; endl; Tup&lt;string, int, int, string&gt; student(&quot;baby&quot;, 18, 1001, &quot;18508444345&quot;); cout &lt;&lt; student.GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetData() &lt;&lt; &quot;\\t&quot; &lt;&lt; student.GetArgs().GetArgs().GetArgs().GetData() &lt;&lt; endl; &#125; //统一接口 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Func)(int, int), int a, int b) &#123; //接口 cout &lt;&lt; Func(a, b) &lt;&lt; endl; &#125; int getValue(int a) &#123; return a; &#125; void print(int (*Func)(int), int a) &#123; //接口 cout &lt;&lt; Func(a) &lt;&lt; endl; &#125; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;sdfsd&quot; &lt;&lt; endl; &#125; operator int() &#123; return age; &#125; protected: int age; string name; &#125;; void testMM() &#123; MM mm(&quot;小芳&quot;, 19); int value = mm; //类的对象隐式转换 cout &lt;&lt; value &lt;&lt; endl; MM* pmm = new MM(&quot;ds&quot;, 19); auto func = &amp;MM::print; (pmm-&gt;*func)(); &#125; template &lt;class _Ty, class _TyF, class... Args&gt; class InterFace &#123; public: InterFace(_Ty* data, _TyF (_Ty::*func)(Args...)) : data(data), func(func) &#123;&#125; //重载 _TyF operator()(Args... args) &#123; return (data-&gt;*func)((args)...); &#125; protected: _Ty* data; //_Ty 类类型 _TyF (_Ty::*func)(Args...); //类中成员函数指针 &#125;; //统一创建接口 template &lt;class _Ty, class _TyF, class... Args&gt; InterFace&lt;_Ty, _TyF, Args...&gt; createObject(_Ty* data, _TyF (_Ty::*func)(Args...)) &#123; return InterFace&lt;_Ty, _TyF, Args...&gt;(data, func); &#125; struct Data &#123; void Func1(int i) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; void Func2(int i, int j) &#123; cout &lt;&lt; i + j &lt;&lt; endl; &#125; void Func3(int i, int j, int k) &#123; cout &lt;&lt; i * j * k &lt;&lt; endl; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; &#125;; void testInterFace() &#123; Data data; auto Func1 = createObject(&amp;data, &amp;Data::Func1); Func1(1); auto Func2 = createObject(&amp;data, &amp;Data::Func2); Func2(2, 3); auto Func3 = createObject(&amp;data, &amp;Data::Func3); Func3(2, 3, 4); auto Func4 = createObject(&amp;data, &amp;Data::Max); cout &lt;&lt; Func4(2, 3) &lt;&lt; endl; &#125; void print1(int a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; void print2(int a, int b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testFirst(); tuple&lt;int, string&gt; tup; testSecond(); testInterFace(); //多线程库 thread t1(print1, 1); t1.join(); thread t2(print2, 2, 3); t2.join(); return 0; &#125; C++随机数,比较鸡肋,直接用C语言的吧#include &lt;array&gt; #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;vector&gt; using namespace std; void testSeed() &#123; // NO.1 种子管理 seed_seq seed = &#123;1, 3, 4, 5, 6, 7, 8&#125;; cout &lt;&lt; &quot;size:&quot; &lt;&lt; seed.size() &lt;&lt; endl; array&lt;int, 7&gt; data; seed.param(data.begin()); //把种子拿出赋值 for (auto v : data) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; // array&lt;int,7&gt; vec; //使用内部算法填充所提供序列的元素 // seed.generate(vec.begin(), vec.end()); ////for_each(vec.begin(), vec.end(), [](int a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;); // for (auto v : vec) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; &#125; void RandValue() &#123; // 1.基操 //随机引擎--&gt;就是一个算法 //线性同余： x=(x*a+c)%m; //梅森旋转 default_random_engine e; //设置随机数种子 e.seed(chrono::high_resolution_clock::now().time_since_epoch().count()); //等同: e.seed((size_t)time(nullptr)); for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;随机数:&quot; &lt;&lt; e() % 10 &lt;&lt; endl; //控制范围和C语言一样，用区域方式 &#125; // 2.分布方式 uniform_int_distribution&lt;int&gt; duration(1, 6); cout &lt;&lt; &quot;uniform:&quot; &lt;&lt; duration(e) &lt;&lt; endl; //随机数范围在1-6之间 auto randFunc = bind(duration, e); cout &lt;&lt; &quot;1:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;2:&quot; &lt;&lt; randFunc() &lt;&lt; endl; cout &lt;&lt; &quot;3:&quot; &lt;&lt; randFunc() &lt;&lt; endl; // 3.其他引擎 // x=(x*a+c)%m; linear_congruential_engine&lt;unsigned int, 2, 4, 8&gt; ee; ee.seed((size_t)time(nullptr)); cout &lt;&lt; &quot;线性同余:&quot; &lt;&lt; ee() &lt;&lt; endl; //梅森旋转 mersenne_twister_engine&lt;size_t, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1&gt; eeee; //一般用直接用下面写法 mt19937_64 eeeee; cout &lt;&lt; &quot;梅森:&quot; &lt;&lt; eeeee() &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; testSeed(); RandValue(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++正则表达式","slug":"C++正则表达式","date":"2022-06-16T09:10:54.000Z","updated":"2023-02-19T08:04:04.960Z","comments":true,"path":"2022/06/16/C++正则表达式/","link":"","permalink":"http://am900skp.github.io/2022/06/16/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++正则库正则指的是一种规则，用来匹配，捕获，替换字符串(字符串处理方案) 特殊含义元字符^: 以字符作为字符串开的头, ^ 表示单个字符 $:以字符结尾 ，\\$表示单个字符 ():分组 &#121;&#100;&#112;&#97;&#106;&#106;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d; \\b: 字符串的边界 .: 除了\\n意外的任意一个字符 |:a|b a或者b [abc]: abc任意一个字符 [^abc]: abc之外的任意一个字符 [a-z]:任意一个小写字母 \\w: 任意字母数字下划线 [(0-9)(a-z)(A-Z)(_)] \\W: 字母数字下划线之外的字符 \\d: 任意一个数字 \\D:数字之外的任意一个字符 \\s: 空白符 量词元字符*:0次或者多次 [a-z]* {0,} +:1次或者多次 {1,} ?:0次或者1次 {0,1} {n}: 出现n次 {n,}: 至少出现n次 {n,m}: 至少有n到m个之间的字符 注意的问题: C&#x2F;C++中带\\的元字符一定改为\\\\ #include &lt;iostream&gt; #include &lt;regex&gt; #include &lt;string&gt; using namespace std; // No.1 匹配 void testMatch() &#123; // 1.1 先构造正则对象 // 1.2 调用 regex_match 返回true匹配，返回false不匹配 #if 0 while (1) &#123; string userName; cin &gt;&gt; userName; regex reg(&quot;^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$&quot;); bool result = regex_match(userName, reg); if (result == true) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; #endif //正则匹配一定完全匹配 string str = &quot;ILoveyou1314&quot;; regex reg(&quot;[a-z0-9]+&quot;); if (regex_match(str, reg)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg2(&quot;[a-z0-9]+&quot;, regex_constants::icase); //忽略大小写 if (regex_match(str, reg2)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; regex reg3(&quot;ILoveyou[0-9]+&quot;); if (regex_match(str, reg3)) &#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl; &#125; &#125; // No.2 截取 void testGetString() &#123; string str = &quot;ILoveyou1314IMiss520you999dsdsd999sds23234&quot;; // regex_search(string str,smatch result,regex reg); smatch result; //只要找到就结束 bool flag = regex_search(str, result, regex(&quot;\\\\d+&quot;)); if (flag) &#123; cout &lt;&lt; &quot;size:&quot; &lt;&lt; result.size() &lt;&lt; endl; for (int i = 0; i &lt; result.size(); i++) &#123; cout &lt;&lt; result.str() &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;前缀:&quot; &lt;&lt; result.prefix() &lt;&lt; endl; cout &lt;&lt; &quot;后缀:&quot; &lt;&lt; result.suffix() &lt;&lt; endl; &#125; //捕获所有满足的条件字符串 // sregex_iterator regex reg(&quot;\\\\d+&quot;); //得到满足条件 sregex_iterator pos(str.begin(), str.end(), reg); sregex_iterator end; //无参构造是结束流 while (pos != end) &#123; cout &lt;&lt; pos-&gt;str() &lt;&lt; &quot;\\t&quot;; pos++; &#125; cout &lt;&lt; endl; str = &quot;10,12,32,,,34,,34,34,6566,67,,67&quot;; // 0: 表示匹配 //-1:不匹配 regex reg2(&quot;,&quot;); sregex_token_iterator tpos(str.begin(), str.end(), reg2, -1); sregex_token_iterator tend; while (tpos != tend) &#123; cout &lt;&lt; tpos-&gt;str() &lt;&lt; &quot; &quot;; tpos++; &#125; cout &lt;&lt; endl; &#125; // No.3 替换 void testReplace() &#123; string str = &quot;ILoveyou******IMiss*******y*****o***u&quot;; regex reg(&quot;\\\\*+&quot;); // regex_replace(string str,regex regx,string content) //返回值是处理后的字符串 cout &lt;&lt; &quot;888:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;) &lt;&lt; endl; //控制替换 cout &lt;&lt; &quot;only one:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_first_only) &lt;&lt; endl; cout &lt;&lt; &quot;no copy:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_no_copy) &lt;&lt; endl; cout &lt;&lt; &quot;sed:&quot; &lt;&lt; regex_replace(str, reg, &quot;*&quot;, regex_constants::format_sed) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // testMatch(); // testGetString(); testReplace(); return 0; &#125; C++日期时间库using nanoseconds = duration&lt;long long, nano&gt;; //纳秒 using microseconds = duration&lt;long long, micro&gt;; //微妙 using milliseconds = duration&lt;long long, milli&gt;; //毫秒 using seconds = duration&lt;long long&gt;; //秒 using minutes = duration&lt;int, ratio&lt;60&gt;&gt;; //分钟 using hours = duration&lt;int, ratio&lt;3600&gt;&gt;; //小时 #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; int main(int argc, char** argv) &#123; chrono::seconds one(1); // C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; return 0; &#125; 时钟 system_clock:系统时钟 steady_clock: 计时 high_resoulution_clock: 高精度时钟 时间点 time_point:时间点 from_time_t: time_t 的时间转换为time_point to_time_t: time_piont 转换为time_t #include &lt;chrono&gt; #include &lt;ctime&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;thread&gt; using namespace std; void GetTime() &#123; //获取当前系统时间 chrono::system_clock::time_point curTime = chrono::system_clock::now(); //用的时候: auto curTime=chrono::system_clock::now(); time_t tm_t = chrono::system_clock::to_time_t(curTime); cout &lt;&lt; &quot;日期:&quot; &lt;&lt; ctime(&amp;tm_t) &lt;&lt; endl; //格式化输出时间 tm* pCurTime = localtime(&amp;tm_t); cout &lt;&lt; put_time(pCurTime, &quot;%F %X&quot;) &lt;&lt; endl; cout &lt;&lt; &quot;时间戳:&quot; &lt;&lt; curTime.time_since_epoch().count() &lt;&lt; endl; &#125; void CountTime() &#123; chrono::steady_clock::time_point start = chrono::steady_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; chrono::steady_clock::time_point end = chrono::steady_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; void HightClock() &#123; auto start = chrono::high_resolution_clock::now(); cout &lt;&lt; &quot;start:&quot; &lt;&lt; endl; for (int i = 0; i &lt; 1000; i++) &#123; // cout &lt;&lt; &quot;运行中...&quot; &lt;&lt; endl; &#125; auto end = chrono::high_resolution_clock::now(); // auto dt = end - start; //纳秒 chrono::duration&lt;double, ratio&lt;1, 1000&gt;&gt; dt = end - start; cout &lt;&lt; &quot;耗时&quot; &lt;&lt; dt.count() &lt;&lt; &quot;s&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; #if 0 chrono::seconds one(1); //C++延时函数 thread //延时1秒钟 this_thread::sleep_for(chrono::seconds(1)); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1s); cout &lt;&lt; &quot;延时1秒钟&quot; &lt;&lt; endl; this_thread::sleep_for(1000ms); cout &lt;&lt; &quot;延时1000毫秒&quot; &lt;&lt; endl; #endif GetTime(); CountTime(); HightClock(); return 0; &#125; C+文件目录库C++17标准才有的东西，C++文件目录库分为三部分 file_status类: 文件状态 path类: 处理目录 directory_entry类： 访问遍历目录 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;string&gt; using namespace std; void TestPath() &#123; error_code temp; filesystem::create_directory(&quot;xxx&quot;, temp); //创建一个目录(文件夹) filesystem::create_directories(&quot;a/b&quot;); //创建多级目录 cout &lt;&lt; temp.message() &lt;&lt; endl; filesystem::create_directory(&quot;xxx/bbb&quot;); //创建一个目录(文件夹) // filesystem::path url(&quot;my_box&quot;); //构建一个path filesystem::path url = filesystem::current_path(); cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url &lt;&lt; endl; cout &lt;&lt; &quot;当前路径:&quot; &lt;&lt; url.string() &lt;&lt; endl; cout &lt;&lt; &quot;根目录:&quot; &lt;&lt; url.root_directory() &lt;&lt; endl; cout &lt;&lt; &quot;相对路径:&quot; &lt;&lt; url.relative_path() &lt;&lt; endl; cout &lt;&lt; &quot;根名：&quot; &lt;&lt; url.root_name() &lt;&lt; endl; cout &lt;&lt; &quot;根路径:&quot; &lt;&lt; url.root_path() &lt;&lt; endl; &#125; void DemoStatus(filesystem::file_status object) &#123; switch (object.type()) &#123; case filesystem::file_type::regular: cout &lt;&lt; &quot;磁盘文件&quot; &lt;&lt; endl; break; case filesystem::file_type::directory: cout &lt;&lt; &quot;目录文件&quot; &lt;&lt; endl; break; case filesystem::file_type::not_found: cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; break; case filesystem::file_type::unknown: cout &lt;&lt; &quot;无法识别文件&quot; &lt;&lt; endl; break; &#125; &#125; void TestStatus() &#123; filesystem::create_directory(&quot;fileBox&quot;); DemoStatus(filesystem::status(&quot;fileBox&quot;)); fstream file(&quot;fileBox/file&quot;, ios::out | ios::trunc); DemoStatus(filesystem::status(&quot;fileBox/file&quot;)); &#125; // directory_entry // directory_iterator // 1.遍历当前目录下所有文件夹(一层) void tarverseDirectory() &#123; filesystem::path url(&quot;./test&quot;); if (!filesystem::exists(url)) &#123; cout &lt;&lt; &quot;目录不存在&quot; &lt;&lt; endl; return; &#125; filesystem::directory_iterator list(url); for (auto v : list) &#123; cout &lt;&lt; v.path().filename() &lt;&lt; endl; &#125; &#125; // 2.遍历文件夹中的所有文件(一层) void travserDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); set&lt;string&gt; dirset; for (filesystem::directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; &#125; // 3.所有文件夹中的文件 void traverseAllDirectoryAllFile() &#123; filesystem::path url(&quot;./test&quot;); multiset&lt;string&gt; dirset; for (filesystem::recursive_directory_iterator end, begin(url); begin != end; ++begin) &#123; if (!filesystem::is_directory(begin-&gt;path())) &#123; dirset.insert(begin-&gt;path().filename().string()); &#125; &#125; for (auto v : dirset) &#123; cout &lt;&lt; v &lt;&lt; endl; &#125; remove_all(url / &quot;b&quot;); //删除当前url下面b文件夹 &#125; // remove_all int main(int argc, char** argv) &#123; TestPath(); TestStatus(); tarverseDirectory(); travserDirectoryAllFile(); traverseAllDirectoryAllFile(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++智能指针","slug":"C++智能指针","date":"2022-06-13T11:06:51.000Z","updated":"2023-02-19T08:03:56.492Z","comments":true,"path":"2022/06/13/C++智能指针/","link":"","permalink":"http://am900skp.github.io/2022/06/13/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++智能指针智能指针本质是一个类的对象，使用的时候不会创建这个类指针，只会使用这个类的对象 智能指针原理是通过对象的死亡会自动调用析构函数这个功能去实现 构造函数: 管理new的对象 析构函数: 析构new的对象 C++共享型智能指针 允许拷贝构造 允许多个智能指针对象管理同一段内存 // shared_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void printData(shared_ptr&lt;MM&gt; mm) &#123; mm-&gt;print(); &#125; auto returnPtr() &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;小芳&quot;, 18)); return mm; &#125; void FreeFile(FILE*&amp; fp) &#123; cout &lt;&lt; &quot;关闭文件成功&quot; &lt;&lt; endl; fclose(fp); &#125; void test_shared_ptr() &#123; // 1.管理基本数据 shared_ptr&lt;int&gt; intData(new int(100)); if (!intData) &#123; cout &lt;&lt; &quot;初始化之智能指针失败!&quot; &lt;&lt; endl; return; &#125; cout &lt;&lt; *intData &lt;&lt; endl; //获取管理对象地址 // int* x = intData.get(); // cout &lt;&lt; *x &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p2(intData); cout &lt;&lt; &quot;size:&quot; &lt;&lt; intData.use_count() &lt;&lt; endl; // swap // reset // make_shared函数的参数由构造函数决定 // 2.管理自定义类型 shared_ptr&lt;string&gt; str = make_shared&lt;string&gt;(&quot;ILoveyou&quot;); cout &lt;&lt; *str &lt;&lt; endl; &#123; shared_ptr&lt;MM&gt; mm(new MM(&quot;张三&quot;, 19)); mm-&gt;print(); mm.reset(new MM(&quot;小芳&quot;, 18)); mm-&gt;print(); shared_ptr&lt;MM&gt; mm2 = make_shared&lt;MM&gt;(&quot;小芳&quot;, 20); mm2-&gt;print(); &#125; // 3.智能指针常用场景 shared_ptr&lt;MM&gt; temp(new MM(&quot;亲爱的&quot;, 28)); printData(temp); printData(returnPtr()); // 4.特殊释放形式的内存，需要自己手动写删除器 // C语言文件指针 &#123; shared_ptr&lt;FILE&gt; pf(fopen(&quot;1.txt&quot;, &quot;w+&quot;), FreeFile); &#125; &#123; shared_ptr&lt;Boy&gt; p(new Boy[10], [](Boy*&amp; p) &#123; delete[] p; &#125;); &#125; &#123; shared_ptr&lt;int&gt; pint(new int(999)); int* pp = pint.get(); *pp = 666; cout &lt;&lt; *pint &lt;&lt; endl; // delete pp; //不能直接释放，会导致二次析构问题 // cout &lt;&lt; *pint &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; test_shared_ptr(); return 0; &#125; C++弱引用型智能指针 weak_ptr 是弱引用指针，不会累计计数 weak_ptr不能直接管理对象，只能shared_ptr或者weak_ptr构造而来 目的是为了解决shared_ptr循环引用的时候内存未释放问题 不可以使用* 或者-&gt;访问对象，只能通过lock函数访问shared_ptr对象，再去访问数据 // weak_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class B; class A &#123; public: A() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;B&gt; b; weak_ptr&lt;B&gt; b; &#125;; class B &#123; public: B() &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B&quot; &lt;&lt; endl; &#125; // shared_ptr&lt;A&gt; a; weak_ptr&lt;A&gt; a; &#125;; void test_weak_ptr() &#123; &#123; shared_ptr&lt;A&gt; ao = make_shared&lt;A&gt;(); shared_ptr&lt;B&gt; bo = make_shared&lt;B&gt;(); cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; ao-&gt;b = bo; bo-&gt;a = ao; cout &lt;&lt; ao.use_count() &lt;&lt; endl; cout &lt;&lt; bo.use_count() &lt;&lt; endl; &#125; &#123; shared_ptr&lt;int&gt; s(new int(999)); cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; weak_ptr&lt;int&gt; w(s); cout &lt;&lt; &quot;count:&quot; &lt;&lt; w.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;count:&quot; &lt;&lt; s.use_count() &lt;&lt; endl; cout &lt;&lt; *w.lock() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); test_weak_ptr(); return 0; &#125; C++独享型智能指针 禁止拷贝和赋值(通过删除拷贝构造函数和赋值重载) 可以通过转交所有权的方式让一个指针去管理对象 move函数移交所有权限 内置reset函数结合release函数去移交所有权限 // unique_ptr #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构过程&quot; &lt;&lt; endl; &#125; protected: string name; int age; &#125;; class Boy &#123; public: Boy() &#123; cout &lt;&lt; &quot;Boy&quot; &lt;&lt; endl; &#125; ~Boy() &#123; cout &lt;&lt; &quot;~Boy&quot; &lt;&lt; endl; &#125; &#125;; void test_unique_ptr() &#123; unique_ptr&lt;int&gt; ptr(new int(999)); cout &lt;&lt; *ptr &lt;&lt; endl; // unique_ptr&lt;int&gt; ptr2(ptr); //转交所有权 unique_ptr&lt;int&gt; ptr2; ptr2 = move(ptr); // cout &lt;&lt; *ptr &lt;&lt; endl; //没有值了 cout &lt;&lt; *ptr2 &lt;&lt; endl; unique_ptr&lt;int&gt; ptr3; ptr3.reset(ptr2.release()); cout &lt;&lt; *ptr3 &lt;&lt; endl; auto p = ptr3.get(); // delete p; //导致二次析构问题 &#123; unique_ptr&lt;MM&gt; pMM(new MM(&quot;小美&quot;, 19)); pMM-&gt;print(); // unique_ptr&lt;管理对象类型,删除器函数指针类型&gt; using FUNC = void (*)(Boy*&amp;); unique_ptr&lt;Boy, FUNC&gt; pBoy(new Boy[3], [](Boy*&amp; pBoy) &#123; delete[] pBoy; &#125;); //不能用auto // unique_ptr&lt;Boy, auto&gt; pBoy2(new Boy[3], [](Boy*&amp; pBoy) &#123;delete[] // pBoy; &#125;); &#125; &#125; int main(int argc, char** argv) &#123; // test_shared_ptr(); // test_weak_ptr(); test_unique_ptr(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++模板","slug":"C++模板","date":"2022-06-10T00:32:18.000Z","updated":"2023-02-19T08:03:29.259Z","comments":true,"path":"2022/06/10/C++模板/","link":"","permalink":"http://am900skp.github.io/2022/06/10/C++%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++模板什么是模板模板编程也可以叫做泛型编程，忽略数据类型的一种编程方式 //求最值问题 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; double Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; string Max(string a, string b) &#123; return a &gt; b ? a : b; &#125; //引入模板编程 template &lt;typename type&gt; //告诉编译器，下面会用到一个未知类型叫做type type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; 模板代码 #include &lt;iostream&gt; using namespace std; template &lt;typename type&gt; type Max(type a, type b) &#123; return a &gt; b ? a : b; &#125; // typename 可以用class 替换 template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; //隐式调用 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; cout &lt;&lt; Max(1.1, 2.2) &lt;&lt; endl; // string 和char* 有区别 cout &lt;&lt; Max(string(&quot;1ILoveyou&quot;), string(&quot;2IMissyou&quot;)) &lt;&lt; endl; //显示调用 &lt;&gt;传类型的参数 cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; // type=int a=1 b=2 cout &lt;&lt; Max&lt;string&gt;(string(&quot;1&quot;), string(&quot;2&quot;)) &lt;&lt; endl; cout &lt;&lt; Max&lt;double&gt;(1.2, 1.3) &lt;&lt; endl; return 0; &#125; 函数模板函数模板重载问题 函数模板和普通函数 函数模板和函数模板 #include &lt;iostream&gt; using namespace std; // No.1 模板与普通函数 int Max(int a, int b) &#123; cout &lt;&lt; &quot;普通函数...&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; template &lt;class T&gt; T Max(T a, T b) &#123; cout &lt;&lt; &quot;模板&quot; &lt;&lt; endl; return a &gt; b ? a : b; &#125; // No.2 模板与模板 template &lt;class type1, class type2, class type3&gt; void print(type1 one, type2 two, type3 three) &#123; cout &lt;&lt; &quot;三只&quot; &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; // type1=int type2=double void print(type1 one, type1 two, type2 tow) &#123; // int int double cout &lt;&lt; &quot;两只&quot; &lt;&lt; endl; &#125; template &lt;class type&gt; void print(type one, type two, type three) &#123; cout &lt;&lt; &quot;一只&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; Max&lt;int&gt;(1, 2) &lt;&lt; endl; //显式调用，百分百调用模板 cout &lt;&lt; Max(1, 2) &lt;&lt; endl; //优先调用类型确定的函数 cout &lt;&lt; &quot;显示调用&quot; &lt;&lt; endl; print&lt;int, double, string&gt;(1, 1.1, string(&quot;23&quot;)); print&lt;int, double&gt;(1, 1, 1.22); print&lt;int&gt;(1, 2, 3); cout &lt;&lt; &quot;隐式调用&quot; &lt;&lt; endl; print(1, 1, 2); //需要传参越少先调用 print(1, 1, string(&quot;sdsd&quot;)); print(1, 1.11, string(&quot;sdsd&quot;)); //只有一种选择 return 0; &#125; 类成员函数是函数模板//这种不叫做模板类型 class MM &#123; public: template &lt;class T&gt; void print(T data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; MM mm; mm.print(1); mm.print&lt;string&gt;(&quot;string&quot;); return 0; &#125; 函数模板缺省函数模板缺省和函数参数的缺省是一样的规则 //函数模板缺省 template &lt;class type1,class type2=string&gt; void printData(type1 one, type2 two) &#123; cout &lt;&lt; one &lt;&lt; endl; cout &lt;&lt; two &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; printData&lt;int, double&gt;(1, 1.22); printData&lt;int&gt;(1, string(&quot;dsfsdf&quot;)); return 0; &#125; 函数模板传常量//函数模板传常量 template &lt;class T,size_t size&gt; void printArray(T* array) &#123; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; int num[3] = &#123; 1,2,3 &#125;; printArray&lt;int, 3&gt;(num); //下面代码报错 //int length = 3; //printArray&lt;int, length&gt;(num); string str[4] = &#123; &quot;sdds&quot;,&quot;sd&quot;,&quot;sdsd&quot; ,&quot;sdds&quot;&#125;; printArray&lt;string, 4&gt;(str); return 0; &#125; 类模板 类模板不是一个完整类型，所以任何用到类名的地方都需要用类名&lt;未知类型&gt;的方式使用 怎么去使用类模板，类模板必须采用显式调用方式 类模板在多文件中不能分开写 可以写在.hpp文件中(声明和实现都在一起) #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; template &lt;class type1, class type2&gt; struct my_pair &#123; type1 first; //键 type2 second; //值 my_pair(type1 first, type2 second) : first(first), second(second) &#123;&#125; my_pair() = default; &#125;; template &lt;class type1, class type2&gt; my_pair&lt;type1, type2&gt; my_make_pair(type1 one, type2 two) &#123; return my_pair&lt;type1, type2&gt;(one, two); &#125; template &lt;class type1, class type2&gt; class Test &#123; public: Test(type1 one, type2 two) : one(one), two(two) &#123;&#125; void printTest(); protected: type1 one; type2 two; &#125;; template &lt;class type1, class type2&gt; void Test&lt;type1, type2&gt;::printTest() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; template &lt;class type1, class type2&gt; class Data : public Test&lt;type1, type2&gt; &#123; public: Data(type1 one, type2 two) : Test&lt;type1, type2&gt;(one, two) &#123;&#125; protected: &#125;; int main(int argc, char** argv) &#123; my_pair&lt;int, int&gt; pairData = &#123;1, 2&#125;; cout &lt;&lt; pairData.first &lt;&lt; &quot; &quot; &lt;&lt; pairData.second &lt;&lt; endl; my_pair&lt;int, string&gt;* p = new my_pair&lt;int, string&gt;; p-&gt;first = 12; p-&gt;second = &quot;sdsd&quot;; cout &lt;&lt; p-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;second &lt;&lt; endl; Data&lt;int, int&gt; data(1, 2); data.printTest(); //标准库中的pair类型 pair&lt;int, string&gt; pD(1, &quot;ILoveyou&quot;); cout &lt;&lt; pD.first &lt;&lt; &quot; &quot; &lt;&lt; pD.second &lt;&lt; endl; pair&lt;int, string&gt; testData = make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); my_pair&lt;int, string&gt; my_testData = my_make_pair&lt;int, string&gt;(1, &quot;sdfsdf&quot;); return 0; &#125; 类模板特化问题 局部特化 完全特化 特化的目的是为了适应不同数据的不同处理 #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; (one + two + three) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; //局部特化 //两个数据,打印两数之差 template &lt;class _Ty1, class _Ty2&gt; class Data&lt;_Ty1, _Ty1, _Ty2&gt; &#123; public: Data(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; (one - two) &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; &#125;; //只有一个数据,打印数据 template &lt;class _Ty1&gt; class Data&lt;_Ty1, _Ty1, _Ty1&gt; &#123; public: Data(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; private: _Ty1 one; &#125;; //完全特化 template &lt;&gt; class Data&lt;string, string, string&gt; &#123; public: Data(string one, string two, string three) : one(one), two(two), three(three) &#123;&#125; void printData(); private: string one; string two; string three; &#125;; void Data&lt;string, string, string&gt;::printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data1(1); data1.printData(); Data&lt;int, int, double&gt; data2(2, 1); data2.printData(); Data&lt;int, double, float&gt; data3(1, 1.1, 1.2f); data3.printData(); Data&lt;string, string, string&gt; data4(&quot;dsd&quot;, &quot;sdfd&quot;, &quot;sdfdsf&quot;); data4.printData(); return 0; &#125; 模板操作自定义类型 模板操作自定义关键点在于重载 #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() = default; MM(string name, int age) : name(name), age(age) &#123;&#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot; &quot; &lt;&lt; object.age; return out; &#125; private: string name; int age; &#125;; template &lt;class _Ty&gt; void printData(_Ty data) &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: //_Ty1=MM, _Ty2=int, _Ty3=int Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; private: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; int main(int argc, char** argv) &#123; printData(1); printData(&quot;string&quot;); MM mm = &#123;&quot;小芳&quot;, 18&#125;; printData(mm); Data&lt;MM, int, int&gt; data(MM(&quot;小芳&quot;, 18), 98, 99); data.printData(); Data&lt;MM, MM, MM&gt; mmData(MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18), MM(&quot;小芳&quot;, 18)); mmData.printData(); return 0; &#125; 模板嵌套模板 (类型是由类名&lt;类型&gt;表示一个类型） #include &lt;iostream&gt; using namespace std; template &lt;class _Ty1, class _Ty2, class _Ty3&gt; class Data &#123; public: Data(_Ty1 one, _Ty2 two, _Ty3 three) : one(one), two(two), three(three) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; &quot; &quot; &lt;&lt; three &lt;&lt; endl; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Data&lt;_Ty1, _Ty2, _Ty3&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot; &lt;&lt; object.three; return out; &#125; protected: _Ty1 one; _Ty2 two; _Ty3 three; &#125;; template &lt;class _Ty1, class _Ty2&gt; class Info &#123; public: Info(_Ty1 one, _Ty2 two) : one(one), two(two) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; &quot; &quot; &lt;&lt; two &lt;&lt; endl; &#125; // template &lt;class _Ty1, class _Ty2&gt; 类中实现不需要修饰了，会出现重定义问题 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Info&lt;_Ty1, _Ty2&gt;&amp; object) &#123; out &lt;&lt; object.one &lt;&lt; &quot; &quot; &lt;&lt; object.two &lt;&lt; &quot; &quot;; return out; &#125; protected: _Ty1 one; _Ty2 two; &#125;; template &lt;class _Ty1&gt; class Student &#123; public: Student(_Ty1 one) : one(one) &#123;&#125; void printData() &#123; cout &lt;&lt; one &lt;&lt; endl; &#125; protected: _Ty1 one; &#125;; int main(int argc, char** argv) &#123; Data&lt;int, int, int&gt; data(1, 1, 1); // Data&lt;int, int, int&gt; Info&lt;int, int&gt; info(1, 2); // Info&lt;int, int&gt; Info&lt;Data&lt;int, int, int&gt;, Data&lt;string, string, string&gt;&gt; test1( Data&lt;int, int, int&gt;(1, 1, 1), Data&lt;string, string, string&gt;(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); //起别名 using type1 = Data&lt;int, int, int&gt;; using type2 = Data&lt;string, string, string&gt;; //别名版本 Info&lt;type1, type2&gt; test2(type1(1, 1, 1), type2(&quot;ds&quot;, &quot;sd&quot;, &quot;sds&quot;)); Data&lt;Info&lt;int, string&gt;, Info&lt;string, string&gt;, Info&lt;int, double&gt;&gt; test3( Info&lt;int, string&gt;(1, &quot;sd&quot;), Info&lt;string, string&gt;(&quot;sdds&quot;, &quot;dsds&quot;), Info&lt;int, double&gt;(1, 1.11)); test1.printData(); test2.printData(); test3.printData(); Student&lt;Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;&gt; stu( Data&lt;Info&lt;int, int&gt;, Info&lt;int, string&gt;, Info&lt;string, string&gt;&gt;( Info&lt;int, int&gt;(1, 1), Info&lt;int, string&gt;(1, &quot;sdsd&quot;), Info&lt;string, string&gt;(&quot;sds&quot;, &quot;sdsd&quot;))); stu.printData(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++IO流","slug":"C++IO流","date":"2022-06-08T08:11:36.000Z","updated":"2023-02-19T08:02:58.811Z","comments":true,"path":"2022/06/08/C++IO流/","link":"","permalink":"http://am900skp.github.io/2022/06/08/C++IO%E6%B5%81/","excerpt":"","text":"编译器: gcc &#x2F; g++ C++IO流流的概念流就是若干字节组成字节序列，流操作从一个到另一个移动的过程 流中的内容:二进制数据 ASCII码 流类体系C++中用类实现所有流类操作 标准的输入输出流 C++格式控制 字符流 文件流 #include &lt;iostream&gt; //istream ostream #include &lt;fstream&gt; //ifstream ofstream #include &lt;strstream&gt; //istringstream using namespace std; int main(int argc, char** argv) &#123; fstream out; ifstream iin; return 0; &#125; 标准输入输出流 对象 类型 作用 cin 标准输入 从键盘读取，可以重定向 cout 标准输出 输出到控制台，可以重定向 cerr 标准错误输出 输出到控制台，不可以重定向 clog 标准错误输出 输出到控制台，可重定向 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; return 0; &#125; 字符和字符串输入 cout成员函数 put() : 输出一个字符 write(): 输出字符串 cin成员函数 get()：输入一个字符 getline: 输入一个字符串 #include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;标准输出&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; //字符输入 cout &lt;&lt; &quot;字符输入:&quot; &lt;&lt; endl; int userKey = cin.get(); cout.put(userKey); char str[10] = &#123; &quot;&quot; &#125;; cout &lt;&lt; &quot;字符串输入:&quot; &lt;&lt; endl; while (getchar() != &#39;\\n&#39;); cin.getline(str, 10); //10个长度包含\\0 cout &lt;&lt; str &lt;&lt; endl; cout.write(str, 10); return 0; &#125; C++格式控制 包含头文件: iomanip 通过对象的形式，一种通过成员的函数形式 对象形式 实际含义 setbase(n) 设置多少进制输出整数(参数是8和16) setw(n) 设置输出数据宽度(默认对齐是右对齐，不足补空格) setiosflags(ios::left) 设置对齐方式: ios::left ,ios::right setprecition(n) 单纯使用是控制有效位数，如果控制小数位数结合fixed setfill(n) 填充字符 #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int main(int argc, char** argv) &#123; //进制输出 cout &lt;&lt; setbase(16) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; setbase(8) &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt;showbase&lt;&lt; hex &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; dec &lt;&lt; 32 &lt;&lt; endl; cout &lt;&lt; noshowbase&lt;&lt;oct &lt;&lt; 32 &lt;&lt; endl; //cout &lt;&lt; setbase(2) &lt;&lt; 32 &lt;&lt; endl; //无效 //默认右对齐 cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setiosflags(ios::left); cout &lt;&lt; setw(10) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(10) &lt;&lt; &quot;年龄&quot; &lt;&lt; setw(10) &lt;&lt; &quot;编号&quot; &lt;&lt; endl; cout &lt;&lt; setw(10) &lt;&lt; &quot;小芳&quot; &lt;&lt; setw(10) &lt;&lt; 17 &lt;&lt; setw(10) &lt;&lt; 119911 &lt;&lt; endl; cout &lt;&lt; setprecision(4) &lt;&lt; 300.12345 &lt;&lt; endl; //直接用控制的是有效位数 cout &lt;&lt; fixed&lt;&lt;setprecision(4) &lt;&lt; 300.12349 &lt;&lt; endl; //小数位数 cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; 300.12345 &lt;&lt; endl; //所有的格式控制存在成员函数的调用形式 cout.width(8); cout &lt;&lt; &quot;姓名&quot;; cout.width(8); cout &lt;&lt; 1 &lt;&lt; endl; cout.precision(4); //取消上述格式 cout &lt;&lt;resetiosflags &lt;&lt;300.333 &lt;&lt; endl; bool num = 1; cout &lt;&lt; boolalpha &lt;&lt; num &lt;&lt; endl; //true和false形式输出bool类型 return 0; &#125; 字符流 包含头文件： sstream istringstream ostringstream stringstream 一般处理字符流的时候用的是stringstream类型的对象 获取字符流中的stirng string str(); &#x2F;&#x2F;获取string void str(const string&amp; str) &#x2F;&#x2F;重置流对象中字符串 字符流做什么 数据类型的转换 数据的分割 #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; stringstream stream(&quot;ILoveyou&quot;); cout &lt;&lt; stream.str() &lt;&lt; endl; char str[20] = &quot;&quot;; stream &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; stream.str(&quot;&quot;); //清除 //数据类型转换 //整数转字符串,字符串转数字 string num = to_string(123); cout &lt;&lt; num &lt;&lt; endl; int inumber = 12123; char result[20] = &#123; &quot;&quot; &#125;; stringstream buf(result); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; stringstream strNum(&quot;12345435&quot;); int dataNum = 0; strNum &gt;&gt; dataNum; cout &lt;&lt; dataNum &lt;&lt; endl; //数据切割(流中默认空格作为单一数据的间隔) stringstream ip(&quot;ip: 192.168.1.1&quot;); char strip[20] = &#123; &quot;&quot; &#125;; ip &gt;&gt; strip; //ip: 拿出来 int ipNum[4]; char userKey; ip &gt;&gt; ipNum[0]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[1]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[2]; ip &gt;&gt; userKey; ip &gt;&gt; ipNum[3]; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; ipNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; //注意点： 流在做转换的，必须调用clear清除处理 buf.clear(); buf &lt;&lt; inumber; buf &gt;&gt; result; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; 文件操作流 包含头文件: fstream ofstream: 打开文件只能写操作 ifstream: 打开文件只读操作 一般大家创建一个fstream对象，可读可写 打开文件 构造的方式,带参数构造函数：const char* URL,ios::openmode mode 成员函数方式: void open(const char* URL,ios::openmode mode) 判断文件打开是否成功 !is_open()函数判断是否打开成功 ,!is_open()是1的打开失败 !文件对象 .!对象是1打开失败 读写方式 作用 ios::in 读的方式打开文件 ios::out 写的方式打开文件 ios::app 追加写文件 ios::ate 打开已有文件，指针在文件末位 ios::trunc 文件不存在具有创建方式 ios::binary 二进制打开，默认打开方式ASCII码 ios::nocreate 不创建 ios::noreplace 不替换 组合方式: 用位或, 可读可写: ios::in|ios::out 关闭文件 close关闭文件 文件读写 直接采用&gt;&gt; &lt;&lt;符号进行读写 采用成员函数读写：read函数和write成员函数 文件指针移动 ifstream文件指针 ifstream&amp; seekg(long int pos); ifstream&amp; seekg(long int pos,ios_base::seekdir begin); ofstream文件指针 ofstream&amp; seekp(long int pos); ofstream&amp; seekp(long int pos,ios_base::seekdir begin); begin: ios::beg 开始位置 ios::cur 当前位置 ios::end 结束位置 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //采用&gt;&gt; &lt;&lt; void saveFile(string fileName) &#123; fstream file(fileName, ios::in | ios::out | ios::app); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; file &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; file.close(); &#125; void readFile(string fileName) &#123; fstream file(fileName, ios::in); if (!file) &#123; cout &lt;&lt; &quot;打开文件失败!&quot; &lt;&lt; endl; return; &#125; while (true) &#123; MM temp; file &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; if (file.eof()) &#123; break; &#125; temp.print(); &#125; file.close(); &#125; protected: string name; int age; int num; &#125;; void asciiRWFile(string readFile, string writeFile) &#123; //流的方式 //字符或者字符串的 fstream read(readFile, ios::in); fstream write(writeFile, ios::out); while (!read.eof()) &#123; char userkey = read.get(); // getline() write.put(userkey); // write()函数 &#125; read.close(); write.close(); &#125; //二进制读写 void binaryRWFile(string readFile, string writeFile) &#123; fstream r(readFile, ios::in | ios::binary); fstream w(writeFile, ios::out | ios::binary); while (!r.eof()) &#123; char str[1024] = &#123;&quot;&quot;&#125;; //缓冲区 r.read(str, 1024); w.write(str, strlen(str)); //长度写多少就写入文件多少 &#125; r.close(); w.close(); &#125; //文件指针移动 int getSize(string fileName) &#123; fstream read(fileName, ios::in | ios::binary); read.seekg(0, ios::end); int size = read.tellg(); read.close(); return size; &#125; int main(int argc, char** argv) &#123; //打开文件测试 // fstream file(&quot;xxoo.txt&quot;,ios::in|ios::out|ios::trunc); //等效下面两行 fstream file; file.open(&quot;xxoo.txt&quot;, ios::in | ios::out | ios::trunc); if (!file || !file.is_open()) &#123; cerr &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; file.close(); MM mm(&quot;xxx&quot;, 18, 1001); mm.saveFile(&quot;mm.txt&quot;); mm.readFile(&quot;mm.txt&quot;); asciiRWFile(&quot;mm.txt&quot;, &quot;xxoo.txt&quot;); binaryRWFile(&quot;xxoo.txt&quot;, &quot;rw.txt&quot;); cout &lt;&lt; &quot;size:&quot; &lt;&lt; getSize(&quot;size.txt&quot;) &lt;&lt; endl; return 0; &#125; //用write写入对象数组数据放到文件 //用read把数据读取出来，可以存储到对象数组中，打印出来 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* name, int age, int num) : age(age), num(num) &#123; strcpy(this-&gt;name, name); &#125; void writeFile(const char* fileName) &#123; fstream fread(fileName, ios::out | ios::app | ios::binary); fread.write((char*)this, sizeof(MM)); fread.close(); &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object); protected: char name[20]; int age; int num; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, const MM&amp; object) &#123; out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; &quot;\\t&quot; &lt;&lt; object.num &lt;&lt; endl; return out; &#125; void readFile(const char* fileName, MM* temp, int size) &#123; fstream fread(fileName, ios::in | ios::binary); // char str[1024] = &#123; &quot;&quot; &#125;; while (1) &#123; if (fread.eof()) break; fread.read((char*)temp, size); &#125; fread.close(); &#125; int main(int argc, char** argv) &#123; &#123; // MM array[3] = &#123; &#123;&quot;张三&quot;,18,1001&#125;,&#123;&quot;小美&quot;,28,1002&#125;,&#123;&quot;小丽&quot;,38,1003&#125; &#125;; // MM temp[3]; // readFile(&quot;mm.txt&quot;, temp, 3 * sizeof(MM)); // for (int i = 0; i &lt; 3; i++) //&#123; // cout &lt;&lt; temp[i]; //&#125; &#125; cout &lt;&lt; &quot;dsafdsfasda&quot; &lt;&lt; endl; fstream read(&quot;xx.txt&quot;, ios::in | ios::trunc | ios::_Nocreate); // ios::app: 追加方式，不能替换原文件 if (!read) &#123; cout &lt;&lt; &quot;文件打开失败!&quot; &lt;&lt; endl; return 0; &#125; read.close(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++虚函数与多态","slug":"C++虚函数与多态","date":"2022-06-03T08:04:05.000Z","updated":"2023-02-19T08:02:47.423Z","comments":true,"path":"2022/06/03/C++虚函数与多态/","link":"","permalink":"http://am900skp.github.io/2022/06/03/C++%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++虚函数与多态虚函数virtual修饰的成员函数就是虚函数 虚函数对类的内存影响:需要增加一个指针类型的内存大小 无论多少虚函数，只会增加一个指针类型的内存大小 虚函数表的概念: 指向虚函数的指针 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;第一个虚函数&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;第二个虚函数&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; sizeof(MM) &lt;&lt; endl; // 2.对类内存影响 MM mm; mm.print(); mm.printData(); int** pObject = (int**)(&amp;mm); typedef void (*PF)(); PF pf = (PF)pObject[0][0]; pf(); //调用第一个虚函数 pf = (PF)pObject[0][1]; pf(); //调用第二个虚函数 return 0; &#125; 纯虚函数具有一个或者多个纯虚函数的类型称之为抽象类，抽象类特性: 抽象类不能创建对象 抽象类可以创建对象指针 纯虚函数也是一个虚函数，需要virtual修饰，纯虚函数是没有函数体，函数&#x3D;0； #include &lt;iostream&gt; using namespace std; //抽象类 class MM &#123; public: //纯虚函数 virtual void print() = 0; protected: string name; &#125;; int main(int argc, char** argv) &#123; // MM object; 抽象类不能构建对象 MM* pMM = nullptr; return 0; &#125; 虚析构函数virtual修饰的析构函数 就是虚析构函数 当父类指针被子类对象初始化的时候需要用虚析构函数 所有析构函数底层解析其实函数名相同 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; MM* pMM = new Son; //构造子类对象，必须构造父类对象在构造自身 pMM-&gt;print(); // MM看类型 delete pMM; pMM = nullptr; return 0; &#125; 虚函数和多态多态概念: 指在继承中指针的同一行为的不同结果 实现多态的两个前提条件: 必须是public继承 必须父类存在virtual类型的成员函数,并且子类中存在该函数的同名函数 一定存在指针的引用 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void print() &#123; cout &lt;&lt; &quot;MM::print&quot; &lt;&lt; endl; &#125; virtual void printData() &#123; cout &lt;&lt; &quot;MM virtual printData&quot; &lt;&lt; endl; &#125; virtual ~MM() &#123; //虚析构函数 cout &lt;&lt; &quot;~MM&quot; &lt;&lt; endl; &#125; &#125;; class Son : public MM &#123; public: void print() &#123; cout &lt;&lt; &quot;Son::print&quot; &lt;&lt; endl; &#125; void printData() &#123; cout &lt;&lt; &quot;Son printData&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;~Son&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; //正常对象的访问，不存在多态 //都是就近原则 cout &lt;&lt; &quot;正常对象访问&quot; &lt;&lt; endl; MM mmobject; mmobject.print(); mmobject.printData(); Son sonobject; sonobject.print(); sonobject.printData(); //正常的指针访问 cout &lt;&lt; &quot;正常指针访问&quot; &lt;&lt; endl; MM* pMM = new MM; pMM-&gt;print(); pMM-&gt;printData(); Son* pSon = new Son; pSon-&gt;print(); pSon-&gt;printData(); //非正常的初始化 //父类指针被子类初始化 cout &lt;&lt; &quot;不正常的指针赋值&quot; &lt;&lt; endl; MM* pObject = new Son; pObject-&gt;print(); //没有virutal 看指针类型 调用MM::print pObject-&gt;printData(); //有virtual 看对象 调用Son::printData pObject = new MM; pObject-&gt;printData(); //调用MM中 cout &lt;&lt; &quot;引用类型&quot; &lt;&lt; endl; MM&amp; girl = sonobject; girl.print(); girl.printData(); return 0; &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: virtual void print() &#123; cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; virtual void printData() final &#123; //禁止子类重写方法 cout &lt;&lt; &quot;A&quot; &lt;&lt; endl; &#125; &#125;; // final: 父类中用来禁止子类重写同名方法 // override: 强制重写，起说明作用，表示当前子类当前方法是重写父类 class B : public A &#123; public: //重写:子类实现父类虚函数的同名函数 void print() override &#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125; // void printData()&#123;&#125; //final禁止重写 &#125;; class C : public B &#123; public: void print() &#123; cout &lt;&lt; &quot;C&quot; &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; B* pb = new C; pb-&gt;print(); //调用C::print pb = new B; pb-&gt;print(); //调用B::print return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++继承","slug":"C++继承","date":"2022-05-31T03:47:42.000Z","updated":"2023-02-19T08:02:39.906Z","comments":true,"path":"2022/05/31/C++继承/","link":"","permalink":"http://am900skp.github.io/2022/05/31/C++%E7%BB%A7%E6%89%BF/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++继承继承的实质就是父类有的属性在子类中也存在一份。只是根据继承方式不同，在子类中权限的体现不同。 继承:子类没有新的属性或者行为产生 父类 子类 派生:派生类中有新的属性产生 基类 派生类 单继承只有父类的继承称之为单继承 写法class 父类 &#123; &#125;; class 子类:继承方式 父类名 &#123; &#125;; //继承方式就是权限限定词 //公有继承: public //保护继承: protected //私有继承: private 继承中权限问题 public protected private public继承 public protected 不可访问 protected继承 protected protected 不可访问 private继承 private private 不可访问 综上: 权限限定词只会增强权限(public:最低权限 private:最高权限) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //父类 class MM &#123; public: string getName() &#123; return name; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; protected: int age = 18; private: string name = &quot;默认&quot;; &#125;; //子类 //公有继承 class Boy : public MM &#123; public: // print() void printBoy() &#123; // cout &lt;&lt; name &lt;&lt; endl; 不可能访问 cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // int age private: // string name; 不能访问 &#125;; //保护继承 class Girl : protected MM &#123; public: void printGirl() &#123; cout &lt;&lt; age &lt;&lt; endl; print(); &#125; protected: // void print() // int age; private: // string name; &#125;; //私有继承 class Son : private MM &#123; public: void printSon() &#123; print(); cout &lt;&lt; age &lt;&lt; endl; // cout &lt;&lt; name &lt;&lt; endl; // //父类的私有属性子类不能使用 只能间接调用父类的非私有方法访问 cout &lt;&lt; getName() &lt;&lt; endl; &#125; protected: private: // void print(); // int age; // string name; &#125;; int main(int argc, char** argv) &#123; Boy boy; boy.print(); boy.printBoy(); Girl girl; // girl.print(); //无法访问 girl.printGirl(); Son son; son.printSon(); return 0; &#125; 注意点: 继承的属性无论被继承多少次，都存在， A 被B继承 B被C继承 C被D继承 D包含ABC中所有属性 继承不易过多继承，导致子类臃肿 私有继承可以阻断父类属性被孙子类去使用(断子绝孙) 继承中构造函数写法 写法:子类必须先构造父类对象(子类必须调用父类的构造函数) ,调用父类的构造函数必须采用初始化参数列表 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A() &#123; cout &lt;&lt; a; &#125; A(string a) : a(a) &#123; cout &lt;&lt; a; &#125; ~A() &#123; cout &lt;&lt; a; &#125; protected: string a = &quot;A&quot;; &#125;; class B : public A &#123; public: B() &#123; //就算没写，也会调用父类的无参构造函数 cout &lt;&lt; b; &#125; //子类完整写法: 除了初始化自身数据，还需要初始化父类数据 B(string a, string b) : A(a) &#123; this-&gt;b = b; //自身属性可以采用初始化列表 cout &lt;&lt; b; &#125; void print() &#123; cout &lt;&lt; a; cout &lt;&lt; b; &#125; ~B() &#123; cout &lt;&lt; b; &#125; protected: string b = &quot;B&quot;; &#125;; class C : public B &#123; public: C(string a, string b, string c) : B(a, b), c(c) &#123; cout &lt;&lt; c; &#125; void print() &#123; cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl; &#125; ~C() &#123; cout &lt;&lt; c; &#125; protected: string c; &#125;; int main(int argc, char** argv) &#123; &#123; B b; cout &lt;&lt; endl; B object(&quot;A&quot;, &quot;B&quot;); cout &lt;&lt; endl; object.print(); cout &lt;&lt; endl; C c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); cout &lt;&lt; endl; c.print(); &#125; cout &lt;&lt; endl; &#123; cout &lt;&lt; &quot;构造和析构顺序问题:&quot; &lt;&lt; endl; C cobject(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); // ABCCBA &#125; return 0; &#125; 多继承多继承就是存在两个以及两个以上父类 权限问题和构造函数和单继承一样的 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Father &#123; public: Father(string FFName) : FFName(FFName) &#123;&#125; protected: string FFName; &#125;; class Monther &#123; public: Monther(string MFName) : MFName(MFName) &#123;&#125; protected: string MFName; &#125;; class Son : public Father, public Monther &#123; public: Son(string FFName, string MFName, string SSName) : Father(FFName), Monther(MFName) &#123; this-&gt;SFName = FFName + MFName; this-&gt;SSName = SSName; &#125; void print() &#123; cout &lt;&lt; FFName &lt;&lt; endl; cout &lt;&lt; MFName &lt;&lt; endl; cout &lt;&lt; this-&gt;SFName + this-&gt;SSName &lt;&lt; endl; &#125; protected: string SFName; string SSName; &#125;; int main(int argc, char** argv) &#123; Son son(&quot;李&quot;, &quot;田&quot;, &quot;大牛&quot;); son.print(); return 0; &#125; 菱形继承菱形继承是因为多继承存在问题而衍生的继承方式(菱形继承就是虚继承) #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A &#123; public: A(int a) : a(a) &#123;&#125; int a = 666; &#125;; class B : virtual public A &#123; public: B(int a) : A(a) &#123;&#125; &#125;; class C : virtual public A &#123; public: C(int a) : A(a) &#123;&#125; &#125;; //多继承构造顺序只和这个地方顺序(继承顺序)有关 class D : public C, public B &#123; public: //子类必须调用爷爷构造函数 D(int a) : C(14), B(12), A(a) &#123;&#125; void print() &#123; cout &lt;&lt; A::a &lt;&lt; endl; cout &lt;&lt; B::a &lt;&lt; endl; cout &lt;&lt; C::a &lt;&lt; endl; &#125; &#125;; int main(int argc, char** argv) &#123; D dobject(23); dobject.print(); return 0; &#125; 继承中同名问题 数据成员同名 成员函数同名 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name) : name(name) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;MM::name&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; class Son : public MM &#123; public: Son() : name(&quot;Son&quot;), MM(&quot;MM&quot;) &#123;&#125; void print() &#123; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son::name&quot; &lt;&lt; endl; // No.1 不写任何标识 ，就近原则 cout &lt;&lt; name &lt;&lt; endl; // No.2 可以用类名 cout &lt;&lt; MM::name &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; &#125; protected: string name; &#125;; void printInfo(MM* p) &#123; p-&gt;print(); &#125; int main(int argc, char** argv) &#123; //对象访问: // No.1 不写任何标识 ，就近原则 Son son; son.print(); son.MM::print(); son.Son::print(); MM mm(&quot;MM&quot;); mm.print(); //指针访问 //正常初始化访问 cout &lt;&lt; &quot;正常初始化指针访问&quot; &lt;&lt; endl; Son* pSon = new Son; pSon-&gt;print(); MM* pMM = new MM(&quot;MM&quot;); pMM-&gt;print(); //非正常初始化访问 // 1.1 父类指针用子类对象初始化 //在没有写任何修饰词的，看指针类型 MM* pFather = new Son; pFather-&gt;print(); //调用那个函数？ // 1.2 子类指针被父类对象初始化，危险，一般不这样做 // Son* pp = new MM(&quot;MM&quot;); //错误的 Son* pp = NULL; pp = static_cast&lt;Son*&gt;(&amp;mm); //强制类型转换类似C语言强制 // pp-&gt;print(); //程序中断，没办法执行 cout &lt;&lt; &quot;当父类指针成为函数参数时候,传参子类和父类对象通用&quot; &lt;&lt; endl; printInfo(pMM); printInfo(pSon); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++运算符重载","slug":"C++运算符重载","date":"2022-05-28T00:32:18.000Z","updated":"2023-02-19T08:02:24.598Z","comments":true,"path":"2022/05/28/C++运算符重载/","link":"","permalink":"http://am900skp.github.io/2022/05/28/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++运算符重载 运算符重载赋予运算能够操作自定义类型。 运算符重载前提条件： 必定存在一个自定义类型 运算符重载实质: 就是函数调用 友元重载 类重载 在同一自定义类型中，一个运算符只能被重载一次 C++重载只能重载已有的运算符，不能重载没有 C++重载一般情况不能违背运算符原来的含义(就算语法正确) 注意点: . ,.* ,?：，:: 不能被重载 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; protected: string name; int score; &#125;; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 // MM result = mm + girl; //错误 return 0; &#125; 重载写法重载函数的写法 //函数定义方式 函数返回值类型 函数名(参数) &#123; //函数体； &#125; //运算符重载也是函数，只是函数名写法不同 //函数名: operator加上运算符组成函数名 //参数： // 友元重载: 参数个数等于操作数 // 类成员函数: 参数个数等于操作-1 // 函数返回值类型:运算符组成表达式 最终结果是什么类型就返回类型 // int a; int b; a+b 返回int // 函数体：写你真正要实现的效果 友元重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; MM operator+(MM a, MM b) &#123; return MM(a.name, a.score + b.score); //返回一个匿名对象 &#125; int main(int argc, char** argv) &#123; int a = 1; int b = 2; int sum = a + b; MM mm(&quot;小芳&quot;, 6); MM girl(&quot;小芳&quot;, 2); // error: 没有与这些操作数匹配 &quot;xxx&quot; 运算符 //重载函数的隐式调用 --&gt;mm + girl 解析为:operator+(mm, girl) MM result = mm + girl; //显示绿色就是运算符重载 result.print(); //重载函数显示调用：按照函数的调用方式 MM res = operator+(mm, girl); // operator+:函数名 参数 // string aa(&quot;12&quot;); // string bb(&quot;2323&quot;); // cout &lt;&lt; (aa &gt; bb) &lt;&lt; endl; return 0; &#125; 类重载#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int score) : name(name), score(score) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; score &lt;&lt; endl; &#125; //友元重载 friend MM operator+(MM a, MM b); //加法重载函数的声明 protected: string name; int score; &#125;; //类成员函数少一个参数： 对象本身可以表示参数 MM MM::operator-(MM object) &#123; return MM(this-&gt;name, this-&gt;score - object.score); &#125; int main(int argc, char** argv) &#123; MM mul = mm.operator-(girl); //类重载显示调用，跟调用普通成员函数一样的 mul.print(); MM girlFriend = mm - girl; //编译器mm - girl翻译为: mm.operator-(girl) girlFriend.print(); return 0; &#125; 特殊运算符重载 通常情况:单目运算符用类成员函数重载，双目用友元重载 &#x3D; ,（）,-&gt;,[] 只能采用成员函数重载 ++ –运算符重载 增加一个无用参数，标识是后置++或者– 流运算符重载(&gt;&gt; &lt;&lt;) 输入流对象(cin): istream类 输出流对象(cout): ostream类 流重载必须用引用 流重载一定要用友元重载 后缀重载 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;thread&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; // MM operator=(MM) = delete; //删掉默认的 //函数重载 void operator=(int data) &#123; this-&gt;age += data; &#125; //++ 为例 MM operator++() &#123; //前置 this-&gt;age++; return *this; //返回对象本身 &#125; MM operator++(int) &#123; //后置的 return MM(this-&gt;name, this-&gt;age++); &#125; //流运算符的重载 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object); friend istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object); private: string name; int age; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, MM&amp; object) &#123; // out当做cout用 out &lt;&lt; object.name &lt;&lt; &quot;\\t&quot; &lt;&lt; object.age &lt;&lt; endl; return out; &#125; istream&amp; operator&gt;&gt;(istream&amp; in, MM&amp; object) &#123; cout &lt;&lt; &quot;输入对象属性:&quot;; // in当做cin用即可 in &gt;&gt; object.name &gt;&gt; object.age; return in; &#125; //文本重载, 一般写成下划线系列 //后缀的重载 unsigned long long operator&quot;&quot;_h(unsigned long long data) &#123; return data * 60 * 60; &#125; unsigned long long operator&quot;&quot;_m(unsigned long long data) &#123; return data * 60; &#125; unsigned long long operator&quot;&quot;_s(unsigned long long data) &#123; return data; &#125; int main(int argc, char** argv) &#123; MM mm(&quot;小芳&quot;, 18); MM girl; girl = mm; //每一个类中都存在默认的赋值重载 girl = 8; girl.print(); MM result = ++girl; result.print(); girl.print(); result = girl++; result.print(); girl.print(); cin &gt;&gt; girl; cout &lt;&lt; girl &lt;&lt; endl; // this_thread::sleep_for(10s); cout &lt;&lt; 1_h &lt;&lt; endl; cout &lt;&lt; (1_h + 30_m + 49_s) &lt;&lt; endl; return 0; &#125; 对象的隐式转换对象隐式转换: 就是让对象能够赋值给普通数据 // operator 转换的类型() &#123; // return 要转换类型的数据； // &#125; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) : name(name), age(age) &#123;&#125; operator int() &#123; return this-&gt;age; &#125; protected: string name; int age; &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;mm&quot;, 39); int age = mm; cout &lt;&lt; age &lt;&lt; endl; return 0; &#125; ()运算符的重载仿函数让类型可以模仿函数调用的行为： 函数名(参数)； 类名() 调用的函数行为 #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; class Data &#123; public: // operator()组成函数名 void operator()() &#123; cout &lt;&lt; &quot;无参重载()&quot; &lt;&lt; endl; &#125; void operator()(int a, int b) &#123; cout &lt;&lt; &quot;有参重载(a,b)&quot; &lt;&lt; endl; &#125; protected: &#125;; int main(int argc, char** argv) &#123; // greater&lt;int&gt;(); //比较准则 // int array[5] = &#123; 3,4,1,2,32 &#125;; // sort(array, array + 5, greater&lt;int&gt;()); // for (auto&amp; v : array) //&#123; // cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; // &#125; // cout &lt;&lt; endl; Data data; data.operator()(); //显式调用 data.operator()(1, 2); //显式调用 data(); //隐式调用 data(1, 2); //隐式调用 Data&#123;&#125;(); //&#123;&#125;帮助识别 Data() Data&#123;&#125;(2, 3); return 0; &#125; 智能指针智能指针是用对象方式管理new的内存，可以做到自动释放(本质是析构函数自动调用)内存的功能 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class Auto_Ptr &#123; public: Auto_Ptr(int* ptr) : ptr(ptr) &#123;&#125; ~Auto_Ptr() &#123; if (ptr) &#123; delete ptr; ptr = nullptr; &#125; &#125; //访问指针 int* operator-&gt;() &#123; return this-&gt;ptr; &#125; //访问数据 int&amp; operator*() &#123; return *ptr; &#125; //禁止拷贝，禁止赋值 Auto_Ptr(Auto_Ptr&amp;) = delete; Auto_Ptr&amp; operator=(Auto_Ptr&amp;) = delete; protected: int* ptr; &#125;; int main(int argc, char** argv) &#123; Auto_Ptr object(new int(1999)); cout &lt;&lt; *object &lt;&lt; endl; // shared_ptr&lt;int&gt; p(new int(19999)); // cout &lt;&lt; *p &lt;&lt; endl; // shared_ptr&lt;double&gt; p2(new double(19.99)); // cout &lt;&lt; *p2 &lt;&lt; endl; return 0; &#125; 封装数组#include &lt;iostream&gt; #include &lt;vector&gt; //动态数组 using namespace std; class my_vector &#123; public: my_vector(int capacity = 10) : capacity(capacity) &#123; mem = new int[capacity]&#123;0&#125;; curSize = 0; &#125; void push_back(int data) &#123; mem[curSize++] = data; &#125; int* begin() &#123; return mem + 0; &#125; int* end() &#123; return mem + capacity; &#125; int&amp; operator[](int index) &#123; if (curSize &lt; index) curSize = index; return mem[index]; &#125; //万金油函数 int size() &#123; return curSize; &#125; int empty() &#123; return curSize == 0; &#125; ~my_vector() &#123; if (mem) &#123; delete[] mem; mem = nullptr; &#125; &#125; protected: int* mem; int capacity; int curSize; &#125;; int main(int argc, char** argv) &#123; my_vector vec; for (int i = 0; i &lt; 3; i++) &#123; vec[i] = i; &#125; for (auto v : vec) &#123; cout &lt;&lt; v &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; vec.size() &lt;&lt; endl; for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; return 0; &#125; 迭代器实现&#x2F;&#x2F;迭代器就是让一个类中类去遍历数据 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List() : headNode(new Node), curSize(0) &#123;&#125; void push_front(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); curSize++; &#125; Node* begin() &#123; return headNode-&gt;next;上 &#125; Node* end() &#123; return nullptr; &#125; class iterator &#123; public: iterator() : pmove(nullptr) &#123;&#125; void operator=(Node* pmove) &#123; this-&gt;pmove = pmove; &#125; bool operator!=(Node* pmove) &#123; return this-&gt;pmove != pmove; &#125; iterator operator++() &#123; this-&gt;pmove = this-&gt;pmove-&gt;next; //链表++不了 return *this; &#125; int operator*() &#123; return this-&gt;pmove-&gt;data; //*运算访问数据 &#125; private: Node* pmove; //需要指针访问数据 &#125;; protected: Node* headNode; int curSize; &#125;; void my_list() &#123; List list; for (int i = 0; i &lt; 3; i++) &#123; list.push_front(i); &#125; List::iterator it; for (it = list.begin(); it != list.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; string str = &quot;ILoveyou&quot;; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl; //类中类访问一个容器数据 string::iterator it; for (it = str.begin(); it != str.end(); it++) &#123; cout &lt;&lt; *it; //*指针取值运算 &#125; cout &lt;&lt; endl; // cout &lt;&lt; *str.end() &lt;&lt; endl; my_list(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++友元","slug":"C++友元","date":"2022-05-24T10:37:54.000Z","updated":"2023-02-19T08:02:15.235Z","comments":true,"path":"2022/05/24/C++友元/","link":"","permalink":"http://am900skp.github.io/2022/05/24/C++%E5%8F%8B%E5%85%83/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++友元C++友元是用friend关键修饰的函数或者类，友元用来打破类封装(忽视权限限定) 友元并不是说直接访问数据成员，友元只是提供一个场所赋予对象具有打破权限限定 友元函数 友元类 友元函数和友元类不属于当前类，实现函数或者类不需要类名限定 友元函数 普通函数成为类的友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; void print(); //友元函数 friend void visitedData(); friend void visited(MM mm); protected: int num; private: int age; string name; &#125;; void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; //友元函数 void visitedData() &#123; // name = &quot;ILoveyou&quot;; 不是直接访问，赋予对象的具有这样权限 //创建对象的无视权限 MM mm(&quot;girl&quot;, 18, 1001); cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; MM* p = new MM(&quot;new&quot;, 28, 1002); cout &lt;&lt; p-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; p-&gt;num &lt;&lt; endl; &#125; void visited(MM mm) &#123; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM girl(&quot;girl&quot;, 19, 1002); // girl.name=&quot;name&quot;; //类外只能访问public girl.print(); visitedData(); visited(girl); return 0; &#125; 以另一个类的成员函数为友元函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //前向声明 class A; class B &#123; public: B(int b) : b(b) &#123;&#125; void printA(A object); private: int b; &#125;; class A &#123; public: A(int a) : a(a) &#123;&#125; friend void B::printA(A object); private: int a; &#125;; void B::printA(A object) &#123; cout &lt;&lt; object.a &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; B b(111); A a(222); b.printA(a); return 0; &#125; /* A以B的成员函数为友元函数， B又以A类的成员函数为友元， 如果存在这种需求， 代码设计有问题， 但是C++允许这种关系 */ 友元类#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; friend class Boy; //声明boy类是MM友元类 public: MM(string name) : name(name) &#123;&#125; private: string name; &#125;; //友元类中，MM类的对象无视权限 class Boy &#123; public: Boy() : mm(&quot;mm&quot;) &#123; pObject = new MM(&quot;Object&quot;); &#125; void print() &#123; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; mm.name &lt;&lt; endl; cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pObject-&gt;name &lt;&lt; endl; MM* pMM = new MM(&quot;new&quot;); cout &lt;&lt; &quot;访问私有属性:&quot; &lt;&lt; pMM-&gt;name &lt;&lt; endl; &#125; private: MM mm; MM* pObject; &#125;; class A &#123; public: friend class B; void printA(); private: string a_name = &quot;A&quot;; &#125;; class B &#123; public: friend class A; void printB() &#123; A a; cout &lt;&lt; a.a_name &lt;&lt; endl; &#125; private: string b_name = &quot;B&quot;; &#125;; void A::printA() &#123; B b; cout &lt;&lt; b.b_name &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; Boy boy; boy.print(); B b; b.printB(); A a; a.printA(); return 0; &#125; 顺便介绍一下C++的强制类型转换#include &lt;iostream&gt; using namespace std; int main(int argc, char** argv) &#123; int num = 1.11; cout &lt;&lt; num &lt;&lt; endl; int cnum = (int)1.11; cout &lt;&lt; cnum &lt;&lt; endl; int cppnum = int(1.22); // C++强制类型转换 cout &lt;&lt; cppnum &lt;&lt; endl; return 0; &#125; static_cast类型转换类似C语言的强制类型转换，按照C++的说法 比C语言的更为安全 基本数据类型的强制转换 空指针转换目标类型指针 不能操作带const属性的类型 // static_cast&lt;要转换的类型&gt;(要转换目标) //要转换的类型: 数据类型 //要转换目标 可以是表达式，或者常量，都可以 #include &lt;iostream&gt; using namespace std; void test_static_cast() &#123; // No.1 基本数据类型的强制转换 int num = static_cast&lt;int&gt;(1.111); // No.2 空类型指针的转换 double* pD = new double(1.11); void* pVoid = static_cast&lt;void*&gt;(pD); // No.3 不能做const属性的类型的转换 //增加const属性 //不能去掉const属性 int number = 11; const int cNum = static_cast&lt;const int&gt;(number); const int ccNum = number; const int data = 1; int* pData = (int*)(&amp;data); // C语言强制类型转换 // int* pcData = static_cast&lt;int*&gt;(&amp;data); //错误 &#125; int main(int argc, char** argv) &#123; test_static_cast(); return 0; &#125; const_cast类型转换 去掉const属性(提供一个可以修改接口去操作const数据类型) 加上const属性(用的少一点) #include &lt;iostream&gt; using namespace std; class Str &#123; public: // 1.去掉const属性 Str(const char* str) : str(const_cast&lt;char*&gt;(str)) &#123;&#125; void print() &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; private: char* str; &#125;; class Test &#123; public: void print() &#123; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; private: &#125;; void printTest(const Test&amp; object) &#123; Test&amp; m_test = const_cast&lt;Test&amp;&gt;(object); m_test.print(); &#125; void test_const_cast() &#123; // 2.增加const属性 const int data = 1; int* pData = const_cast&lt;int*&gt;(&amp;data); *pData = 1001; //不会作用到const变量，只是单纯提供一个接口 cout &lt;&lt; &quot;data:&quot; &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; &quot;*pData:&quot; &lt;&lt; *pData &lt;&lt; endl; cout &lt;&lt; &amp;data &lt;&lt; endl; cout &lt;&lt; pData &lt;&lt; endl; Str str(&quot;ILoveyou&quot;); //错误，C++对于const要求更为严格 str.print(); char sstr[20] = &quot;ILoveyoud&quot;; Str str2(sstr); str2.print(); // 3.引用类型 Test test; test.print(); const Test&amp; c_test = test; // c_test.print(); //常属性的对象只能调用常成员函数 Test&amp; m_test = const_cast&lt;Test&amp;&gt;(c_test); m_test.print(); &#125; int main(int argc, char** argv) &#123; test_const_cast(); return 0; &#125; reinterpreat_cast类型转换把指针转换为一个整数，又可以把整数转换为一个指针，指针的效果依然有效 #include &lt;iostream&gt; using namespace std; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; //官方案例 unsigned short Hash(void* p) &#123; unsigned int val = reinterpret_cast&lt;unsigned int&gt;(p); return (unsigned short)(val ^ (val &gt;&gt; 16)); &#125; void test_reinterpret_cast() &#123; int* p = reinterpret_cast&lt;int*&gt;(0); // p=nullptr; //官方案例 int a[20]; for (int i = 0; i &lt; 20; i++) cout &lt;&lt; Hash(a + i) &lt;&lt; endl; //允许将任何指针转换为任何其他指针类型。 //也允许将任何整数类型转换为任何指针类型以及反向转换 int* num = reinterpret_cast&lt;int*&gt;(Max); //把函数地址转换为int类型的数字 cout &lt;&lt; *num &lt;&lt; endl; auto pMax = reinterpret_cast&lt;int (*)(int, int)&gt;(num); cout &lt;&lt; &quot;max:&quot; &lt;&lt; pMax(1, 2) &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; test_reinterpret_cast(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++构造与析构","slug":"C++构造与析构","date":"2022-05-22T05:17:08.000Z","updated":"2023-02-19T08:01:52.352Z","comments":true,"path":"2022/05/22/C++构造与析构/","link":"","permalink":"http://am900skp.github.io/2022/05/22/C++%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++构造和析构构造函数 名字和类名相同 没有返回值 构造函数是用来构造对象，构造对象时候必定调用构造函数 不写构造函数，存在一个默认的构造函数，默认的构造函数是无参，所以可以构造无参对象 默认的构造函数可以删掉，通过delete删除默认的构造函数 显示使用默认的构造函数, 通过default做显示调用 通常情况构造函数是public属性 自己写了构造函数，默认的构造函数就不存在了 构造函数决定对象的长相(构造函数无参，对象无参，构造有一个，对象必须也要一个参数) 构造函数通常做的事情，就是给数据成员初始化 构造函数也是函数，所以也可以重载，也可以缺省 通过重载和缺省，实现构造不同长相对象 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: // MM() = default; //显式使用默认的构造函数 // MM() = delete; //删掉默认的构造函数 MM(string name, int age) &#123; m_name = name; m_age = age; cout &lt;&lt; &quot;两个参数的构造函数&quot; &lt;&lt; endl; &#125; MM() = default; //默认无参构造函数，据说速度更快 void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; // MM::MM() //&#123; // cout &lt;&lt; &quot;调用无参构造函数&quot; &lt;&lt; endl; // &#125; struct Boy &#123; string name; int age; int num; //一旦C++结构体中写了构造函数，必须当做类去操作，不能用C语言的那种方式使用 Boy() &#123;&#125; Boy(string bname, int bage) &#123; name = bname; age = bage; &#125; &#125;; void testStruct() &#123; // Boy boy = &#123; &quot;string&quot;,18,1001&#125;; //错误 //这个地方也是创建对象过程，所以数据也需要和构造函数 Boy boy = &#123;&quot;string&quot;, 18&#125;; //这里数据必须和构造函数的一致 Boy boy2; Boy array[3]; &#125; int main(int argc, char** argv) &#123; // MM mm; // //因为构造函数有两个参数，对象也必须带有两参数 MM mm(&quot;对象&quot;, 18); //这步创建对象的过程就是调用构造函数构造函数的过程 mm.printMM(); MM empty; //调用无参构造函数 // new一个对象 MM* p = new MM; //调用无参的构造函数 MM* p2 = new MM(&quot;对象&quot;, 29); //调用有参的构造函数 return 0; &#125; 析构函数 ~类名 当做析构函数名字 没有参数 释放数据成员new的内存 在对象死亡前自动调用 通常如果数据成员没有做new操作，就可以不写析构函数 不写析构函数，存在一个默认的析构函数 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(const char* str =&quot;ILoveyou&quot;) &#123; //缺省,相当于存在两个构造函数，一个是无参的，一个是有参 int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; ~MM(); protected: char* name; &#125;; MM::~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; cout &lt;&lt; &quot;析构函数....\\n&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; &#123; MM mm; MM* p = new MM; cout &lt;&lt; &quot;1......&quot; &lt;&lt; endl; delete p; //立刻调用析构函数 p = nullptr; cout &lt;&lt; &quot;2.......&quot; &lt;&lt; endl; &#125; &#123; MM beauty(&quot;Continue&quot;); &#125; cout &lt;&lt; &quot;对象死亡&quot; &lt;&lt; endl; return 0; &#125; 拷贝构造函数 拷贝构造函数也是构造函数 拷贝构造函数参数是固定的:对对象的引用 拷贝构造函数不写会存在一个默认的拷贝构造函数 拷贝构造函数作用： 通过一个对象产生另一个对象 关键点：一定是有一个新的对象产生 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; MM(MM&amp; object); void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; protected: string m_name; int m_age; &#125;; //拷贝构造函数 //通过传入对象属性确定创建对象的属性 MM::MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用自己写的拷贝构造函数&quot; &lt;&lt; endl; &#125; //函数传参也可以隐式调用 void print(MM object) &#123; // MM object=girl object.printMM(); &#125; // C++中传参能用引用就用，效率搞 void printData(MM&amp; object) &#123; //引用就是别名，没有产生新的对象 object.printMM(); &#125; int main(int argc, char** argv) &#123; MM mm(&quot;C神&quot;, 18); //产生一个对象 MM beauty = mm; //隐式调用拷贝构造函数 MM girl(beauty); //显式调用拷贝构造函数 print(girl); //调用拷贝构造函数 printData(girl); MM boy; //对象先有了，才赋值，不调用拷贝 boy = girl; //不调用拷贝构造函数--&gt;默认重载=运算符(后续会详细阐述) return 0; &#125; 深浅拷贝问题浅拷贝 没有在拷贝构造函数中给数据成员做new操作 默认拷贝构造函数都是浅拷贝 深拷贝 在拷贝构造函数中做了new操作 浅拷贝导致内存释放问题浅拷贝会导致同一段内存重复释放问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; // MM(MM&amp; object) &#123; // name = object.name; // &#125; ~MM() &#123; if (name != nullptr) &#123; //浅拷贝导致内存释放问题 //浅拷贝会导致同一段内存重复释放问题 //两个指针都指向同一段内存 delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 深拷贝解决方案#include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM() &#123;&#125; MM(const char* str) &#123; int length = strlen(str) + 1; name = new char[length]; strcpy(name, str); &#125; MM(MM&amp; object) &#123; // name = object.name; int length = strlen(object.name) + 1; name = new char[length]; strcpy(name, object.name); &#125; ~MM() &#123; if (name != nullptr) &#123; delete[] name; name = nullptr; &#125; &#125; private: char* name; &#125;; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;); MM mm = girl; //调用拷贝构造函数 &#125; return 0; &#125; 综上： 一旦类中有指针，做了内存申请，并且要对对象做拷贝操作，就必须使用深拷贝 匿名对象匿名对象就是无名对象，匿名对象只能充当右值，所以匿名对象拷贝必须存在移动拷贝，或者准备一个ecosnt限定普通拷贝构造函数。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: MM()&#123;&#125;; MM(string name, int age) &#123; m_name = name; m_age = age; &#125; void printMM() &#123; cout &lt;&lt; m_name &lt;&lt; &quot;\\t&quot; &lt;&lt; m_age &lt;&lt; endl; &#125; MM(MM&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; &#125; //移动构造---&gt;新标准的 MM(MM&amp;&amp; object) &#123; m_name = object.m_name; m_age = object.m_age; cout &lt;&lt; &quot;调用移动构造&quot; &lt;&lt; endl; &#125; ~MM() &#123; cout &lt;&lt; &quot;析构打印name:&quot; &lt;&lt; m_name &lt;&lt; endl; &#125; private: string m_name; int m_age; &#125;; MM returnMM(string name, int age) &#123; return MM(name, age); //构造一个匿名对象当做函数返回值 &#125; int main(int argc, char** argv) &#123; &#123; MM girl(&quot;girl&quot;, 19); //匿名对象是一个右值 MM mm = MM(&quot;mm&quot;, 29); //匿名对象 ---&gt;匿名对象转正 ，mm接管所有权 cout &lt;&lt; &quot;匿名对象已死亡&quot; &lt;&lt; endl; &#125; MM beauty = returnMM(&quot;返回值&quot;, 18); beauty.printMM(); return 0; &#125; 构造和析构顺序问题 一般情况构造顺序和析构是相反的 静态的和全局的是最后释放的 delete 立刻调用析构函数 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Test &#123; public: Test(string data = &quot;A&quot;) &#123; m_data = data; cout &lt;&lt; m_data; &#125; ~Test() &#123; cout &lt;&lt; m_data; &#125; protected: string m_data; &#125;; int main(int argc, char** argv) &#123; &#123; Test t1; // A static Test t2(&quot;B&quot;); // B Test array[3]; // AAA //数组就是多个无参 Test* p = new Test(&quot;C&quot;); // C delete p; // C p = nullptr; &#125; // ABAAACCAAAAB return 0; &#125; //用构造函数的方式简单实现单链表 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; Node* next; Node() : next(nullptr) &#123;&#125; Node(int data) : data(data), next(nullptr) &#123;&#125; Node(int data, Node* next) : data(data), next(next) &#123;&#125; &#125;; class List &#123; public: List(); void insertData(int data); void printList() &#123; Node* pmove = headNode-&gt;next; while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;data &lt;&lt; &quot; &quot;; pmove = pmove-&gt;next; &#125; cout &lt;&lt; endl; &#125; private: Node* headNode; &#125;; List::List() &#123; headNode = new Node; &#125; void List::insertData(int data) &#123; headNode-&gt;next = new Node(data, headNode-&gt;next); &#125; int main(int argc, char** argv) &#123; List list; list.insertData(1); list.insertData(2); list.insertData(3); list.printList(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++特殊成员","slug":"C++特殊成员","date":"2022-05-19T13:07:35.000Z","updated":"2023-02-09T11:45:03.093Z","comments":true,"path":"2022/05/19/C++特殊成员/","link":"","permalink":"http://am900skp.github.io/2022/05/19/C++%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++特殊成员const成员 const修饰的数据成员 初始化必须采用初始化参数列表 不能被修改 构造函数必须要初始化常数据成员 const修饰的成员函数 写法上要注意: const修饰是写在函数后面 const成员函数不能修改任何的数据成员 如果实在是要在常成员函数中修改该数据，用mutable修饰数据成员即可 常成员函数可以普通函数同时存在 const对象 const修饰的对象 常对象只能调用常成员函数 #include &lt;iostream&gt; using namespace std; class MM &#123; public: MM(int age) : name(&quot;小芳&quot;), num(4323) &#123; this-&gt;age = age; &#125; MM(string name, int age, int num) : name(name), age(age), num(num) &#123;&#125; // MM() &#123;&#125; 常数据必须要初始化，错误 // MM() = default; //正确，可以构造无参对象 void print() &#123; age = 18; // num = 11; //不能修改常数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl; &#125; //常成员函数： const写在函数后面 void print() const &#123; cout &lt;&lt; this-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;age &lt;&lt; endl; cout &lt;&lt; &quot;常成员函数&quot; &lt;&lt; endl; &#125; void printData() const &#123; // age = 23; //常成员函数，不能修改数据成员 cout &lt;&lt; this-&gt;name &lt;&lt; this-&gt;num &lt;&lt; this-&gt;age &lt;&lt; endl; &#125; void test() &#123;&#125; protected: //常数据成员 const string name; const int num; int age; // mutable 可修改的意思 &#125;; int main(int argc, char** argv) &#123; MM mm(&quot;小丽&quot;, 18, 1001); //如果普通函数和常成员函数同名 mm.print(); //普通对象优先调用普通函数 const MM object(18); object.print(); //常对象只能调用常成员函数 object.printData(); // object.test(); // //错误，常对象只能调用常成员函数 return 0; &#125; static成员static成员不属于某一个单独对象，是属于类的，通俗一点讲，是所有对象的共享的，static成员依然受权限 satic成员他的访问可以不需要对象(用类名限定的方式去访问) static数据成员 初始化必须在类外初始化 类实现的时候不需要用static修饰了 static成员函数 static写在修饰函数的前面 类外实现也不需要static修饰 静态函数中没有this指针 静态成员函数的访问问题 静态成员函数访问静态成员 是可以直接访问 静态成员函数访问非静态数据成员，必须通过指定对象的方式 静态成员函数传参 在静态成员函数定义对象去访问 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class User &#123; public: User(string name = &quot;默认&quot;) &#123; this-&gt;count++; //类中访问 this-&gt;m_count++; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl; &#125; // void test() &#123;&#125; 不能和普通函数形参重载效果，会造成重定义问题 public: static void test(); static void testData(User&amp; object); private: string name; public: static int count; int m_count = 0; &#125;; //必须在类外面做初始化，不需要static修饰了 int User::count = 0; void User::test() &#123; cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; // cout &lt;&lt; &quot;m_count:&quot; &lt;&lt; m_count &lt;&lt; endl; // //静态成员函数中不能直接调用非静态成员 cout &lt;&lt; &quot;静态函数&quot; &lt;&lt; endl; &#125; void User::testData(User&amp; object) &#123; cout &lt;&lt; object.m_count &lt;&lt; endl; //传参 User mm; cout &lt;&lt; mm.m_count &lt;&lt; endl; //创建对象 &#125; int main(int argc, char** argv) &#123; cout &lt;&lt; User::count &lt;&lt; endl; // static 成员访问不需要对象 User object[3]; cout &lt;&lt; User::count &lt;&lt; endl; User mm; cout &lt;&lt; mm.count &lt;&lt; endl; cout &lt;&lt; User::count &lt;&lt; endl; //可以用类名访问，前提是权限没问题 cout &lt;&lt; mm.m_count &lt;&lt; endl; //不能用类名 User::test(); //因为存在这种调用，所以静态成员函数中不能存在this指针 mm.test(); return 0; &#125; 顺便介绍一下多文件的写法(Google) 一个类一个模块 声明写在.h 实现写在.cpp 声明和试下写在一起 .hpp 头文件包含尽量在.cpp完成 设计项目时候，头文件形成交叉包含，说明思想有问题，自己重新设计代码 不要为了拆分而拆分 静态数据成员多文件写法","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++类和对象","slug":"C++类和对象","date":"2022-05-19T03:58:16.000Z","updated":"2023-02-19T08:01:35.652Z","comments":true,"path":"2022/05/19/C++类和对象/","link":"","permalink":"http://am900skp.github.io/2022/05/19/C++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++类和对象初识类的创建 类和结构体区别 在没写构造函数之前，C语言结构体就按照C语言的方式用即可 用了构造函数时候，结构体直接当做C++类去使用 结构体其实可以当做一个默认权限是公有属性的类 C++是允许空类和结构体存在 class 类名 &#123; //默认为私有属性 //..... public: //类外只能访问公有属性 //....公有属性 //公有函数---&gt;类外的公有接口 protected: //....保护属性 private: //....私有属性 &#125;; //保护和私有属性区别，暂时不需要知道，后续讲继承的时候会讲 //类中没有权限可言 创建类完整代码class MM &#123; public: void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); protected: private: //一般数据成员写：私有属性 string name; int age; int num; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; 结构体和类的区别// C++类和对象 #include &lt;iostream&gt; using namespace std; class MM &#123; int num; //类中默认的是私有属性 public: int age; private: string name; &#125;; struct Boy &#123; //结构体中默认的公有属性 int num; int age; private: string name; &#125;; // C语言是不能写空的结构体 // C++允许空结构体或者类 struct Empty &#123; //占用内存不是0 是1(标记),写了数据这个标记就不存在 &#125; m; //作用:泛型编程做参数包解析的递归循环终止处理 int main(int argc, char** argv) &#123; struct Boy boy; // boy.num = 1001; // boy.age = 12; MM mm; mm.age = 19; cout &lt;&lt; sizeof(Empty) &lt;&lt; endl; cout &lt;&lt; sizeof(Boy) &lt;&lt; endl; return 0; &#125; 对象创建和初始化对象创建 创建普通对象 创建对象数组 创建对象指针 对象的初始化 类中直接给数据赋值 提供一个共有接口去操作数据 提供一个返回引用的接口 完整代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void printData() &#123; //普通成员函数只是写在类中，不占对象内存 cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; void print(); void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; int&amp; getNum() &#123; return num; &#125; protected: private: //一般数据成员写：私有属性 string name = &quot;默认值&quot;; int age = 0; int num = 0; &#125;; //在类外实现类中的函数，必须要用类名限定(类名::函数名) void MM::print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM mm; //创建对象 MM array[3]; MM* pMM; pMM = &amp;mm; pMM = new MM; // new一个对象 // new一个对象过程 // 1.创建一个匿名对象(没有名字的对象) // 2.把匿名对象的首地址赋值指针 pMM-&gt;print(); pMM-&gt;printData(); // pMM-&gt;name = &quot;小芳&quot;; 不可访问，类外不能访问public之外的所有属性 cout &lt;&lt; &quot;通过提供共有接口传参的方式初始化对象的数据&quot; &lt;&lt; endl; mm.initData(&quot;小芳&quot;, 18, 1001); mm.printData(); cout &lt;&lt; &quot;返回引用的去访问数据&quot; &lt;&lt; endl; MM* p = new MM; p-&gt;getName() = &quot;MM&quot;; p-&gt;getAge() = 28; p-&gt;getNum() = 1004; p-&gt;printData(); return 0; &#125; 成员的访问 类中普通数据成员和成员函数必须通过对象去访问 只有两种方案 普通对象: 用 对象.成员访问 对象指针:用 对象指针-&gt;成员 案例代码#include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class MM &#123; public: void initData(string mmName, int mmAge, int mmNum) &#123; name = mmName; age = mmAge; num = mmNum; &#125; //不想让别人直接修改数据，不要返回引用，只能看不能操作 string getName() &#123; return name; &#125; int getAge() &#123; return age; &#125; int getNum() &#123; return num; &#125; private: string name; int age; int num; &#125;; void testObject() &#123; MM mm; mm.initData(&quot;小芳&quot;, 19, 1002); cout &lt;&lt; mm.getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.getNum() &lt;&lt; endl; // IMAGE img; // img.getwidth(); // img.getheight(); &#125; void testObjectPoint() &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;小丽&quot;, 29, 1004); cout &lt;&lt; pMM-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;getNum() &lt;&lt; endl; &#125; void testArray() &#123; MM array[3]; for (int i = 0; i &lt; 3; i++) &#123; string name = &quot;name&quot; + to_string(i); //iomanip array[i].initData(name, 18 + i, 1002 + i); cout &lt;&lt; (array + i)-&gt;getName() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getAge() &lt;&lt; &quot;\\t&quot; &lt;&lt; (array + i)-&gt;getNum() &lt;&lt; endl; &#125; &#125; int main(int argc, char** argv) &#123; // age = 123; 不能直接访问 testObject(); testObjectPoint(); testArray(); return 0; &#125; 类和对象的其他操作类中含有指针问题含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 // 含有指针的处理方案和C语言的结构体中含有指针的处理方案是一样的，相对于C语言来说多了权限问题 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; class MM &#123; public: void initData(const char* mmName, int mmAge); void initMM(const char* mmName, int mmAge); void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; char*&amp; getName() &#123; return name; &#125; protected: char* name; int age; &#125;; //一般不采用这种方案处理,诟病很大 void MM::initData(const char* mmName, int mmAge) &#123; name = (char*)mmName; age = mmAge; &#125; void MM::initMM(const char* mmName, int mmAge) &#123; name = new char[strlen(mmName) + 1]; strcpy(name, mmName); age = mmAge; &#125; void printConst(const char* str) &#123; //传入常量和变量 传参const修饰 cout &lt;&lt; str &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; MM* pMM = new MM; pMM-&gt;initData(&quot;张三&quot;, 19); pMM-&gt;print(); // strcpy(pMM-&gt;getName(), &quot;ILoveyou&quot;); // // 百分百有问题，name没有指向一段可操作内存 char str[10] = &quot;ILoveyou&quot;; // C++const要求更为严格，尤其是字符串处理 printConst(&quot;ILoveyou&quot;); printConst(str); pMM-&gt;getName() = str; pMM-&gt;print(); MM* p = new MM; p-&gt;initMM(&quot;ILoveyou&quot;, 20); p-&gt;print(); strcpy(p-&gt;getName(), &quot;IMiss&quot;); p-&gt;print(); return 0; &#125; 类不能直接包含自身的对象只能包含自身指针不能包含自身对象 class Boy &#123; public: //Boy boy; 错误代码 Boy* pBoy; //指针正确 &#125;; 成员函数指针调用成员函数#include &lt;iostream&gt; using namespace std; class Test &#123; public: void print(string info) &#123; cout &lt;&lt; info &lt;&lt; endl; &#125; &#125;; void testFunc() &#123; Test test; // void (*Func)(string) = nullptr; // Func = &amp;Test::print; 错误写法，类型 // 1.auto自动推断出类成员函数指针类型 auto Funcf = &amp;Test::print; //没问题 (test.*Funcf)(&quot;测试函数&quot;); //调用还是要学会 Test testb; (testb.*Funcf)(&quot;测试函数2&quot;); testb.print(&quot;直接调用&quot;); // 2.正规写一下正常写法 //不是简单的用*指针名替换函数，而是要加上类名限定 void (Test::*Func)(string) = nullptr; Func = &amp;Test::print; //类中所有东西，无论怎么访问，必须类名限定 (test.*Func)(&quot;类成员函数指针访问成员函数&quot;); &#125; int main(int argc, char** argv) &#123; testFunc(); return 0; &#125; 对象本质 对象的本质就是一个数据,只是数据包含操作 因为对象的本质是一个数据，所以变量能做的，它都可以 当做函数参数 当做函数返回值 当做另一个结构体数据成员 当做另一个类的数据成员 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Student &#123; public: void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; endl; &#125; string&amp; getName() &#123; return name; &#125; int&amp; getAge() &#123; return age; &#125; protected: string name; int age; &#125;; void printData(Student student) &#123; student.print(); &#125; //子函数修改实参，C语言传入实参地址，C++传引用 void modifyStudent(Student&amp; stu) &#123; stu.getName() = &quot;Memory&quot;; stu.getAge() = 28; &#125; Student* createStu(string name, int age) &#123; Student* p = new Student; p-&gt;getName() = name; p-&gt;getAge() = age; return p; &#125; void testStudent() &#123; Student stu; modifyStudent(stu); printData(stu); Student* p = createStu(&quot;C++&quot;, 19); p-&gt;print(); Student temp = *p; temp.print(); //除了赋值之外，其他运算不能直接做 // Student temp1 = temp + temp; //算术+条件 &#125; int main(int argc, char** argv) &#123; testStudent(); return 0; &#125; // C++的方式简单实现链表操作 #include &lt;iostream&gt; using namespace std; struct Node &#123; int data; struct Node* p_next; &#125;; class List &#123; public: void Initlist(); Node* CreateNode(int new_data); void InsertNode(int new_data); void DeleteNodeByPosData(int pos_data); void PrintList(); protected: Node* p_head_node; //表头 int cur_size; //链表中结点个数 &#125;; void List::Initlist() &#123; p_head_node = new Node; p_head_node-&gt;p_next = nullptr; cur_size = 0; &#125; Node* List::CreateNode(int new_data) &#123; Node* p_new_node = new Node; p_new_node-&gt;data = new_data; p_new_node-&gt;p_next = nullptr; return p_new_node; &#125; void List::InsertNode(int new_data) &#123; Node* p_new_node = CreateNode(new_data); p_new_node-&gt;p_next = p_head_node-&gt;p_next; p_head_node-&gt;p_next = p_new_node; cur_size++; &#125; void List::DeleteNodeByPosData(int pos_data) &#123; Node* p_pre_node = p_head_node; Node* p_cur_node = p_head_node-&gt;p_next; while (p_cur_node != nullptr &amp;&amp; p_cur_node-&gt;data != pos_data) &#123; p_pre_node = p_cur_node; p_cur_node = p_pre_node-&gt;p_next; &#125; if (p_cur_node == nullptr) &#123; cout &lt;&lt; &quot;没有找到指定位置&quot; &lt;&lt; endl; &#125; else &#123; p_pre_node-&gt;p_next = p_cur_node-&gt;p_next; delete p_cur_node; p_cur_node = nullptr; &#125; &#125; void List::PrintList() &#123; Node* p_move = p_head_node-&gt;p_next; while (p_move != nullptr) &#123; cout &lt;&lt; p_move-&gt;data; p_move = p_move-&gt;p_next; &#125; cout &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; List* p_list = new List; p_list-&gt;Initlist(); for (int i = 0; i &lt; 3; ++i) &#123; p_list-&gt;InsertNode(i); &#125; p_list-&gt;PrintList(); p_list-&gt;DeleteNodeByPosData(1); p_list-&gt;PrintList(); return 0; &#125; 结点和链表都用类#include &lt;iostream&gt; using namespace std; class Node &#123; public: int&amp; getData() &#123; return data; &#125; struct Node*&amp; getNext() &#123; return next; &#125; protected: int data; struct Node* next; &#125;; class List &#123; public: void initList(); void insertData(int data); void printData(); void deleteNode(int posData); protected: Node* headNode; //表示表头 int curSize; //当前节点个数 &#125;; void List::initList() &#123; headNode = new Node; headNode-&gt;getNext() = nullptr; curSize = 0; &#125; void List::insertData(int data) &#123; //创建新节点 Node* newNode = new Node; newNode-&gt;getData() = data; newNode-&gt;getNext() = nullptr; //表头插入链接 newNode-&gt;getNext() = headNode-&gt;getNext(); headNode-&gt;getNext() = newNode; curSize++; &#125; void List::printData() &#123; Node* pmove = headNode-&gt;getNext(); while (pmove != nullptr) &#123; cout &lt;&lt; pmove-&gt;getData() &lt;&lt; &quot; &quot;; pmove = pmove-&gt;getNext(); &#125; cout &lt;&lt; endl; &#125; void List::deleteNode(int posData) &#123; Node* preNode = headNode; Node* curPos = headNode-&gt;getNext(); while (curPos != nullptr &amp;&amp; curPos-&gt;getData() != posData) &#123; preNode = curPos; curPos = preNode-&gt;getNext(); &#125; if (curPos == nullptr) &#123; cout &lt;&lt; &quot;没有找到无法做指定位置删除...&quot; &lt;&lt; endl; &#125; else &#123; preNode-&gt;getNext() = curPos-&gt;getNext(); delete curPos; curPos = nullptr; &#125; &#125; int main(int argc, char** argv) &#123; List* p = new List; p-&gt;initList(); for (int i = 0; i &lt; 3; i++) &#123; p-&gt;insertData(i); &#125; p-&gt;printData(); p-&gt;deleteNode(1); p-&gt;printData(); return 0; &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"C++和C的区别","slug":"C++和C的区别","date":"2022-05-15T07:24:31.000Z","updated":"2023-02-09T11:45:04.834Z","comments":true,"path":"2022/05/15/C++和C的区别/","link":"","permalink":"http://am900skp.github.io/2022/05/15/C++%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"参考书籍: C++ Primer Essential C++ 编译器: gcc &#x2F; g++ C++和C的区别头文件包含问题#include &lt;iostream&gt; //不需要.h 直接包含 int main(int argc, char** argv) &#123; return 0; &#125; 创建的项目源文件是.cpp 头文件的包含不同 不需要.h 直接包含 C语言的标准库头文件 依然按照原来方式包含，一定程序C++兼容C语言 C++包含方式: c+原来的头文件，去掉.h #include &lt;ctime&gt; 完整代码#include &lt;stdio.h&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &quot;myhead.h&quot; //自己写的依旧是按照原来方式 int main(int argc, char** argv) &#123; printf(&quot;C语言的函数！\\n&quot;); return 0; &#125; C++命名空间什么是命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; // namespace 空间名 //用namespace 声明一个东西 可以提高标识符使用，可以避免命名污染 如何创建命名空间namespace 空间名 &#123; //变量 //函数 //结构体 //类 &#125; //用namespace 声明一个东西 怎么访问命名空间 :: :作用域分辨符 访问空间中的成员: 空间名::成员名 用来区分全局变量和局部变量 ::全局变量 #include &lt;cstdio&gt; #include &lt;iostream&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; // namespace MM namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); return 0; &#125; 省略前缀的方式去调用 //using namespace 空间名; //要省略的空间名 //注意点：有作用域 #include &lt;iostream&gt; #include &lt;cstdio&gt; namespace MM &#123; int age = 1; void print() &#123; printf(&quot;MM\\n&quot;); &#125; &#125; namespace Boy &#123; int age = 2; &#125; int g_num = 1001; int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, MM::age); printf(&quot;%d\\n&quot;, Boy::age); int g_num = 1; printf(&quot;全局变量:%d\\n&quot;, ::g_num); MM::print(); using namespace MM; //省略前缀的调用方式 print(); using namespace Boy; //printf(&quot;%d\\n&quot;, age); //二义性问题：有两个选择，不知道找谁 printf(&quot;%d\\n&quot;, Boy::age); printf(&quot;%d\\n&quot;, MM::age); return 0; &#125; 命名空间嵌套namespace A &#123; int a=1; namespace B &#123; int b = 1; &#125; &#125; void test() &#123; //剥洋葱 A::a = 1; A::B::b = 2; using namespace A::B; b = 3; &#125; 先声明后实现//其他写法： 先声明后实现的一种写法 namespace Data &#123; void print(); struct student; &#125; //必须空间名限定 void Data::print() &#123; &#125; struct Data::student &#123; int age; int num; &#125;; 标准的命名空间std C++所有的函数和类都是属于标准命名空间 不写using namespace std; 意味着所有C++标准库中的东西都需要加上std:: using namespace std; //习惯性的操作 C++函数新思想函数重载什么是函数重载C++允许同名不同参数的函数存在，C语言不允许同名函数存在 不同参数的三个体现 数目不同 类型不同 顺序不同：前提条件是存在不同类型 #include &lt;iostream&gt; using namespace std; //类型不同 int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; float Max(float a, float b) &#123; return a &gt; b ? a : b; &#125; //顺序不同 // error C2084: 函数“int Max(int,int)”已有主体 // int Max(int b, int a) //&#123; // //&#125; void print(int a, char c) &#123;&#125; void print(char a, int c) &#123;&#125; //数目不同 void print(int a, int b, int c) &#123;&#125; //想当然了 // double就是末尾加个d 错误的 // char就是加个c嘛 错误的 int main(int argc, char** argv) &#123; printf(&quot;%d\\n&quot;, Max(1, 2)); printf(&quot;%.1f\\n&quot;, Max(1.1f, 2.2f)); //错误，C++对于类型要求比C语言严格 1L; // long 1.1f; // float 1u; // unsiged; //默认的小数是double; return 0; &#125; 函数重载和函数返回值一点毛线关系都没有。 函数缺省什么是函数缺省函数缺省就是给形参赋初始值，当不传参的时候使用的是默认值 函数缺省规则 只能从右往左缺省，中间不能有空着的 多文件中，.h文件缺省了，cpp不需要缺省(声明做了缺省，实现就不需要缺省) 缺省的好处实现函数的不同形态的调用，针对不同需求做不同实现 #include &lt;iostream&gt; using namespace std; //函数缺省 void printData(int a = 1, float b = 1.11f, double c = 1.11, char d = &#39;A&#39;) &#123; printf(&quot;%d\\t%f\\t%lf\\t%c\\n&quot;, a, b, c, d); &#125; int main(int argc, char** argv) &#123; printData(); //所有形参都是默认值 printData(9); // a=9,其他值用默认值 printData(9, 2.22f); // a=9 b=2.22 其他默认值 printData(9, 2.22f, 9.9); // a=9,b=2.22 c=9.9 其他默认值 printData(9, 2.22f, 9.9, &#39;D&#39;); //所有的值用的是传入的值 return 0; &#125; C++标准输入和输出标准输出 cout + &lt;&lt; 一起完成的 换行: endl替换”\\n” #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; //单个数据输出 std::cout &lt;&lt; &quot;ILoveyou&quot;; //没有写using namespace std; 必须加前缀 cout &lt;&lt; 1; //多个数据的输出 cout &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;姓名\\t&quot; &lt;&lt; &quot;年龄\\t&quot; &lt;&lt; &quot;编号\\n&quot;; struct MM mm = &#123;&quot;mm&quot;, 18, 1001&#125;; cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; //和上面一行代码效果一样 cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; mm.num &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; endl; //等效:cout&lt;&lt;&quot;\\n&quot;; std::cout &lt;&lt; std::endl; //一样的是std命名空间中的 return 0; &#125; 标准输入 cin+ &gt;&gt; 一起完成 输入不需要任何的格式控制字符 #include &lt;iostream&gt; using namespace std; //缺省std前缀的 struct MM &#123; char name[20]; int age; int num; &#125;; int main(int argc, char** argv) &#123; cout &lt;&lt; &quot;请输入一个整数:&quot;; int num; cin &gt;&gt; num; //变量名 cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;请输入一个字符串:&quot;; char str[20]; while (getchar() != &#39;\\n&#39;); //存在跳过显现:清空缓冲区 // setbuf(stdin, NULL); // //影响汉字输入，汉字的文件操作出现问题 fflush(stdin); // //C++中已经淘汰了，有时候使用没有效果 cin &gt;&gt; str; //数组名 cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input num and str:&quot;; cin &gt;&gt; num &gt;&gt; str; cout &lt;&lt; num &lt;&lt; &quot;\\t&quot; &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; &quot;input name,age,num:&quot;; struct MM temp; cin &gt;&gt; temp.name &gt;&gt; temp.age &gt;&gt; temp.num; cout &lt;&lt; &quot;姓名\\t年龄\\t编号&quot; &lt;&lt; endl; cout &lt;&lt; temp.name &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.age &lt;&lt; &quot;\\t&quot; &lt;&lt; temp.num &lt;&lt; endl; return 0; &#125; //用C++ 子函数的方式实现模拟登录 #include &lt;conio.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void Input(char* userName, char* passWord) &#123; //..... //登录实现密码不可见 cout &lt;&lt; &quot;用户名:&quot;; cin &gt;&gt; userName; while (getchar() != &#39;\\n&#39;); int i = 0; char key = 0; cout &lt;&lt; &quot;密 码:&quot;; while ((key = _getch()) != &#39;\\r&#39;) &#123; cout &lt;&lt; &quot;*&quot;; passWord[i++] = key; &#125; passWord[i] = &#39;\\0&#39;; cout &lt;&lt; endl; &#125; int Login(char* username, char* passWord, const char* root = &quot;root&quot;, const char* pass = &quot;12345&quot;) &#123; //比较验证 if (strcmp(username, root) == 0 &amp;&amp; strcmp(passWord, pass) == 0) &#123; return 1; &#125; return 0; &#125; int main(int argc, char** argv) &#123; char userName[20] = &#123;&quot;&quot;&#125;; char passWord[7] = &#123;&quot;&quot;&#125;; Input(userName, passWord); if (Login(userName, passWord) == 1) &#123; //登录成功 cout &lt;&lt; &quot;登录成功&quot; &lt;&lt; endl; &#125; else &#123; //打印用户名和密码错误 cout &lt;&lt; &quot;打印用户名和密码错误&quot; &lt;&lt; endl; &#125; return 0; &#125; 新基本数据类型bool类型 占用内存是1个字节 打印出来的值是： 0或者1 非零值表示成立 通常用的是false和true做初始化 #include &lt;iostream&gt; void testBool() &#123; bool bNum = 5; std::cout &lt;&lt; bNum &lt;&lt; std::endl; //一般是会用都用关键字初始化 bNum = false; bNum = true; //用途: //做开关 //做标记--&gt;查找类的操作 //做函数返回值 while (true) ; //死循环 &#125; int main(int argc, char** argv) &#123; testBool(); return 0; &#125; 引用类型把引用类型理解为一个起别名的用法 左值引用 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 // 引用类型 /* 左值引用: 当做函数参数: 直接修改实参，防止拷贝本产生 当做返回值: 增加左值使用 const属性限定问题 右值引用: 给右值起别名 当做函数参数: 函数只能传入右值 想要传入左值，使用move函数移动 */ #include &lt;iostream&gt; using namespace std; // 引用类型 // int&amp; x=b; void Modify(int&amp; x) &#123; x = 9999; &#125; //返回引用等效返回一个变量 //不能返回局部变量的引用 int g_num = 1001; int&amp; getValue() &#123; //就相当于与一个变量,可充当左值 return g_num; &#125; int getData() &#123; //返回变量相当于一个值,不能充当左值 return g_num; &#125; // char* str=&quot;Iloveyou&quot; void printString(const char* str) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; void modifyNum(const int&amp; num) &#123; // num++; //常引用不能做++ cout &lt;&lt; num &lt;&lt; endl; &#125; //只能传入右值 void modifyNum2(int&amp;&amp; num) &#123; num++; //提供修改接口 cout &lt;&lt; num &lt;&lt; endl; &#125; void testNew() &#123; int a = 1; int&amp; b = a; b = 1001; cout &lt;&lt; a &lt;&lt; endl; //当做函数返回值：增加左值使用好处 //当做函数参数：防止拷贝本的产生 Modify(b); cout &lt;&lt; a &lt;&lt; endl; // getData() = 1003; 错误，返回是一个值，不是一个变量，不能充当运算符左值 getValue() = 9999; // 等效于g_num=9999; cout &lt;&lt; g_num &lt;&lt; endl; //常量起别名 // C++对于const属性要求更为严格 // 1.用常引用 const int&amp; xx = 13; cout &lt;&lt; xx &lt;&lt; endl; //char* pStr = &quot;ILoveyou&quot;; //error const char* pstr = &quot;ILoveyou&quot;; printString(&quot;ILoveyou&quot;); char array[10] = &quot;LLLL&quot;; printString(array); //常引用不能修改 // 2.右值引用 &amp;&amp; ---&gt;提供修改接口 int&amp;&amp; yy = 134; yy = 55; const int c_num = 112; //常属性的变量，依旧是左值 // int&amp;&amp; zz = c_num; //错误 modifyNum(1); modifyNum2(23); //左值变成右值 int data = 1001; int&amp;&amp; data2 = move(data); //移动函数：把左值变成右值 int value = 1234; // modifyNum2(value); // //错误，用右值引用当做函数参数，不能传左值 modifyNum2(move(value)); //移动语义(完美转发) &#125; int main(int argc, char** argv) &#123; testNew(); return 0; &#125; C++结构体类型 类型名不在需要struct关键字了 C++结构体可以给成员直接赋初始值 C++结构体可以包含函数 其实C++结构体的处理就是按照类的方式处理（后续在意） 用了构造函数时候C++结构体和C语言结构体处理方案是完全不同的 #include &lt;iostream&gt; using namespace std; //描述的是事物特征和行为 struct MM &#123; char name[20] = &quot;MM&quot;; int age = 111; int num = 1001; void initData(const char* str, int age, int num); //在结构体声明 void printData() &#123; cout &lt;&lt; name &lt;&lt; &quot;\\t&quot; &lt;&lt; age &lt;&lt; &quot;\\t&quot; &lt;&lt; num &lt;&lt; endl; &#125; &#125;; //在外面实现，必须结构体名限定 void MM::initData(const char* str, int age, int num) &#123; strcpy_s(name, 20, str); //同名问题 MM::age = age; MM::num = num; &#125; int main(int argc, char** argv) &#123; // No.1 类型不需要struct MM mm; // cout &lt;&lt; mm.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm.num &lt;&lt; endl; mm.printData(); MM mm2 = &#123;&quot;mm2&quot;, 18, 1030&#125;; // cout &lt;&lt; mm2.name &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.age &lt;&lt; &quot;\\t&quot; &lt;&lt; mm2.num &lt;&lt; endl; mm2.printData(); mm2.initData(&quot;小芳&quot;, 18, 1004); mm2.printData(); return 0; &#125; C++枚举类型#include &lt;iostream&gt; using namespace std; enum State &#123; Open, Close &#125;; enum class Color &#123; Red, Blue &#125;; void print(int state) &#123; cout &lt;&lt; state &lt;&lt; endl; &#125; void printEnum(Color color) &#123; // cout &lt;&lt; color &lt;&lt; endl; 不能直接打印 &#125; void testEnum() &#123; print(1); print(Open); // C++的枚举类型不能当做一个简单的int类型 // print(Color::Red); //访问必须要用枚举类型名限定 printEnum(Color::Red); &#125; int main(int argc, char** argv) &#123; testEnum() return 0; &#125; C++string类型C++string本身是一个类，所以大家本节课只要学会使用即可，不需要问问什么 头文件： #include 注意点和cstring区别，这个是C语言头文件 没有用using namespace std ; string类型需要改为std::string 掌握string常用方式 创建方式 基本操作(比较,连接) 转C语言char* 微软帮助文档:basic_string 类 | Microsoft Docs #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main(int argc, char** argv) &#123; // std::string str; // No.1创建 string str1; str1 = &quot;ILoveyoudsfasdfasdfasdfasdfasd&quot;; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;ILoveyousdfsdafads&quot;; cout &lt;&lt; str2 &lt;&lt; endl; string str3(str2); string str4 = str2; cout &lt;&lt; str3 &lt;&lt; endl; cout &lt;&lt; str4 &lt;&lt; endl; // No.2 基本操作 cout &lt;&lt; (str3 == str4) &lt;&lt; endl; cout &lt;&lt; (str3 &gt;= str4) &lt;&lt; endl; string password; cin &gt;&gt; password; cout &lt;&lt; password; //原理是：运算符重载 后面会讲 //比较直接比 if (password == string(&quot;12345&quot;)) &#123; cout &lt;&lt; endl &lt;&lt; &quot;密码正确&quot; &lt;&lt; endl; &#125; int a = (int)1.3; // C语言强制类型转换 int b = int(1.34); // C++强制类型转换 //连接直接加法 string name = &quot;张三&quot;; string info = name + &quot;很帅&quot;; cout &lt;&lt; info &lt;&lt; endl; //上述复杂的用法 cout &lt;&lt; info.compare(name) &lt;&lt; endl; //和strcmp 返回值一样 cout &lt;&lt; info.append(name) &lt;&lt; endl; //下标的方式访问 cout &lt;&lt; info.length() &lt;&lt; endl; //当前长度 cout &lt;&lt; info.size() &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info[i]; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; info.length(); i++) &#123; cout &lt;&lt; info.at(i); &#125; cout &lt;&lt; endl; cout &lt;&lt; info.capacity() &lt;&lt; endl; //容量 //和C语言string.h有区别的 char* // 不能用%s的方式打印 // printf(&quot;%s\\n&quot;, info); // 图形库中传char* 函数 都不能直接用string类型 //提供两个函数： c_str() data(); printf(&quot;%s\\n&quot;, info.c_str()); printf(&quot;%s\\n&quot;, info.data()); return 0; &#125; C++自动推断类型 auto类型 decltype类型 #include &lt;iostream&gt; using namespace std; struct MM &#123; int age; &#125;; MM g_MM = &#123;12&#125;; MM* createMM() &#123; MM* p = &amp;g_MM; return p; &#125; int Max(int a, int b) &#123; return a &gt; b ? a : b; &#125; void print(int (*Max)(int, int), int a, int b) &#123; cout &lt;&lt; Max(a, b) &lt;&lt; endl; &#125; void printData(int (*)(int, int), int, int) &#123; cout &lt;&lt; &quot;另一个函数&quot; &lt;&lt; endl; &#125; int main(int argc, char** argv) &#123; // auto 类型自动推断: 一定要有赋值 所以不能单独定义变量 // auto a; 没有赋值 推断不出来 auto a = 1; // int a = 134; auto pMM = createMM(); cout &lt;&lt; pMM-&gt;age &lt;&lt; endl; auto pFunc = print; // void (*)(int(*)(int, int), int , int ) pFunc(Max, 1, 3); pFunc = printData; pFunc(Max, 1, 3); int* p = nullptr; //新的空 等效C语言NULL // decltype 不需要赋值 decltype(123) num = 123; // decltype(123) 表示一个int类型 //函数指针必须取地址 decltype(&amp;print) ppFunc; ppFunc = printData; //推断一个int decltype(num) Num = num; decltype(&amp;num) pNum = &amp;num; //当你们用的时候，不知道类型，推断定义变量去赋值 return 0; &#125; C++动态内存申请C++申请的内存是自由存储区的，C语言的堆区内存，所以C++类的对象内存不能用malloc申请 &#x2F;&#x2F; IMAGE * new申请内存 申请单个变量内存 申请一段内存 申请内存可以手动初始化 申请内存后可以再分配 delete释放内存 释放单个变量内存：delete 指针名; 释放一段变量内存： delete[] 指针名; #include &lt;iostream&gt; using namespace std; struct MM &#123; char name[20]; int age; int num; &#125;; void testOne() &#123; int* pInt = new int; *pInt = 123; cout &lt;&lt; pInt[0] &lt;&lt; endl; delete pInt; pInt = nullptr; char* pc = new char; delete pc; int* pNum = new int(1234); //申请并且初始化 cout &lt;&lt; pNum[0] &lt;&lt; endl; delete pNum; MM* pMM = new MM(&#123;&quot;name&quot;, 12, 1101&#125;); cout &lt;&lt; pMM-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;age &lt;&lt; &quot;\\t&quot; &lt;&lt; pMM-&gt;num &lt;&lt; endl; &#125; void testTwo() &#123; //一段内存的申请 int size = 4; int* pArray = new int[size]; // int pArray[4]; MM* pMM = new MM[4]; // MM pMM[4]; delete[] pArray; delete[] pMM; pArray = nullptr; pMM = nullptr; int* pNum = new int[4]&#123;1, 2, 3, 4&#125;; for (int i = 0; i &lt; 4; i++) &#123; cout &lt;&lt; pNum[i] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; delete[] pNum; pNum = nullptr; &#125; void testThree() &#123; char* pMem = new char[1024]; //在原来上面拿个20字节存整数 int* pInt = new (pMem + 0) int[5]&#123;1, 2, 3, 4, 5&#125;; //在原来上面拿出20个存字符 char* pChar = new (pMem + 20) char[20]&#123;&quot;ILoveyou&quot;&#125;; //等效：char* pChar = new(pInt + 5) char[20]&#123;&quot;ILoveyou&quot;&#125;; delete[] pMem; pMem = nullptr; &#125; int main(int argc, char** argv) &#123; testOne(); testTwo(); testThree(); return 0; &#125; 小试牛刀#include &lt;iostream&gt; using namespace std; int** create2DArray(int row, int cols) &#123; int** pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; return pArray; &#125; void create2DArray(int**&amp; pArray, int row, int cols) &#123; pArray = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; pArray[i] = new int[cols]; &#125; &#125; void Free(int**&amp; array, int row) &#123; for (int i = 0; i &lt; row; i++) &#123; delete[] array[i]; &#125; delete[] array; array = nullptr; &#125; int main(int argc, char** argv) &#123; int** p2D = nullptr; int cols, rows; //让用户输入行列 cin &gt;&gt; rows &gt;&gt; cols; // create2DArray(p2D, rows, cols); p2D = create2DArray(rows, cols); //让用户赋值 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cin &gt;&gt; p2D[i][j]; &#125; &#125; //打印结果 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; cout &lt;&lt; p2D[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; //释放 Free(p2D, rows); &#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"}]},{"title":"计组-计算机硬件基础","slug":"计算机硬件基础","date":"2022-05-10T02:30:46.000Z","updated":"2023-02-21T04:44:28.260Z","comments":true,"path":"2022/05/10/计算机硬件基础/","link":"","permalink":"http://am900skp.github.io/2022/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"参考视频: 计算机硬件基础 机箱 够不够大. 主板能不能放下 散热 外观 主板 接口,型号,品牌… 可以理解为电路板 CPU:中央处理器 整个机箱里最重要的就是CPU,就是大脑 用于电脑下命令的 CPU如果卡了,其他的部件性能再好也没用 CPU厂商 IntelCPU实战分析Intel中国官网请点击此蓝色字体Intel 代表的处理器型号: 赛扬,奔腾 酷睿 core四类,分等级 :i3 i5 i7 i9 从*大体来看,越来越好*,注意是同代相比,不能拿今年的i5和几年前的i7相比 i3 针对的是轻量化办公, (打字,文稿,处理文档,客户沟通等等) i5 处理简单视频, 程序, 简答项目,游戏 i7 发烧, 大型游戏, 大型工程, 专业用户… i9 顶级性能 解读:Intel 第12代酷睿 i9-12900K台式机CPU处理器 16核24线程 单核睿频至高可达5.2Ghz 30M三级缓存 i9-12900K i9就不解释了,就代表酷睿的这一系列产品 12900K: (12就是代号) 读作:i9第十二代 如i9-9900K , 9900K中的第一个9是代号 读作:i9第九代 具体代号指是哪一年的产品 ,去官网搜索就可以了 后面的900K 在900K中,第一个9代表的是性能 数字排名[0-9] 举个例子, i9-12900K 和 i9-12700K ,那显然是i9-12900K性能好了(9&gt;7嘛) 但如果是i3-9500 i5-2700 ,这样就不好比较了, 可以google搜索,找一下测评视频,这两款cpu跑分怎么样 中间的两个0 不用管,没有什么特别的意义,注意台式机大部分是00 末尾的字母:K? KF? G1? G7? 产品后缀,同代相比G7是一定比G1好的 F,Intel全新推出的后缀,代表无内置核心显卡版本,显然买带F的需要自己配显卡 G,Y,主打续航,不是性能 U 稍微有点续航, 办公 H 焊接,不可拆卸,打游戏的 大多数台式是不带字母的, 如果带基本都是K,超频(满功率运行) 后缀比较多, 这里没有介绍的搜索就可以 英特尔® 处理器名称和编号请点击此蓝色字体 CPU厂商 AMDCPU实战分析AMD中国官网请点击此蓝色字体 AMD 于 2016&#x2F;8&#x2F;17 推出 Zen 架构，但直到 2017&#x2F;3 才发布第一款 Zen 架构处理器。现在已经进化到第四代，分别是 Zen、Zen+、Zen2、Zen3。 14nm Zen：2017&#x2F;3 12nm Zen+：2018&#x2F;4 7nm Zen2：2019&#x2F;7 7nm Zen3：2020&#x2F;11 在解释 AMD 命名规则前，先看看一些 AMD 处理器型号 Ryzen Threadripper 1950X Ryzen 7 2700X Ryzen 5 3600XT Ryzen 7 4700G …. 命名规则 AMD Ryzen 5 3600X AMD: Company Name Ryzen: Brand Name 5: CPU Family 3: CPU Generation 6: CPU Performance Level 00: Model Number Or SKU Number X: Power Suffix 型号的第一个数字 这里说的型号，是指由 4 个数字和字母后缀组成的那段字符，例如“5900X”。AMD 官方通常根据型号的第一个数字，把处理器称为 xxxx 系列，例如 5700U 是 5000 系列移动处理器，5900X 是 5000 系列桌面处理器。 Ryzen 后的数字 Ryzen 后面的系列，主要有 3、5、7、9、Threadripper。除了有 Ryzen，还有 Ryzen pro、Ryzen Threadripper Pro，它们主要面向商业用途，而不是大众消费者。 同一个系列下，Ryzen 后面的第一个数字越大，性能通常越强，最强的是 Threadripper(线程撕裂者)。如果系列不同，则不一定。 比如 Ryzen 7 5800X 的性能比 Ryzen 9 3900XT 强，虽然前者是 Ryzen 7，后者是 Ryzen 9，似乎 9 强于 7，但前者是 5000 系列，后者是 3000 系列。不同的系列代表不同的架构，前者是 Zen3 架构，后者是 Zen2 架构。 CPU性能天梯图请点击此蓝色字体 总结:比较两款处理器的性能，首先看型号的第一个数字，即先看系列(架构)，系列(架构)相同，则看 代号后的数字，数字越大性能通常越强。如果系列不同，则需要考虑更多因素。16核24线程 可以理解为16个脑子,24个脑仁, 肯定是越多越好 单核 主频 睿频 主频:智商.平常工作时的节奏 睿频:智商爆表, 比如玩游戏时的节奏,集中注意力的运行这个东西 30M三级缓存 就相当于是库存,能存多块,同样是越高越好 如何查看电脑CPU详细信息 CPU-Z下载地址请点击此蓝色字体 内存(RAM 运行内存) 意味着最大能开多少的空间 每个正在运行的软件都会占用内存空间 也就是说此电脑后台和前台能同时运行多少APP 现在是2022年8月, 就电脑来讲大部分都是16G运行内存了,属于是最低标准 内存频率的用途DDR4 3200 代号 DDR1 DDR2 DDR3 3200 当然也是越高越好… 但是需要注意的是, 频率越高,需要的主板应当越好 电源(主要针对台式机) 好的CPU,好的显卡,功率可能会更大 功率如果不够,硬件可能出现带不动的情况,导致不能发挥顶级的性能 硬盘注意:硬盘和内存是不一样的 内存 :吃完了扔了,扔完再放(完全是临时的东西) 一旦关机,临时的东西全部释放, 内存条 保存的是开机时运行的APP和数据 硬盘(存储永久数据的) 机械硬盘(不推荐个人用户买机械硬盘) 最古老的硬盘 现在是2022年8月,机械硬盘并不流行 举个例子: 2TB 256MB 7200PRM SATA接口 2TB : 2000G, 256MB: 缓存 7200RPM: 转 硬盘的转速,越大越好 SATA接口: 详见文章开篇电路板图片 固态硬盘(部分可支持台式,笔记本互联) SATA接口 为了兼容旧电脑 MiniSATA PCI-E U.2 M.2 读写速度,缓存速度 机械银盘读写速度都 &lt;&#x3D; 110MB&#x2F;S 固态硬盘读写速度 SATA接口 &lt;&#x3D; 550 MB&#x2F;s MiniSATA接口,老式笔记本电脑使用,即将被淘汰 PCI-E占用了一个显卡的接口位置 读6000M&#x2F;s 写 4000M&#x2F;s(不推荐),注意查看主板是否支持 U.2 即将被淘汰 M.2(21世纪20年代的主流硬盘, 遵循NVME协议) 读写速度没有看到具体上限 显卡(图形显示处理器,3D,动画渲染的能力)AMD NVIDIA IntelArc(新潮流) NVIDIA(玩游戏推荐) GeForce900 GTX980 GeForce10 GTX1050TI GeForce16 GeForce RTX 20系列 RTX2060(RTX采用了光线追中技术,游戏里的光反射,画面更加好) GeForce RTX 30系列 RTX2080 RTX3090 同代相比Ti比super好,super比什么都不带的好 显存 能丢多少图形渲染到显卡里(3A大作) 显卡分类 集成显卡(核显): 买CPU送显卡 作用就是链接显示器(屏幕): 显示内容 ,玩游戏不行 独立显卡 注意: Intel CPU后缀是F的都不带显卡 如何查看自己电脑显卡 GPU-Z下载地址请点击此蓝色字体 桌面显卡性能天梯图请点击此蓝色字体 显示器 分辨率越高,画面显示越好,显卡负载越大 1080p 3060 2k 3060 4k 3080TI 3090 屏幕刷新率 144hz 感谢Frank","categories":[{"name":"计组","slug":"计组","permalink":"http://am900skp.github.io/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"计组","slug":"计组","permalink":"http://am900skp.github.io/tags/%E8%AE%A1%E7%BB%84/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://am900skp.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计网","slug":"计网","permalink":"http://am900skp.github.io/categories/%E8%AE%A1%E7%BD%91/"},{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/categories/%E5%91%A8%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Rust","slug":"Rust","permalink":"http://am900skp.github.io/categories/Rust/"},{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"cpp","slug":"cpp","permalink":"http://am900skp.github.io/categories/cpp/"},{"name":"计组","slug":"计组","permalink":"http://am900skp.github.io/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://am900skp.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计网","slug":"计网","permalink":"http://am900skp.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"周记","slug":"周记","permalink":"http://am900skp.github.io/tags/%E5%91%A8%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"http://am900skp.github.io/tags/MySQL/"},{"name":"Rust","slug":"Rust","permalink":"http://am900skp.github.io/tags/Rust/"},{"name":"数据结构","slug":"数据结构","permalink":"http://am900skp.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://am900skp.github.io/tags/C/"},{"name":"计组","slug":"计组","permalink":"http://am900skp.github.io/tags/%E8%AE%A1%E7%BB%84/"}]}